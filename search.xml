<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019长安杯wp</title>
    <url>/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/</url>
    <content><![CDATA[<p>本篇博客简单记录了我对2019长安杯电子数据取证比赛的学习复盘</p>
<span id="more"></span>

<h1 id="赛题背景"><a href="#赛题背景" class="headerlink" title="赛题背景"></a>赛题背景</h1><p>在一起电诈案件中，受害者称自己的银行卡被他人冒用，曾收到假冒公安的短信，因为自己在一个 P2P 网站中理财，假冒公安称该网站已被列外非法网站，要自己到公安备案网站填写自己的信息，并帮助自己追回本金，因此信以为真，在网站上填写了自己的信息和绑定 的银行卡信息；办案机关推测嫌疑人可能是获取了 P2P 网站中的注册用户信息，从而进行定向诈骗，因此调取了 P2P 理财网站的服务器，现委派你对该服务器进行电子数据取证</p>
<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu1.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu2.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu3.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu4.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu5.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu6.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu7.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu8.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu9.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu10.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu11.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu12.png" class="">

<h1 id="检材一"><a href="#检材一" class="headerlink" title="检材一"></a>检材一</h1><p>你获得该 P2P 理财网站服务器硬盘镜像文件“检材 1.E01”，根据这个镜像文件，回答下列问题</p>
<h2 id="计算“检材-1-E01”镜像的-SHA256-值是多少"><a href="#计算“检材-1-E01”镜像的-SHA256-值是多少" class="headerlink" title="计算“检材 1.E01”镜像的 SHA256 值是多少"></a>计算“检材 1.E01”镜像的 SHA256 值是多少</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/1.png" class="">

<h2 id="该服务器的操作系统版本是什么"><a href="#该服务器的操作系统版本是什么" class="headerlink" title="该服务器的操作系统版本是什么"></a>该服务器的操作系统版本是什么</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/2.png" class="">

<h2 id="该服务器内核版本是多少"><a href="#该服务器内核版本是多少" class="headerlink" title="该服务器内核版本是多少"></a>该服务器内核版本是多少</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/3.png" class="">

<h2 id="原服务器存在多少硬盘分区？"><a href="#原服务器存在多少硬盘分区？" class="headerlink" title="原服务器存在多少硬盘分区？"></a>原服务器存在多少硬盘分区？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/4.png" class="">

<p>2个</p>
<h2 id="原服务器中硬盘分区中含有一个-LVM-逻辑卷的分区，请找出该分区内开始的逻辑区块地址（LBA）"><a href="#原服务器中硬盘分区中含有一个-LVM-逻辑卷的分区，请找出该分区内开始的逻辑区块地址（LBA）" class="headerlink" title="原服务器中硬盘分区中含有一个 LVM 逻辑卷的分区，请找出该分区内开始的逻辑区块地址（LBA）"></a>原服务器中硬盘分区中含有一个 LVM 逻辑卷的分区，请找出该分区内开始的逻辑区块地址（LBA）</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/5.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/6.png" class="">

<h2 id="该-LVM-逻辑卷分区内-root-逻辑卷的文件系统是什么？"><a href="#该-LVM-逻辑卷分区内-root-逻辑卷的文件系统是什么？" class="headerlink" title="该 LVM 逻辑卷分区内 root 逻辑卷的文件系统是什么？"></a>该 LVM 逻辑卷分区内 root 逻辑卷的文件系统是什么？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/7.png" class="">

<h2 id="该-LVM-逻辑卷分区内-root-逻辑卷的物理大小是多少？（单位：byte）"><a href="#该-LVM-逻辑卷分区内-root-逻辑卷的物理大小是多少？（单位：byte）" class="headerlink" title="该 LVM 逻辑卷分区内 root 逻辑卷的物理大小是多少？（单位：byte）"></a>该 LVM 逻辑卷分区内 root 逻辑卷的物理大小是多少？（单位：byte）</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/8.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/9.png" class="">

<p>与选项 C 最接近</p>
<h2 id="请找出该服务器的网站访问端口是什么？"><a href="#请找出该服务器的网站访问端口是什么？" class="headerlink" title="请找出该服务器的网站访问端口是什么？"></a>请找出该服务器的网站访问端口是什么？</h2><p>开启 docker 并查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/10.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/11.png" class="">

<p>即主机（0.0.0.0）的 8091 端口映射到 nginx 服务器的 80 端口，所以该服务器的网站访问端口肯定是 8091</p>
<h2 id="该服务器中运行了-docker-应用，在本地有多少-docker-镜像？"><a href="#该服务器中运行了-docker-应用，在本地有多少-docker-镜像？" class="headerlink" title="该服务器中运行了 docker 应用，在本地有多少 docker 镜像？"></a>该服务器中运行了 docker 应用，在本地有多少 docker 镜像？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/12.png" class="">

<p>明显 11 个</p>
<h2 id="该-docker-应用的-server-版本是多少？"><a href="#该-docker-应用的-server-版本是多少？" class="headerlink" title="该 docker 应用的 server 版本是多少？"></a>该 docker 应用的 server 版本是多少？</h2><p>见第 12 题</p>
<h2 id="该-docker-应用中总共有多少容器节点？"><a href="#该-docker-应用中总共有多少容器节点？" class="headerlink" title="该 docker 应用中总共有多少容器节点？"></a>该 docker 应用中总共有多少容器节点？</h2><p>见第 12 题</p>
<h2 id="运行中的容器节点有多少？"><a href="#运行中的容器节点有多少？" class="headerlink" title="运行中的容器节点有多少？"></a>运行中的容器节点有多少？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/13.png" class="">

<p>由上图可见，docker 应用的 server 版本为18.09.7，docker 应用中总共10个容器节点，运行中的容器节点有3个</p>
<h2 id="在运行中的容器节点中，其中一台容器名称为-romantic-varahamihira-的容器节点，它的-hostname-是什么？"><a href="#在运行中的容器节点中，其中一台容器名称为-romantic-varahamihira-的容器节点，它的-hostname-是什么？" class="headerlink" title="在运行中的容器节点中，其中一台容器名称为 romantic_varahamihira 的容器节点，它的 hostname 是什么？"></a>在运行中的容器节点中，其中一台容器名称为 romantic_varahamihira 的容器节点，它的 hostname 是什么？</h2><p>所谓 hostname 其实就是容器 ID</p>
<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/14.png" class="">

<h2 id="上题容器节点中，占用了主机的哪个端口？"><a href="#上题容器节点中，占用了主机的哪个端口？" class="headerlink" title="上题容器节点中，占用了主机的哪个端口？"></a>上题容器节点中，占用了主机的哪个端口？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/15.png" class="">

<p>很显然未占用端口</p>
<h2 id="在运行中的容器节点中，其中一台容器-ID-为-15debb1824e6-的容器节点，它运行了什么服务？"><a href="#在运行中的容器节点中，其中一台容器-ID-为-15debb1824e6-的容器节点，它运行了什么服务？" class="headerlink" title="在运行中的容器节点中，其中一台容器 ID 为 15debb1824e6 的容器节点，它运行了什么服务？"></a>在运行中的容器节点中，其中一台容器 ID 为 15debb1824e6 的容器节点，它运行了什么服务？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/16.png" class="">

<h2 id="上题容器节点中，占用了主机的哪个端口？-1"><a href="#上题容器节点中，占用了主机的哪个端口？-1" class="headerlink" title="上题容器节点中，占用了主机的哪个端口？"></a>上题容器节点中，占用了主机的哪个端口？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/17.png" class="">

<h2 id="该服务器中网站运行在-docker-容器中，其中-web-服务使用的是什么应用？"><a href="#该服务器中网站运行在-docker-容器中，其中-web-服务使用的是什么应用？" class="headerlink" title="该服务器中网站运行在 docker 容器中，其中 web 服务使用的是什么应用？"></a>该服务器中网站运行在 docker 容器中，其中 web 服务使用的是什么应用？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/18.png" class="">

<h2 id="上题所述运行-web-服务的容器节点，使用的镜像名称是什么？"><a href="#上题所述运行-web-服务的容器节点，使用的镜像名称是什么？" class="headerlink" title="上题所述运行 web 服务的容器节点，使用的镜像名称是什么？"></a>上题所述运行 web 服务的容器节点，使用的镜像名称是什么？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/19.png" class="">

<h2 id="上题所述容器节点占用的容器端口是什么？"><a href="#上题所述容器节点占用的容器端口是什么？" class="headerlink" title="上题所述容器节点占用的容器端口是什么？"></a>上题所述容器节点占用的容器端口是什么？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/20.png" class="">

<h2 id="网站目录所在的容器内部路径为"><a href="#网站目录所在的容器内部路径为" class="headerlink" title="网站目录所在的容器内部路径为"></a>网站目录所在的容器内部路径为</h2><p>就开了 3 个容器，结合相应选项进到容器里找网站根目录就好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 53 /bin/bash</span><br></pre></td></tr></table></figure>

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/21.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/22.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/23.png" class="">

<p>PS：一般来说，项目都是从 github 上 clone 下来的，所以根目录应该都是在 home 目录下</p>
<h2 id="网站目录所在的主机路径为下列选项中的哪个？"><a href="#网站目录所在的主机路径为下列选项中的哪个？" class="headerlink" title="网站目录所在的主机路径为下列选项中的哪个？"></a>网站目录所在的主机路径为下列选项中的哪个？</h2><img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/24.png" class="">

<h2 id="网站日志的路径在哪？"><a href="#网站日志的路径在哪？" class="headerlink" title="网站日志的路径在哪？"></a>网站日志的路径在哪？</h2><p>结合选项进入容器，<code>cat /etc/nginx/nginx.conf</code> 即可</p>
<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/25.png" class="">

<p>或者就四个选项都找一遍</p>
<h2 id="案发当时，该服务器的原始-IP-地址是多少？"><a href="#案发当时，该服务器的原始-IP-地址是多少？" class="headerlink" title="案发当时，该服务器的原始 IP 地址是多少？"></a>案发当时，该服务器的原始 IP 地址是多少？</h2><p>将上题找到的日志文件导出（不知为啥火眼导出会失败，取证大师就可以直接打开）</p>
<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/26.png" class="">

<p>在日志最后很明显能看出用户 192.168.184.133 在爆破 admin 用户的 password ，所以基本可以确定这个时候就是“案发当时”，服务器的原始 IP 地址为 192.168.184.128:8091 ，嫌疑人的 IP 地址为 192.168.184.133</p>
<h2 id="在-docker-中，各容器节点和主机之间的网络连接模式是什么？"><a href="#在-docker-中，各容器节点和主机之间的网络连接模式是什么？" class="headerlink" title="在 docker 中，各容器节点和主机之间的网络连接模式是什么？"></a>在 docker 中，各容器节点和主机之间的网络连接模式是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect ID</span><br></pre></td></tr></table></figure>

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/27.png" class="">

<h2 id="当我们想将网站重构好时，访问网站时，web-应用在其中承担什么样的工作？"><a href="#当我们想将网站重构好时，访问网站时，web-应用在其中承担什么样的工作？" class="headerlink" title="当我们想将网站重构好时，访问网站时，web 应用在其中承担什么样的工作？"></a>当我们想将网站重构好时，访问网站时，web 应用在其中承担什么样的工作？</h2><p>转发（存疑）</p>
<h2 id="从网站日志中，我们可以看到嫌疑人入侵服务器所使用的-IP-是"><a href="#从网站日志中，我们可以看到嫌疑人入侵服务器所使用的-IP-是" class="headerlink" title="从网站日志中，我们可以看到嫌疑人入侵服务器所使用的 IP 是"></a>从网站日志中，我们可以看到嫌疑人入侵服务器所使用的 IP 是</h2><p>见第 23 题</p>
<h2 id="网站目录中网站的主配置文件是哪一个？-相对路径"><a href="#网站目录中网站的主配置文件是哪一个？-相对路径" class="headerlink" title="网站目录中网站的主配置文件是哪一个？(相对路径)"></a>网站目录中网站的主配置文件是哪一个？(相对路径)</h2><p>进入网站根目录，发现有 README.md 文件，打开看看</p>
<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/28.png" class="">

<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/29.png" class="">

<p>其实在取证大师里打开会更好看一点</p>
<img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/30.png" class="">

<p>所以其实题目里所指的网站的主配置文件应该是 node js 的配置文件，查看目录可以发现 node 服务端文件都在 <code>/server</code> 目录下，结合选项 <code>/server/index.js</code> 最符合</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/31.png" class="">

<h2 id="该网站使用的是什么数据库？"><a href="#该网站使用的是什么数据库？" class="headerlink" title="该网站使用的是什么数据库？"></a>该网站使用的是什么数据库？</h2><p>README.md 里清清楚楚</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/32.png" class="">

<h2 id="所使用数据库的端口是多少？"><a href="#所使用数据库的端口是多少？" class="headerlink" title="所使用数据库的端口是多少？"></a>所使用数据库的端口是多少？</h2><p>由目录结构可以知道，数据库的配置文件是 db.js ，打开看看</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/33.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/34.png" class="">

<p>结合</p>
<p><code>mongoose.connect(&#39;mongodb://username:password@host:port/database?options.....&#39;)</code> 和上图可知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库所在服务器的IP为 192.168.184.129</span><br><span class="line">端口为 27017</span><br><span class="line">数据库的用户名/密码为 root/root</span><br><span class="line">数据库库名为 tougu</span><br></pre></td></tr></table></figure>

<h2 id="数据库所在服务器-IP-是多少？"><a href="#数据库所在服务器-IP-是多少？" class="headerlink" title="数据库所在服务器 IP 是多少？"></a>数据库所在服务器 IP 是多少？</h2><p>见第 29 题</p>
<h2 id="数据库的用户名是什么？"><a href="#数据库的用户名是什么？" class="headerlink" title="数据库的用户名是什么？"></a>数据库的用户名是什么？</h2><p>见第 29 题</p>
<h2 id="数据库的密码是什么？"><a href="#数据库的密码是什么？" class="headerlink" title="数据库的密码是什么？"></a>数据库的密码是什么？</h2><p>见第 29 题</p>
<h2 id="该网站所使用的数据库库名是什么？"><a href="#该网站所使用的数据库库名是什么？" class="headerlink" title="该网站所使用的数据库库名是什么？"></a>该网站所使用的数据库库名是什么？</h2><p>见第 29 题</p>
<h2 id="在案发时，黑客对该服务器某个文件-x2F-目录进行了加密，请问是哪个文件-x2F-目录？"><a href="#在案发时，黑客对该服务器某个文件-x2F-目录进行了加密，请问是哪个文件-x2F-目录？" class="headerlink" title="在案发时，黑客对该服务器某个文件&#x2F;目录进行了加密，请问是哪个文件&#x2F;目录？"></a>在案发时，黑客对该服务器某个文件&#x2F;目录进行了加密，请问是哪个文件&#x2F;目录？</h2><p>history</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/35.png" class="">

<p>显然是 <code>.bash_history</code> 目录</p>
<h1 id="检材二"><a href="#检材二" class="headerlink" title="检材二"></a>检材二</h1><p>你获得了该 P2P 理财网站数据库服务器硬盘镜像文件“检材 2.E01”，根据这个镜像文件，回答下列问题</p>
<h2 id="该数据库服务器使用数据库的安装路径在哪？"><a href="#该数据库服务器使用数据库的安装路径在哪？" class="headerlink" title="该数据库服务器使用数据库的安装路径在哪？"></a>该数据库服务器使用数据库的安装路径在哪？</h2><p>已知网站服务器使用的是 mongo 数据库，所以我们反向查找数据库的安装路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name mongo</span><br></pre></td></tr></table></figure>

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/36.png" class="">

<p>结合选项显然是 <code>/var/lib/mongo/</code></p>
<h2 id="数据库的配置文件的路径？"><a href="#数据库的配置文件的路径？" class="headerlink" title="数据库的配置文件的路径？"></a>数据库的配置文件的路径？</h2><p> 先去数据库的安装路径下看看</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/37.png" class="">

<p>发现没有 .conf 的配置文件，那就再去 etc 目录下找找（配置文件一般都在 etc 目录下），果然就发现啦</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/38.png" class="">

<p>所以数据库配置文件的路径就是 <code>/etc/mongod.conf</code></p>
<h2 id="数据库的日志文件路径在哪里？"><a href="#数据库的日志文件路径在哪里？" class="headerlink" title="数据库的日志文件路径在哪里？"></a>数据库的日志文件路径在哪里？</h2><p>一般日志文件的路径在配置文件中都会有记录，所以打开配置文件看看</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/39.png" class="">

<p>里面果然有记录日志文件的路径：<code>/var/log/mongodb/mongod.log</code></p>
<p>还有数据库的安装路径：<code>/var/lib/mongo/</code>（第 35 题）</p>
<h2 id="该数据库的网站用户表名是什么？"><a href="#该数据库的网站用户表名是什么？" class="headerlink" title="该数据库的网站用户表名是什么？"></a>该数据库的网站用户表名是什么？</h2><p>因为读取用户的注册信息在前端，所以我们需要回到前端（检材1）来查找，先看看和网站主配置文件同目录的 api.js 文件</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/40.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/41.png" class="">

<p>显然该数据库的网站用户表名是“Users”</p>
<h2 id="该数据库中网站用户表里的密码字段加密方式是"><a href="#该数据库中网站用户表里的密码字段加密方式是" class="headerlink" title="该数据库中网站用户表里的密码字段加密方式是"></a>该数据库中网站用户表里的密码字段加密方式是</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/42.png" class="">

<p>可以看到，在 “const password &#x3D; req.query.password;” 之后，password 没有经过任何其他操作就直接与 data[0].password 进行比较，因此可以判断密码字段是未加密的</p>
<h2 id="该用户表被做过什么样的修改？"><a href="#该用户表被做过什么样的修改？" class="headerlink" title="该用户表被做过什么样的修改？"></a>该用户表被做过什么样的修改？</h2><p>&#x2F;root&#x2F;.dbshell 文件中记录了 mongodb 的 shell 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more /root/.dbshell</span><br></pre></td></tr></table></figure>

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/43.png" class="">

<p>很明显进行了对用户密码的更新操作（即修改用户密码）</p>
<h2 id="嫌疑人对该数据库的哪个库进行了风险操作？"><a href="#嫌疑人对该数据库的哪个库进行了风险操作？" class="headerlink" title="嫌疑人对该数据库的哪个库进行了风险操作？"></a>嫌疑人对该数据库的哪个库进行了风险操作？</h2><p>看数据库的日志文件</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/44.png" class="">

<p>很明显是对库名为 “tougu” 的数据库进行了删库操作</p>
<h2 id="嫌疑人对上述数据库做了什么样的风险操作？"><a href="#嫌疑人对上述数据库做了什么样的风险操作？" class="headerlink" title="嫌疑人对上述数据库做了什么样的风险操作？"></a>嫌疑人对上述数据库做了什么样的风险操作？</h2><p>见第 41 题</p>
<h2 id="嫌疑人在哪个时间段内登陆数据库？"><a href="#嫌疑人在哪个时间段内登陆数据库？" class="headerlink" title="嫌疑人在哪个时间段内登陆数据库？"></a>嫌疑人在哪个时间段内登陆数据库？</h2><p>last 命令查看登录历史</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/45.png" class="">

<p>18:05-18:26 与选项 D 最接近</p>
<h2 id="嫌疑人在什么时间对数据库进行了-42-题所述的风险操作？"><a href="#嫌疑人在什么时间对数据库进行了-42-题所述的风险操作？" class="headerlink" title="嫌疑人在什么时间对数据库进行了 42 题所述的风险操作？"></a>嫌疑人在什么时间对数据库进行了 42 题所述的风险操作？</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/46.png" class="">

<h1 id="检材三"><a href="#检材三" class="headerlink" title="检材三"></a>检材三</h1><p>经调查，你扣押获得了一台嫌疑人使用过的 VPN 服务器，并用服务器硬盘制作成“检材 3.E01” 镜像文件，根据该镜像文件，回答下列问题</p>
<h2 id="该服务器所使用的-VPN-软件，采用了什么协议"><a href="#该服务器所使用的-VPN-软件，采用了什么协议" class="headerlink" title="该服务器所使用的 VPN 软件，采用了什么协议"></a>该服务器所使用的 VPN 软件，采用了什么协议</h2><p>history</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/47.png" class="">

<p>能看到很多关于 PPTP 协议的操作</p>
<h2 id="该服务器的时区为"><a href="#该服务器的时区为" class="headerlink" title="该服务器的时区为"></a>该服务器的时区为</h2><p>还是在 history 里</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/48.png" class="">

<p>可见设置了多次时区，最后一次将时区设置为 Asia&#x2F;Dhaka</p>
<p>或者 timedatectl</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/49.png" class="">

<h2 id="该服务器中对-VPN-软件配置的-option-的文件位置在哪里？"><a href="#该服务器中对-VPN-软件配置的-option-的文件位置在哪里？" class="headerlink" title="该服务器中对 VPN 软件配置的 option 的文件位置在哪里？"></a>该服务器中对 VPN 软件配置的 option 的文件位置在哪里？</h2><p>history 里也有关于 VPN 软件配置的 option 文件的记录</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/50.png" class="">

<h2 id="VPN-软件开启了写入客户端的连接与断开，请问写入的文件是哪个？"><a href="#VPN-软件开启了写入客户端的连接与断开，请问写入的文件是哪个？" class="headerlink" title="VPN 软件开启了写入客户端的连接与断开，请问写入的文件是哪个？"></a>VPN 软件开启了写入客户端的连接与断开，请问写入的文件是哪个？</h2><p>开启“写入客户端的连接与断开”这个功能肯定是和配置文件有关，执行这个功能肯定是和日志文件有关。history 可以发现 pptp 配置文件的所在路径</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/51.png" class="">

<p>查看配置文件</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/52.png" class="">

<p>显示为 wtmp 文件</p>
<h2 id="VPN-软件客户端被分配的-IP-范围是"><a href="#VPN-软件客户端被分配的-IP-范围是" class="headerlink" title="VPN 软件客户端被分配的 IP 范围是"></a>VPN 软件客户端被分配的 IP 范围是</h2><p>还是 pptp 的配置文件</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/53.png" class="">

<p>检材三为 VPN 服务器镜像，所以分配本地IP（服务端），那么 VPN 软件客户端显然就分配远程 IP，也就是 192.168.184.12-192.168.184.18</p>
<h2 id="由-option-文件可以知道，option-文件配置了-VPN-软件的日志路径为"><a href="#由-option-文件可以知道，option-文件配置了-VPN-软件的日志路径为" class="headerlink" title="由 option 文件可以知道，option 文件配置了 VPN 软件的日志路径为"></a>由 option 文件可以知道，option 文件配置了 VPN 软件的日志路径为</h2><p>由第 47 题知道 option 文件的所在路径为 <code>/etc/ppp/options.pptpd</code> ，查看一下</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/54.png" class="">

<h2 id="VPN-软件记录了客户端使用的名称和密码，记录的文件是"><a href="#VPN-软件记录了客户端使用的名称和密码，记录的文件是" class="headerlink" title="VPN 软件记录了客户端使用的名称和密码，记录的文件是"></a>VPN 软件记录了客户端使用的名称和密码，记录的文件是</h2><p>option 文件里有</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/55.png" class="">

<h2 id="在服务器时间-2019-07-02-02-08-27-登陆过-VPN-客户端的用户名是哪个？"><a href="#在服务器时间-2019-07-02-02-08-27-登陆过-VPN-客户端的用户名是哪个？" class="headerlink" title="在服务器时间 2019-07-02_02:08:27 登陆过 VPN 客户端的用户名是哪个？"></a>在服务器时间 2019-07-02_02:08:27 登陆过 VPN 客户端的用户名是哪个？</h2><p>查看第 50 题找到的日志文件</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/56.png" class="">

<p>显然用户名为 root</p>
<h2 id="上题用户登陆时的客户-IP-是什么？"><a href="#上题用户登陆时的客户-IP-是什么？" class="headerlink" title="上题用户登陆时的客户 IP 是什么？"></a>上题用户登陆时的客户 IP 是什么？</h2><p>见第 52 题图，显然为 192.168.43.238</p>
<h2 id="通过-IP-172-16-80-188-登陆-VPN-服务器的用户名是哪个？"><a href="#通过-IP-172-16-80-188-登陆-VPN-服务器的用户名是哪个？" class="headerlink" title="通过 IP 172.16.80.188 登陆 VPN 服务器的用户名是哪个？"></a>通过 IP 172.16.80.188 登陆 VPN 服务器的用户名是哪个？</h2><p>继续查日志文件</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/57.png" class="">

<p>显然是 vpn1</p>
<h2 id="上题用户登陆-VPN-服务器的北京时间是"><a href="#上题用户登陆-VPN-服务器的北京时间是" class="headerlink" title="上题用户登陆 VPN 服务器的北京时间是"></a>上题用户登陆 VPN 服务器的北京时间是</h2><p>由第 46 题可知，服务器时区为 Asia&#x2F;Dhaka，比北京时间要早 2 小时。由第 54 题图可知，用户登陆 VPN 服务器的服务器时间为 2019-07-13_14:15:37，那么北京时间就应该是 2019-07-13_16:15:37</p>
<h2 id="该服务器曾被进行过抓包，请问-network-cap-是对哪个网卡进行抓包获得的抓包文件？"><a href="#该服务器曾被进行过抓包，请问-network-cap-是对哪个网卡进行抓包获得的抓包文件？" class="headerlink" title="该服务器曾被进行过抓包，请问 network.cap 是对哪个网卡进行抓包获得的抓包文件？"></a>该服务器曾被进行过抓包，请问 network.cap 是对哪个网卡进行抓包获得的抓包文件？</h2><p>history</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/58.png" class="">

<h2 id="对-ens37-网卡进行抓包产生的抓包文件并保存下来的是哪个？"><a href="#对-ens37-网卡进行抓包产生的抓包文件并保存下来的是哪个？" class="headerlink" title="对 ens37 网卡进行抓包产生的抓包文件并保存下来的是哪个？"></a>对 ens37 网卡进行抓包产生的抓包文件并保存下来的是哪个？</h2><p>还是 history</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/59.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/60.png" class="">

<p>可以看到，对 ens37 网卡进行抓包产生的抓包文件有两个，一个是 network1.cap 和 net0713-1.cap ，但在后面又使用命令删除了 network1.cap 文件，所以保存下来的是 net0713-1.cap</p>
<h2 id="从保存的数据包中分析可知，出口的-IP-为"><a href="#从保存的数据包中分析可知，出口的-IP-为" class="headerlink" title="从保存的数据包中分析可知，出口的 IP 为"></a>从保存的数据包中分析可知，出口的 IP 为</h2><p>使用 wireshark 打开导出后的 net0713-1.cap 数据包，并跟踪 tcp 流	</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/61.png" class="">

<p>所以出口的 IP 为 172.16.80.92</p>
<h1 id="检材四"><a href="#检材四" class="headerlink" title="检材四"></a>检材四</h1><p>你抓获了嫌疑人，并扣押了嫌疑人笔记本电脑，制作笔记本硬盘镜像文件“检材 4.E01”，请根据镜像文件，回答下列问题</p>
<h2 id="计算“检材-4-E01”文件的-sha256-值"><a href="#计算“检材-4-E01”文件的-sha256-值" class="headerlink" title="计算“检材 4.E01”文件的 sha256 值"></a>计算“检材 4.E01”文件的 sha256 值</h2><p>注意这里算的是文件的哈希不是硬盘！</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/62.png" class="">

<h2 id="请分析该检材的操作系统版本"><a href="#请分析该检材的操作系统版本" class="headerlink" title="请分析该检材的操作系统版本"></a>请分析该检材的操作系统版本</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/63.png" class="">

<h2 id="找出该系统用户最后一次登陆时间"><a href="#找出该系统用户最后一次登陆时间" class="headerlink" title="找出该系统用户最后一次登陆时间"></a>找出该系统用户最后一次登陆时间</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/64.png" class="">

<h2 id="找出该系统最后一次正常关机时间"><a href="#找出该系统最后一次正常关机时间" class="headerlink" title="找出该系统最后一次正常关机时间"></a>找出该系统最后一次正常关机时间</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/65.png" class="">

<h2 id="请计算检材桌面上文本文件的-sha256-值"><a href="#请计算检材桌面上文本文件的-sha256-值" class="headerlink" title="请计算检材桌面上文本文件的 sha256 值"></a>请计算检材桌面上文本文件的 sha256 值</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/66.png" class="">

<h2 id="该系统于-2019-年-7-月-13-日安装的软件为"><a href="#该系统于-2019-年-7-月-13-日安装的软件为" class="headerlink" title="该系统于 2019 年 7 月 13 日安装的软件为"></a>该系统于 2019 年 7 月 13 日安装的软件为</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/67.png" class="">

<h2 id="找出该嫌疑人于-2019-07-13-17-52-19-时，使用-WinRAR-工具访问了（-）文件"><a href="#找出该嫌疑人于-2019-07-13-17-52-19-时，使用-WinRAR-工具访问了（-）文件" class="headerlink" title="找出该嫌疑人于 2019-07-13 17:52:19 时，使用 WinRAR 工具访问了（ ）文件"></a>找出该嫌疑人于 2019-07-13 17:52:19 时，使用 WinRAR 工具访问了（ ）文件</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/68.png" class="">

<h2 id="系统于-2019-07-13-17-53-45-时运行了（-）程序"><a href="#系统于-2019-07-13-17-53-45-时运行了（-）程序" class="headerlink" title="系统于 2019-07-13 17:53:45 时运行了（ ）程序"></a>系统于 2019-07-13 17:53:45 时运行了（ ）程序</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/69.png" class="">

<h2 id="文件-test2-master-zip-是什么时间下载到本机的"><a href="#文件-test2-master-zip-是什么时间下载到本机的" class="headerlink" title="文件 test2-master.zip 是什么时间下载到本机的"></a>文件 test2-master.zip 是什么时间下载到本机的</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/70.png" class="">

<h2 id="文件-test2-master-zip-是使用什么工具下载到本地的"><a href="#文件-test2-master-zip-是使用什么工具下载到本地的" class="headerlink" title="文件 test2-master.zip 是使用什么工具下载到本地的"></a>文件 test2-master.zip 是使用什么工具下载到本地的</h2><p> 由第 67 题可知，显然是 Chrome</p>
<h2 id="嫌疑人成功连接至-192-168-184-128-服务器的时间为"><a href="#嫌疑人成功连接至-192-168-184-128-服务器的时间为" class="headerlink" title="嫌疑人成功连接至 192.168.184.128 服务器的时间为"></a>嫌疑人成功连接至 192.168.184.128 服务器的时间为</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/71.png" class="">

<h2 id="嫌疑人通过远程连接到-128-服务器，下载了什么文件到本机"><a href="#嫌疑人通过远程连接到-128-服务器，下载了什么文件到本机" class="headerlink" title="嫌疑人通过远程连接到 128 服务器，下载了什么文件到本机"></a>嫌疑人通过远程连接到 128 服务器，下载了什么文件到本机</h2><p>取证大师直接搜 .tar.gz</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/72.png" class="">

<h2 id="承接上一题，下载该文件用了多长时间"><a href="#承接上一题，下载该文件用了多长时间" class="headerlink" title="承接上一题，下载该文件用了多长时间"></a>承接上一题，下载该文件用了多长时间</h2><p>见第 70 题图</p>
<h2 id="请计算该下载文件的-sha256-值"><a href="#请计算该下载文件的-sha256-值" class="headerlink" title="请计算该下载文件的 sha256 值"></a>请计算该下载文件的 sha256 值</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/73.png" class="">

<h2 id="请分析并提取，嫌疑人所用的手机的-IMEI-号码"><a href="#请分析并提取，嫌疑人所用的手机的-IMEI-号码" class="headerlink" title="请分析并提取，嫌疑人所用的手机的 IMEI 号码"></a>请分析并提取，嫌疑人所用的手机的 IMEI 号码</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/74.png" class="">

<h2 id="嫌疑人是通过何种方式联系到售卖恶意程序的卖家的"><a href="#嫌疑人是通过何种方式联系到售卖恶意程序的卖家的" class="headerlink" title="嫌疑人是通过何种方式联系到售卖恶意程序的卖家的"></a>嫌疑人是通过何种方式联系到售卖恶意程序的卖家的</h2><p>很明显从这起要开始分析 IOS 备份了，所以赶紧将其添加为新检材</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/75.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/76.png" class="">

<p>弹出要密码，试一下检材 4 桌面上的标签内容 “niuroumian6” ，没想到竟然成功了</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/77.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/78.png" class="">

<p>显然是通过 QQ</p>
<h2 id="嫌疑人和卖家的资金来往是通过何种方式"><a href="#嫌疑人和卖家的资金来往是通过何种方式" class="headerlink" title="嫌疑人和卖家的资金来往是通过何种方式"></a>嫌疑人和卖家的资金来往是通过何种方式</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/79.png" class="">

<p>显然是微信</p>
<h2 id="嫌疑人在犯罪过程中所使用的-QQ-账号为"><a href="#嫌疑人在犯罪过程中所使用的-QQ-账号为" class="headerlink" title="嫌疑人在犯罪过程中所使用的 QQ 账号为"></a>嫌疑人在犯罪过程中所使用的 QQ 账号为</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/80.png" class="">

<h2 id="卖家所使用的微信账号-ID-为"><a href="#卖家所使用的微信账号-ID-为" class="headerlink" title="卖家所使用的微信账号 ID 为"></a>卖家所使用的微信账号 ID 为</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/81.png" class="">

<h2 id="嫌疑人下载了几个恶意程序到本机"><a href="#嫌疑人下载了几个恶意程序到本机" class="headerlink" title="嫌疑人下载了几个恶意程序到本机"></a>嫌疑人下载了几个恶意程序到本机</h2><p>结合 QQ 和微信的聊天记录，嫌疑人一共向卖家买了两次，虽然卖家给了三个下载链接，但后两个链接其实是算作一个软件的（加密和解密）</p>
<h2 id="恶意程序被嫌疑人保存在什么位置"><a href="#恶意程序被嫌疑人保存在什么位置" class="headerlink" title="恶意程序被嫌疑人保存在什么位置"></a>恶意程序被嫌疑人保存在什么位置</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/82.png" class="">

<p>显然是 D 盘</p>
<h2 id="恶意程序是使用什么工具下载到本地的"><a href="#恶意程序是使用什么工具下载到本地的" class="headerlink" title="恶意程序是使用什么工具下载到本地的"></a>恶意程序是使用什么工具下载到本地的</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/83.png" class="">

<p>同时佐证了第 78 题和 79 题</p>
<h2 id="嫌疑人是什么时间开始对受害者实施诈骗的"><a href="#嫌疑人是什么时间开始对受害者实施诈骗的" class="headerlink" title="嫌疑人是什么时间开始对受害者实施诈骗的"></a>嫌疑人是什么时间开始对受害者实施诈骗的</h2><p>我们根据案情简介可以知道，嫌疑人是通过短信进行诈骗，所以我们查看嫌疑人的短信</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/84.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/85.png" class="">

<h2 id="请提取受害者的银行卡信息，银行卡账号为"><a href="#请提取受害者的银行卡信息，银行卡账号为" class="headerlink" title="请提取受害者的银行卡信息，银行卡账号为"></a>请提取受害者的银行卡信息，银行卡账号为</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/86.png" class="">

<p>发现检材四的镜像里不但藏着 IOS 的手机备份，还藏着 Ubuntu 的虚拟机镜像，查看路径在备案平台里（检材四本身就 C 盘一个盘，进去一眼就能找到备案平台）</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/87.png" class="">

<p>把虚拟机这个文件夹导出来后仿真打开（选 vmdk 文件）</p>
<p>在 <code>/home/admin888/fund/</code> 目录下，我们发现了 sqlite 数据库，导出后用 Navicat 连接（文件-&gt;新建连接-&gt;SQLite-&gt;导入数据库文件db.sqlite3）</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/88.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/89.png" class="">

<p>不用用户名和密码就能连接成功，但是进去后找不到受害人的相关信息（手机号没一个对上，受害人手机号见第 81 题）……这题姑且只能作罢了</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/90.png" class="">

<h2 id="请综合分析，嫌疑人第一次入侵目标服务器的行为发生在"><a href="#请综合分析，嫌疑人第一次入侵目标服务器的行为发生在" class="headerlink" title="请综合分析，嫌疑人第一次入侵目标服务器的行为发生在"></a>请综合分析，嫌疑人第一次入侵目标服务器的行为发生在</h2><p>这题只能结合选项来了</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/91.png" class="">

<h2 id="请综合分析，嫌疑人入侵服务所使用的登陆方式为"><a href="#请综合分析，嫌疑人入侵服务所使用的登陆方式为" class="headerlink" title="请综合分析，嫌疑人入侵服务所使用的登陆方式为"></a>请综合分析，嫌疑人入侵服务所使用的登陆方式为</h2><p>xshell 中保存了连接 192.168.184.128 的密钥文件，所以可知是 SSH 密钥登陆</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/92.png" class="">

<h2 id="可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件的发送时间为"><a href="#可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件的发送时间为" class="headerlink" title="可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件的发送时间为"></a>可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件的发送时间为</h2><p>虽然检材四下过 Foxmail ，但经查证却不是用它发的邮件（真的坑）。所以我们换个思路，我们之前在检材三中找到了两个数据包，既然他发邮件，那么一定是走了代理，所以我们可以再研究一下检材三中的两个数据包。之前的题目用到了 net0713-1.cap ，那么这道题大概率是用 net0713.cap</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/93.png" class="">

<h2 id="可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件收件人为"><a href="#可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件收件人为" class="headerlink" title="可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件收件人为"></a>可知嫌疑人应对外发送过邮件，请分析并找到发出的邮件，可知邮件收件人为</h2><p>见第 85 题</p>
<h2 id="请重构被入侵的网站，可知该网站后台管理界面的登陆用户名为"><a href="#请重构被入侵的网站，可知该网站后台管理界面的登陆用户名为" class="headerlink" title="请重构被入侵的网站，可知该网站后台管理界面的登陆用户名为"></a>请重构被入侵的网站，可知该网站后台管理界面的登陆用户名为</h2><h2 id="请重构被入侵的网站，并登陆网站后台管理界面，对该网站进行证据固定，可知该网站首页左侧导航栏，不包含下列那个内容"><a href="#请重构被入侵的网站，并登陆网站后台管理界面，对该网站进行证据固定，可知该网站首页左侧导航栏，不包含下列那个内容" class="headerlink" title="请重构被入侵的网站，并登陆网站后台管理界面，对该网站进行证据固定，可知该网站首页左侧导航栏，不包含下列那个内容"></a>请重构被入侵的网站，并登陆网站后台管理界面，对该网站进行证据固定，可知该网站首页左侧导航栏，不包含下列那个内容</h2><h2 id="通过分析知，嫌疑人对目标服务器植入了勒索程序，请解密检材-2-中的被加密数据库，其-sha256-值为"><a href="#通过分析知，嫌疑人对目标服务器植入了勒索程序，请解密检材-2-中的被加密数据库，其-sha256-值为" class="headerlink" title="通过分析知，嫌疑人对目标服务器植入了勒索程序，请解密检材 2 中的被加密数据库，其 sha256 值为"></a>通过分析知，嫌疑人对目标服务器植入了勒索程序，请解密检材 2 中的被加密数据库，其 sha256 值为</h2><h2 id="通过分析知，嫌疑人有对目标服务器植入-ddos-程序，对该程序进行功能性分析，可知该程序会将自身复制到目标机器的什么目录下"><a href="#通过分析知，嫌疑人有对目标服务器植入-ddos-程序，对该程序进行功能性分析，可知该程序会将自身复制到目标机器的什么目录下" class="headerlink" title="通过分析知，嫌疑人有对目标服务器植入 ddos 程序，对该程序进行功能性分析，可知该程序会将自身复制到目标机器的什么目录下"></a>通过分析知，嫌疑人有对目标服务器植入 ddos 程序，对该程序进行功能性分析，可知该程序会将自身复制到目标机器的什么目录下</h2><h2 id="通过分析知，嫌疑人有对目标服务器植入-ddos-程序，对该程序进行功能性分析，可知该程序主控地址为（多选）"><a href="#通过分析知，嫌疑人有对目标服务器植入-ddos-程序，对该程序进行功能性分析，可知该程序主控地址为（多选）" class="headerlink" title="通过分析知，嫌疑人有对目标服务器植入 ddos 程序，对该程序进行功能性分析，可知该程序主控地址为（多选）"></a>通过分析知，嫌疑人有对目标服务器植入 ddos 程序，对该程序进行功能性分析，可知该程序主控地址为（多选）</h2><h2 id="嫌疑人于-2019-07-13-17-22-23-下载了什么文件？"><a href="#嫌疑人于-2019-07-13-17-22-23-下载了什么文件？" class="headerlink" title="嫌疑人于 2019-07-13 17:22:23 下载了什么文件？"></a>嫌疑人于 2019-07-13 17:22:23 下载了什么文件？</h2><p>87-91 题外加 99 题涉及逆向等知识，综合性很强（不太会……）要做的话参考下面这篇 wp ：</p>
<p><a href="https://blackbird-bb.github.io/2021/02/21/%E7%AC%AC%E4%B8%80%E5%B1%8A%E9%95%BF%E5%AE%89%E6%9D%AF%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/">https://blackbird-bb.github.io/2021/02/21/%E7%AC%AC%E4%B8%80%E5%B1%8A%E9%95%BF%E5%AE%89%E6%9D%AF%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/</a></p>
<p>虽然上面几道题不会，但其实不影响后面的做题</p>
<h2 id="压缩包-test2-master-zip-中的文件是什么？"><a href="#压缩包-test2-master-zip-中的文件是什么？" class="headerlink" title="压缩包 test2-master.zip 中的文件是什么？"></a>压缩包 test2-master.zip 中的文件是什么？</h2><p>取证大师直接搜索，双击打开即可</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/94.png" class="">

 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/95.png" class="">

<p>显然是个密钥文件</p>
<h2 id="应用程序-TrueCrypt-7-2-exe-是在什么时间下载到本机的？"><a href="#应用程序-TrueCrypt-7-2-exe-是在什么时间下载到本机的？" class="headerlink" title="应用程序 TrueCrypt-7.2.exe 是在什么时间下载到本机的？"></a>应用程序 TrueCrypt-7.2.exe 是在什么时间下载到本机的？</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/96.png" class="">

<h2 id="文件-runit-txt-从哪个域名下载的？"><a href="#文件-runit-txt-从哪个域名下载的？" class="headerlink" title="文件 runit.txt 从哪个域名下载的？"></a>文件 runit.txt 从哪个域名下载的？</h2><p>查微信聊天记录</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/97.png" class="">

<h2 id="BitLocker-密钥在什么位置？"><a href="#BitLocker-密钥在什么位置？" class="headerlink" title="BitLocker 密钥在什么位置？"></a>BitLocker 密钥在什么位置？</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/98.png" class="">

<p>很明显在 C 盘</p>
<h2 id="BitLocker-rar-生成的时间是？"><a href="#BitLocker-rar-生成的时间是？" class="headerlink" title="BitLocker.rar 生成的时间是？"></a>BitLocker.rar 生成的时间是？</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/99.png" class="">

<h2 id="文件-we-tar-gz-传输完成的时间是？"><a href="#文件-we-tar-gz-传输完成的时间是？" class="headerlink" title="文件 we.tar.gz 传输完成的时间是？"></a>文件 we.tar.gz 传输完成的时间是？</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/100.png" class="">

<h2 id="嫌疑人在什么时间登陆网页微信？"><a href="#嫌疑人在什么时间登陆网页微信？" class="headerlink" title="嫌疑人在什么时间登陆网页微信？"></a>嫌疑人在什么时间登陆网页微信？</h2> <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/101.png" class="">

<h2 id="硬盘-C-盘根目录中，文件-pagefile-sys-vhd-的作用是什么？"><a href="#硬盘-C-盘根目录中，文件-pagefile-sys-vhd-的作用是什么？" class="headerlink" title="硬盘 C 盘根目录中，文件 pagefile.sys.vhd 的作用是什么？"></a>硬盘 C 盘根目录中，文件 pagefile.sys.vhd 的作用是什么？</h2><p>进入 C 盘后双击文件，虽要求解锁，但实际上不用解锁它就已经显示为虚拟磁盘了（只是显示，进不去）</p>
 <img src="/2022/10/31/2019%E9%95%BF%E5%AE%89%E6%9D%AFwp/102.png" class="">]]></content>
      <categories>
        <category>电子数据取证</category>
      </categories>
      <tags>
        <tag>电子数据取证</tag>
      </tags>
  </entry>
  <entry>
    <title>2020长安杯wp</title>
    <url>/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/</url>
    <content><![CDATA[<p>本篇博客简单记录了我对2020长安杯电子数据取证比赛的学习复盘</p>
<span id="more"></span>

<h1 id="赛题背景"><a href="#赛题背景" class="headerlink" title="赛题背景"></a>赛题背景</h1><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu1.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu2.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu3.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu4.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu5.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu6.png" class="">

<h1 id="检材-1"><a href="#检材-1" class="headerlink" title="检材 1"></a>检材 1</h1><p>接群众举报，网站 “<a href="http://www.kkzjc.com”/">www.kkzjc.com”</a> 可能涉嫌非法交易，警方调取了该网站的云服务器镜像（检材 1.DD）， 请对检材 1 进行分析，获取证据，并根据线索解锁更多检材，深入挖掘出更多与案件有关的信息</p>
<h2 id="检材-1-的操作系统版本是"><a href="#检材-1-的操作系统版本是" class="headerlink" title="检材 1 的操作系统版本是"></a>检材 1 的操作系统版本是</h2><p>使用火眼证据分析软件打开检材1.DD，查看系统信息</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/1.png" class="">

<p>或者仿真后也能看到</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/2.png" class="">

<h2 id="检材-1-中，操作系统的内核版本是"><a href="#检材-1-中，操作系统的内核版本是" class="headerlink" title="检材 1 中，操作系统的内核版本是"></a>检材 1 中，操作系统的内核版本是</h2><p>还是在系统信息中（填 3.10.0 就好）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/3.png" class="">

<p>或仿真后使用 uname 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -a</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/4.png" class="">

<p>或直接看版本存储文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/5.png" class="">

<h2 id="检材-1-中磁盘包含一个-LVM-逻辑卷，该-LVM-开始的逻辑区块地址（LBA）是"><a href="#检材-1-中磁盘包含一个-LVM-逻辑卷，该-LVM-开始的逻辑区块地址（LBA）是" class="headerlink" title="检材 1 中磁盘包含一个 LVM 逻辑卷，该 LVM 开始的逻辑区块地址（LBA）是"></a>检材 1 中磁盘包含一个 LVM 逻辑卷，该 LVM 开始的逻辑区块地址（LBA）是</h2><p>确实有 LVM 逻辑卷，大小是38.99G</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/6.png" class="">

<p>所以查看检材1.DD的分区详情就好啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/7.png" class="">

<p>或仿真后 <code>fdisk -l</code></p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/8.png" class="">

<h2 id="检材-1-中网站-“www-kkzjc-com”-对应的-Web-服务对外开放的端口是"><a href="#检材-1-中网站-“www-kkzjc-com”-对应的-Web-服务对外开放的端口是" class="headerlink" title="检材 1 中网站 “www.kkzjc.com” 对应的 Web 服务对外开放的端口是"></a>检材 1 中网站 “<a href="http://www.kkzjc.com”/">www.kkzjc.com”</a> 对应的 Web 服务对外开放的端口是</h2><p>查看历史命令有所发现</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/9.png" class="">

<p>但是软件导不出该文件，也打不开它，那就用火眼仿真取证软件试试吧</p>
<p>root&#x2F;123456 登录服务器后，执行指令 <code>more /etc/nginx/conf.d/www.kkzjc.com</code> 就好啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/10.png" class="">

<p>或仿真后全局搜索关键字 <code>find / -name &quot;*www.kkzjc.com&quot;</code> ，好像还更快一点</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/11.png" class="">

<h2 id="检材-1-所在的服务器共绑定了（）个对外开放的域名"><a href="#检材-1-所在的服务器共绑定了（）个对外开放的域名" class="headerlink" title="检材 1 所在的服务器共绑定了（）个对外开放的域名"></a>检材 1 所在的服务器共绑定了（）个对外开放的域名</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/12.png" class="">

<p>显然是 3 个</p>
<h2 id="检材-1-所在的服务器的原始-IP-地址"><a href="#检材-1-所在的服务器的原始-IP-地址" class="headerlink" title="检材 1 所在的服务器的原始 IP 地址"></a>检材 1 所在的服务器的原始 IP 地址</h2><p>见第 9 题</p>
<h2 id="嫌疑人曾经远程登录过检材-1-所在的服务器，分析并找出其登录使用的IP-地址是（并使用该地址解压检材-2）"><a href="#嫌疑人曾经远程登录过检材-1-所在的服务器，分析并找出其登录使用的IP-地址是（并使用该地址解压检材-2）" class="headerlink" title="嫌疑人曾经远程登录过检材 1 所在的服务器，分析并找出其登录使用的IP 地址是（并使用该地址解压检材 2）"></a>嫌疑人曾经远程登录过检材 1 所在的服务器，分析并找出其登录使用的IP 地址是（并使用该地址解压检材 2）</h2><p>直接在火眼证据分析软件里看登录日志就好了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/13.png" class="">

<p>可以看到一共有俩，题目说正确的地址能解压检材2，具体是哪个试一下就好了</p>
<h2 id="检材-1-所在的服务器，其主要功能之一为反向代理。找出-“www-kkzjc-com”-转发的后台网站所使用的-IP-地址是（）（并用该-IP-地址解压检材3）"><a href="#检材-1-所在的服务器，其主要功能之一为反向代理。找出-“www-kkzjc-com”-转发的后台网站所使用的-IP-地址是（）（并用该-IP-地址解压检材3）" class="headerlink" title="检材 1 所在的服务器，其主要功能之一为反向代理。找出 “www.kkzjc.com” 转发的后台网站所使用的 IP 地址是（）（并用该 IP 地址解压检材3）"></a>检材 1 所在的服务器，其主要功能之一为反向代理。找出 “<a href="http://www.kkzjc.com”/">www.kkzjc.com”</a> 转发的后台网站所使用的 IP 地址是（）（并用该 IP 地址解压检材3）</h2><p>找了半天没啥收获，发现服务器是有 docker 的，那就去 docker 里看看。首先需要开启 docker 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/14.png" class="">

<p>然后查看镜像和容器</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/15.png" class="">

<p>从上图可以发现，当前有一个正在运行的容器（为 nginx 服务器），它的端口映射是把自己的 80 端口映射到虚拟机的 8091 端口上，这和第4题图中 nginx 的代理配置是相同的，所以我们可以知道，“<a href="http://www.kkzjc.com”/">www.kkzjc.com”</a> 网站会经过 nginx 的代理进行转发</p>
<p>接着我们进入交互式终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 08f64376a2e3 /bin/bash</span><br></pre></td></tr></table></figure>

<p>查看历史记录（history）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/16.png" class="">

<p>把历史记录里出现的配置文件都找一找，最终在 hl.conf 文件中找到了 “<a href="http://www.kkzjc.com”/">www.kkzjc.com”</a> 转发的后台网站所使用的 IP 地址（解压检材3试试就知道啦）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/17.png" class="">

<h2 id="嫌疑人曾经从题-7-的-IP-地址，通过-WEB-方式远程访问过网站，统计出检材-1-中该IP-出现的次数为"><a href="#嫌疑人曾经从题-7-的-IP-地址，通过-WEB-方式远程访问过网站，统计出检材-1-中该IP-出现的次数为" class="headerlink" title="嫌疑人曾经从题 7 的 IP 地址，通过 WEB 方式远程访问过网站，统计出检材 1 中该IP 出现的次数为"></a>嫌疑人曾经从题 7 的 IP 地址，通过 WEB 方式远程访问过网站，统计出检材 1 中该IP 出现的次数为</h2><p>题干中提到，嫌疑人曾通过 WEB 方式远程访问过网站，由第 8 题的分析可知，访问该网站会经 nginx 反向代理到另一后台网站，所以，其实我们可以通过分析 nginx 服务的日志来判断嫌疑人访问网站的次数</p>
<p>我们可以从 docker 中 nginx 的主配置文件中知晓 nginx 日志的位置</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/18.png" class="">

<p>但是当我们进入 <code>/var/log/nginx</code> 目录时，会发现 access.log 文件无法直接打开</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/19.png" class="">

<p>原来是 access.log 文件与 <code>/dev/stdout</code> 做了软连接，所以我们要用主机中的 <code>docker logs</code> 命令来查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先退出容器：Ctrl+P+Q</span><br><span class="line">再利用 grep 命令来统计次数：docker logs 08f64376a2e3 | grep -o &quot;192.168.99.222&quot; | grep -c &quot;192.168.99.222&quot;</span><br><span class="line">-o 是显示所有匹配位置；-c 是统计匹配行数；一步到位</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/20.png" class="">

<p>可以看到一共 18 个</p>
<p>同时，我们还能找到第6题的答案。我们知道，nginx 预定义了名为 combined 的日志格式，在没有明确指定日志格式的情况下默认使用该格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_format combined &#x27;$remote_addr - $remote_user [$time_local] &#x27;</span><br><span class="line">​          &#x27;&quot;$request&quot; $status $body_bytes_sent &#x27;</span><br><span class="line">​          &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>从上图中我们可以看到，与 “$http_referer” 字段相对应的值恰好是 “<a href="http://192.168.99.3:8091/dl&quot;">http://192.168.99.3:8091/dl&quot;</a> ，也就是说这个请求是从 192.168.99.3:8091 这个 IP 转发过来的，而 8091 恰好又是 nginx 映射到宿主机，也就是这个服务器虚拟机上的端口，由此可以判断出第 6 题的答案就是192.168.99.3</p>
<h2 id="Part1-小结"><a href="#Part1-小结" class="headerlink" title="Part1 小结"></a>Part1 小结</h2><p>第一部分的题目均围绕服务器镜像展开，负载均衡、反向代理的考点在长安杯中也算比较常见，20年的题目涉及 nginx 反向代理，21年的题目涉及负载均衡服务器。该部分考察了好几个 IP 地址，我们需要搞清楚 <strong>钓鱼网站、后台 IP 地址、远程登陆地址和服务器原始地址</strong> 这几个地址之间的关系与联系：</p>
<ol>
<li><p>nginx 作为 docker 容器，与宿主机服务器（此处就是指本机，宿主机是相对于本机上的虚拟机而言）之间存在端口映射的关系 80&#x2F;tcp -&gt; 8091</p>
</li>
<li><p>嫌疑人远程登录检材1所在的服务器，在服务器中留下登录日志记录（192.168.99.222，检材 2 解压密码）</p>
</li>
<li><p>受害人访问钓鱼网站，访问请求会通过宿主机服务器（原始地址，8091端口）转发到 nginx 服务器（docker，80端口），并在 nginx 日志中留下记录</p>
</li>
<li><p>三个钓鱼网站都通过 nginx 反向代理把访问请求转发到相同的后台 IP 地址（192.168.1.176，检材 3 解压密码）</p>
</li>
</ol>
<h1 id="检材-2"><a href="#检材-2" class="headerlink" title="检材 2"></a>检材 2</h1><p>警方找到了嫌疑人使用的个人 PC（检材 2.zip），请使用第 7 题的答案作为密码解压检材 2，分析并回答下列问题</p>
<h2 id="检材-2-的原始磁盘-SHA256值为"><a href="#检材-2-的原始磁盘-SHA256值为" class="headerlink" title="检材 2 的原始磁盘 SHA256值为"></a>检材 2 的原始磁盘 SHA256值为</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/21.png" class="">

<h2 id="检材-2-所在计算机的-OS-内部版本号是"><a href="#检材-2-所在计算机的-OS-内部版本号是" class="headerlink" title="检材 2 所在计算机的 OS 内部版本号是"></a>检材 2 所在计算机的 OS 内部版本号是</h2><p>仿真后在桌面右键，选择“显示设置”，在面板左边栏选择“关于”，就能看到具体的 OS 内部版本啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/22.png" class="">

<h2 id="检材-2-所在计算机最后一次正常关机的时间为"><a href="#检材-2-所在计算机最后一次正常关机的时间为" class="headerlink" title="检材 2 所在计算机最后一次正常关机的时间为"></a>检材 2 所在计算机最后一次正常关机的时间为</h2><p>这题有点坑，正确答案不在“开关机时间”里，而在“操作系统信息”里</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/23.png" class="">

<p>在“开关机时间”里显示 2020-9-22 是未关机或非正常关机，但在“操作系统信息”里却显示 2020-9-22 是有正常关机的</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/24.png" class="">

<h2 id="检材-2-中，VMware程序的安装时间为"><a href="#检材-2-中，VMware程序的安装时间为" class="headerlink" title="检材 2 中，VMware程序的安装时间为"></a>检材 2 中，VMware程序的安装时间为</h2><p>这题也是有点陷阱的，不要被桌面快捷方式的创建时间骗了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/25.png" class="">

<p>应该是安装包的最后运行时间</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/26.png" class="">

<h2 id="检材-2-中，Vmware-exe-程序总计启动过（）次"><a href="#检材-2-中，Vmware-exe-程序总计启动过（）次" class="headerlink" title="检材 2 中，Vmware.exe 程序总计启动过（）次"></a>检材 2 中，Vmware.exe 程序总计启动过（）次</h2><p>这里就要用到取证大师了，查看一下“应用程序运行痕迹”</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/27.png" class="">

<p>很明显一共启动过 6 次</p>
<h2 id="嫌疑人通过-Web-方式，从检材-2-访问检材-1-所在的服务器上的网站时，连接的目标端口是"><a href="#嫌疑人通过-Web-方式，从检材-2-访问检材-1-所在的服务器上的网站时，连接的目标端口是" class="headerlink" title="嫌疑人通过 Web 方式，从检材 2 访问检材 1 所在的服务器上的网站时，连接的目标端口是"></a>嫌疑人通过 Web 方式，从检材 2 访问检材 1 所在的服务器上的网站时，连接的目标端口是</h2><p>其实第 6 题已经给出答案了，但因为嫌疑人是通过 Web 方式嘛，所以我们也再搜一下浏览器的历史记录来佐证一下</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/28.png" class="">

<h2 id="接-15-题，该端口上运行的进程的程序名称（Program-name）为"><a href="#接-15-题，该端口上运行的进程的程序名称（Program-name）为" class="headerlink" title="接 15 题，该端口上运行的进程的程序名称（Program name）为"></a>接 15 题，该端口上运行的进程的程序名称（Program name）为</h2><p>在检材一的虚拟机中执行指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 8091</span><br><span class="line">-p 获取进程名、进程号以及用户ID</span><br></pre></td></tr></table></figure>

<p>不过要注意，要先开启 docker 服务哦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/29.png" class="">

<h2 id="嫌疑人从检材-2-上访问该网站时，所使用的域名为"><a href="#嫌疑人从检材-2-上访问该网站时，所使用的域名为" class="headerlink" title="嫌疑人从检材 2 上访问该网站时，所使用的域名为"></a>嫌疑人从检材 2 上访问该网站时，所使用的域名为</h2><p>查看 hosts 文件，<code>C:\Windows\System32\drivers\etc\hosts</code></p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/30.png" class="">

<h2 id="检材-2-中，嫌疑人所使用的微信-ID-是"><a href="#检材-2-中，嫌疑人所使用的微信-ID-是" class="headerlink" title="检材 2 中，嫌疑人所使用的微信 ID 是"></a>检材 2 中，嫌疑人所使用的微信 ID 是</h2><p>在 Win10 电脑里找半天没找到微信，突然想到微信不一定必须安在电脑上，微信也可以安在手机上，然后其实在取证大师案例概览的重要信息里也提示我们了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/31.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/32.png" class="">

<p>上图可见，系统最后打开的是一个 iPhone 手机的备份文件夹，在虚拟机中打开一看文件夹里是 .tar 格式的备份文件，导出后继续用火眼证据分析软件对其进行分析（导出这里应该是需要安装 VMware tools ，火眼证据分析软件竟然能直接把 .tar 格式的文件当作镜像导入，震惊我一年）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/33.png" class="">

<p>导入分析的时候提示需要 Keychain ，好像影响不大，先进到微信里看就是</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/34.png" class="">

<h2 id="分析检材-2，嫌疑人为推广其网站，与广告位供应商沟通时使用的通联工具的名称为"><a href="#分析检材-2，嫌疑人为推广其网站，与广告位供应商沟通时使用的通联工具的名称为" class="headerlink" title="分析检材 2，嫌疑人为推广其网站，与广告位供应商沟通时使用的通联工具的名称为"></a>分析检材 2，嫌疑人为推广其网站，与广告位供应商沟通时使用的通联工具的名称为</h2><p>按照题目意思把几个社交软件的聊天记录翻一番就 ok 了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/35.png" class="">

<h2 id="分析检材-2，嫌疑人使用虚拟货币与供应商进行交易，该虚拟货币的名称是"><a href="#分析检材-2，嫌疑人使用虚拟货币与供应商进行交易，该虚拟货币的名称是" class="headerlink" title="分析检材 2，嫌疑人使用虚拟货币与供应商进行交易，该虚拟货币的名称是"></a>分析检材 2，嫌疑人使用虚拟货币与供应商进行交易，该虚拟货币的名称是</h2><p>也在聊天记录里</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/36.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/37.png" class="">

<p>一看 DOGE 收款，那肯定是和 DOGE 相关的虚拟货币，百度一查就知道啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/38.png" class="">

<h2 id="上述交易中，对方的收款地址是"><a href="#上述交易中，对方的收款地址是" class="headerlink" title="上述交易中，对方的收款地址是"></a>上述交易中，对方的收款地址是</h2><p>也在上面收款码的图里，<code>DPBEgbwap7VW5HbNdGi9TyKJbqTLWYYkvf</code></p>
<h2 id="上述交易中，嫌疑人和供应商的交易时间是"><a href="#上述交易中，嫌疑人和供应商的交易时间是" class="headerlink" title="上述交易中，嫌疑人和供应商的交易时间是"></a>上述交易中，嫌疑人和供应商的交易时间是</h2><p>见 23 题</p>
<h2 id="上述交易中，嫌疑人支付货币的数量为"><a href="#上述交易中，嫌疑人支付货币的数量为" class="headerlink" title="上述交易中，嫌疑人支付货币的数量为"></a>上述交易中，嫌疑人支付货币的数量为</h2><p>之所以和第 22 题一起，是因为这两题需要我们上网去查找能够查询狗狗币交易记录的网站——Dogecoin 浏览器，能够通过收款地址查询狗狗币交易，<a href="https://explorer.viawallet.com/doge?lang=zh_Hans_CN">https://explorer.viawallet.com/doge?lang=zh_Hans_CN</a></p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/39.png" class="">

<p>交易时间和支付货币的数量就一目了然啦</p>
<h2 id="检材-2-中，嫌疑人使用的虚拟机的虚拟磁盘被加密，其密码为"><a href="#检材-2-中，嫌疑人使用的虚拟机的虚拟磁盘被加密，其密码为" class="headerlink" title="检材 2 中，嫌疑人使用的虚拟机的虚拟磁盘被加密，其密码为"></a>检材 2 中，嫌疑人使用的虚拟机的虚拟磁盘被加密，其密码为</h2><p>这道题实际上在手机的微信聊天记录中有提示</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/40.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/41.png" class="">

<p>还提示了 github ，去浏览器历史记录里看看</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/42.png" class="">

<p>发现历史记录的访问时间还和聊天记录的时间对上了，此外搜的还都是 pyvmx-cracker ，那我们也搜一搜看，<a href="https://github.com/axcheron/pyvmx-cracker">https://github.com/axcheron/pyvmx-cracker</a></p>
<p>在 github 上找到 pyvmx-cracker 后发现它果然是用于破解虚拟机加密的工具，接下来我们就可以利用该工具进行解密啦（ VMware 对虚拟机进行加密，实际上是对虚拟机的配置文件 vmx 进行加密，在未加密的时候 vmx 文件中存储的是有关该虚拟机配置的明文信息）</p>
<p>检材 2 中的虚拟机 Windows 10 x64 的配置文件 vmx 还藏的挺深的</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/43.png" class="">

<p>导出该文件，用 pyvmx-cracker 爆破即可，字典就用工具自带的字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python .\pyvmx-cracker.py -v Windows 10 x64.vmx -d wordlist.txt</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/44.png" class="">

<h2 id="检材-2-中，嫌疑人发送给广告商的邮件中的图片附件的-SHA256-值为"><a href="#检材-2-中，嫌疑人发送给广告商的邮件中的图片附件的-SHA256-值为" class="headerlink" title="检材 2 中，嫌疑人发送给广告商的邮件中的图片附件的 SHA256 值为"></a>检材 2 中，嫌疑人发送给广告商的邮件中的图片附件的 SHA256 值为</h2><p>检材 2 中并没有邮箱的使用记录，所以想到去上一题中解密完的虚拟机中寻找，这需要把整个虚拟机的文件夹导出来。打开发现不太对，竟然还需要登录密码</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/45.png" class="">

<p>那先关闭虚拟机，然后选中 VM 上边栏“虚拟机”，点击“设置”</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/46.png" class="">

<p>移除加密后用火眼仿真取证软件打开，就能拿到密码</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/47.png" class="">

<p>重新登录虚拟机，发现桌面上有 Foxmail ，好家伙必须点进去看看啊</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/48.png" class="">

<p>不用找就能直接发现</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/49.png" class="">

<p>另存到本地算一下哈希就好啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/50.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cc7ea3ab90ab6b28417e08c715c243ce58ea76d71fd141b93f055a58e9ba561a</span><br></pre></td></tr></table></figure>

<h2 id="检材-2-中，嫌疑人给广告商发送广告图片邮件的发送时间是"><a href="#检材-2-中，嫌疑人给广告商发送广告图片邮件的发送时间是" class="headerlink" title="检材 2 中，嫌疑人给广告商发送广告图片邮件的发送时间是"></a>检材 2 中，嫌疑人给广告商发送广告图片邮件的发送时间是</h2><p>Foxmail里已经记录的很清楚啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/51.png" class="">

<h2 id="检材-2-中，嫌疑人的邮箱密码是"><a href="#检材-2-中，嫌疑人的邮箱密码是" class="headerlink" title="检材 2 中，嫌疑人的邮箱密码是"></a>检材 2 中，嫌疑人的邮箱密码是</h2><p>用火眼证据分析软件打开虚拟机镜像进行取证，找 Foxmail 的账户信息就是了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/52.png" class="">

<p>其实猜也应该猜 honglian7001</p>
<h2 id="检材-2-中，嫌疑人使用了（）远程管理工具，登录了检材-1-所在的服务器"><a href="#检材-2-中，嫌疑人使用了（）远程管理工具，登录了检材-1-所在的服务器" class="headerlink" title="检材 2 中，嫌疑人使用了（）远程管理工具，登录了检材 1 所在的服务器"></a>检材 2 中，嫌疑人使用了（）远程管理工具，登录了检材 1 所在的服务器</h2><p>看看虚拟机桌面上还剩些啥，那只能是 Xshell 了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/53.png" class="">

<p>继续在虚拟机镜像的取证结果里找</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/54.png" class="">

<p>确认为 Xshell 无疑</p>
<h2 id="检材-2-中，嫌疑人使用上述工具连接服务器时，使用的登录密码为"><a href="#检材-2-中，嫌疑人使用上述工具连接服务器时，使用的登录密码为" class="headerlink" title="检材 2 中，嫌疑人使用上述工具连接服务器时，使用的登录密码为"></a>检材 2 中，嫌疑人使用上述工具连接服务器时，使用的登录密码为</h2><p>见第 28 题图</p>
<h2 id="Part2-小结"><a href="#Part2-小结" class="headerlink" title="Part2 小结"></a><strong>Part2</strong> 小结</h2><p>检材 2 中包含了嫌疑人的手机备份和嫌疑人用来远程连接检材 1 服务器的虚拟机镜像，嫌疑人主要的通信行为和远程管理都在手机和虚拟机上完成，宿主机（即检材二最本身的 Win 机）中并未存在太多有用信息。其中一个比较新颖的考点是对 VMware 加密虚拟机的破解，此外还涉及到了一些对于虚拟货币的基础了解。虚拟货币这块也一直是近几年的热门话题，经常出现在各种网络犯罪行为中。</p>
<p>截止目前，检材间的关联如下：</p>
<ol>
<li><p>检材 2 主机中主要包含嫌疑人通过 Web 方式访问检材 1 中网站的历史记录</p>
</li>
<li><p>检材 2 中包含嫌疑人使用的手机备份，手机备份中含有嫌疑人与外界交流的各种通信应用</p>
</li>
<li><p>检材 2 中包含一台 Windows 7 虚拟机，嫌疑人通过该虚拟机与广告供应商进行联系，还通过该虚拟机上的 xshell软件远程管理检材 1 服务器</p>
</li>
</ol>
<h1 id="检材-3"><a href="#检材-3" class="headerlink" title="检材 3"></a>检材 3</h1><p>请使用第 8 题的答案作为密码解压检材 3，分析并回答下列问题</p>
<h2 id="检材-3-的原始磁盘-SHA256值为"><a href="#检材-3-的原始磁盘-SHA256值为" class="headerlink" title="检材 3 的原始磁盘 SHA256值为"></a>检材 3 的原始磁盘 SHA256值为</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/55.png" class="">

<h2 id="检材-3-所在的计算机的操作系统版本是"><a href="#检材-3-所在的计算机的操作系统版本是" class="headerlink" title="检材 3 所在的计算机的操作系统版本是"></a>检材 3 所在的计算机的操作系统版本是</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/56.png" class="">

<h2 id="检材-3-中，部署的网站名称是"><a href="#检材-3-中，部署的网站名称是" class="headerlink" title="检材 3 中，部署的网站名称是"></a>检材 3 中，部署的网站名称是</h2><p>见第 34 题</p>
<h2 id="检材-3-中，部署的网站对应的网站根目录是"><a href="#检材-3-中，部署的网站对应的网站根目录是" class="headerlink" title="检材 3 中，部署的网站对应的网站根目录是"></a>检材 3 中，部署的网站对应的网站根目录是</h2><p>见第 34 题</p>
<h2 id="检材-3-中，部署的网站绑定的端口是"><a href="#检材-3-中，部署的网站绑定的端口是" class="headerlink" title="检材 3 中，部署的网站绑定的端口是"></a>检材 3 中，部署的网站绑定的端口是</h2><p>使用火眼仿真取证软件对检材 3 进行仿真，在打开的虚拟机中选择“Server”用户进行登录，登录后即可看到一个“服务器管理器”面板，发现有一个 Web 服务器（IIS），然后一层层打开</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/57.png" class="">

<p>点击“高级设置”，打开就是三道题一起的答案啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/58.png" class="">

<p>其中物理路径就是网站根目录</p>
<h2 id="检材-3-中，具备登陆功能的代码页，对应的文件名为"><a href="#检材-3-中，具备登陆功能的代码页，对应的文件名为" class="headerlink" title="检材 3 中，具备登陆功能的代码页，对应的文件名为"></a>检材 3 中，具备登陆功能的代码页，对应的文件名为</h2><p>在浏览器的 Main History 中可以发现嫌疑人曾访问过一个名为“代理登录”的网站，网址为 <a href="http://localhost/dl">http://localhost/dl</a></p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/59.png" class="">

<p>我们在检材 3 的虚拟机中尝试访问这个网站，发现可以直接访问，并且其确实具有登录功能</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/60.png" class="">

<p>那我们就去网站根目录下找找看（这也是为什么第 33 题要求我们找网站根目录，其实都是有铺垫的）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/61.png" class="">

<p>网站根目录下有个 Web.config 文件，很诱人点进去看看，全局查找 dl 真的很容易就找到了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/62.png" class="">

<p>dl 就是代理的意思，dllogin 不就是“代理登录”的意思吗，这和之前找到的网站名完美匹配</p>
<h2 id="检材-3-中，请对网站代码进行分析，网站登录过程中，代码中对输入的明文密码作了追加（）字符串处理"><a href="#检材-3-中，请对网站代码进行分析，网站登录过程中，代码中对输入的明文密码作了追加（）字符串处理" class="headerlink" title="检材 3 中，请对网站代码进行分析，网站登录过程中，代码中对输入的明文密码作了追加（）字符串处理"></a>检材 3 中，请对网站代码进行分析，网站登录过程中，代码中对输入的明文密码作了追加（）字符串处理</h2><p>在上一题的目录下（&#x2F;dr&#x2F;login）找到 dllogin.aspx 文件，查看源码</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/63.png" class="">

<p>很明显是在输入的明文密码后追加了“OvO”。其实，直接F12看登录页面的源码也是可以的</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/64.png" class="">

<h2 id="检材-3-中，请对网站代码进行分析，网站登录过程中，代码中调用的动态扩展库文件的完整名称为"><a href="#检材-3-中，请对网站代码进行分析，网站登录过程中，代码中调用的动态扩展库文件的完整名称为" class="headerlink" title="检材 3 中，请对网站代码进行分析，网站登录过程中，代码中调用的动态扩展库文件的完整名称为"></a>检材 3 中，请对网站代码进行分析，网站登录过程中，代码中调用的动态扩展库文件的完整名称为</h2><p>继续看 dllogin.aspx 文件源码，发现“App_Web_dllogin.aspx.7d7c2f33”十分可疑</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/65.png" class="">

<p>所以就去文件系统里搜一搜，发现果然是 .dll 后缀，那么也就可以确定答案了</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/66.png" class="">

<h2 id="检材-3-中，网站登录过程中，后台接收到明文密码后进行加密处理，首先使用的算法是-Encryption-中的（）函数"><a href="#检材-3-中，网站登录过程中，后台接收到明文密码后进行加密处理，首先使用的算法是-Encryption-中的（）函数" class="headerlink" title="检材 3 中，网站登录过程中，后台接收到明文密码后进行加密处理，首先使用的算法是 Encryption 中的（）函数"></a>检材 3 中，网站登录过程中，后台接收到明文密码后进行加密处理，首先使用的算法是 Encryption 中的（）函数</h2><p>直觉上来说，这题肯定和上一题找到的 App_Web_dllogin.aspx.7d7c2f33.dll 文件有关，但导出后直接用记事本打开竟是乱码，尽管如此还是可是发现，里面是包含 Encryption 信息的</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/67.png" class="">

<p>所以想办法把这个文件正确打开就肯定能找到答案，经过尝试发现只有 dnspy（一款反编译软件）可以正常打开，然后就很快找到答案啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/68.png" class="">

<h2 id="检材-3-中，分析该网站连接的数据库地址为（）并使用该地址解压检材-4"><a href="#检材-3-中，分析该网站连接的数据库地址为（）并使用该地址解压检材-4" class="headerlink" title="检材 3 中，分析该网站连接的数据库地址为（）并使用该地址解压检材 4"></a>检材 3 中，分析该网站连接的数据库地址为（）并使用该地址解压检材 4</h2><p>在上题的 dll 文件中，还可以看到 dl_login_dllogin 类调用的外部动态链接库，其中有一个叫 DBManager，看名字就是和数据库相关的库</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/69.png" class="">

<p>可以发现的是，这个 dll 文件也在 bin 目录下，导出后用 dnspy 进行分析。在 DBcon 类的最下面可以看到连接 sql 数据库的默认配置</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/70.png" class="">

<p>其中有数据库地址（192.168.1.174，检材 4 解压密码）和端口号（1433）</p>
<h2 id="检材-3-中，网站连接数据库使用的密码为"><a href="#检材-3-中，网站连接数据库使用的密码为" class="headerlink" title="检材 3 中，网站连接数据库使用的密码为"></a>检材 3 中，网站连接数据库使用的密码为</h2><p>同样是在 DBcon 中，不过是在最上面</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/71.png" class="">

<p>我们尝试理解一下这块代码的逻辑。如果 this.Conn 为空（未被赋值），则使用默认的连接信息（红色框）；但事实上 this.Conn 已经被赋值了（黄色框），也就是说我们需要利用 AESDecrypt 方法来解密这串加密信息。查看该方法，可以发现这是 Encryption 类下的静态方法，可以直接通过 PowerShell 调用，但必须注意的是，调用静态方法一定要使用方括号加上双冒号 :: 的形式，而且要先在当前的 PowerShell 环境下引入这个动态链接库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\DBManager.dll</span><br><span class="line">[DBManager.Encryption]::AESDecrypt(&quot;Mcyj19i/VubvqSM21YPjWnnGzk8G/GG6x9+qwdcOJd9bTEyprEOxs8TD9Ma1Lz1Ct72xlK/g8DDRAQ+X0GtJ8w==&quot;, &quot;HL&quot;, &quot;forensix&quot;)</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/72.png" class="">

<p>其中有数据库地址（192.168.1.174）、端口号（1433）、用户名（sa）、密码（c4f2737e88）以及数据库名（v7sq3）</p>
<h2 id="检材-3-中，网站连接数据库服务器的端口是"><a href="#检材-3-中，网站连接数据库服务器的端口是" class="headerlink" title="检材 3 中，网站连接数据库服务器的端口是"></a>检材 3 中，网站连接数据库服务器的端口是</h2><p>由 39、40 题均可知</p>
<h2 id="Part3-小结"><a href="#Part3-小结" class="headerlink" title="Part3 小结"></a>Part3 小结</h2><p>检材 3 是一个 Windows Server 服务器，上面部署了一个 IIS 网站，主要考察点还是在网站架构（根目录下文件存放路径）、配置信息以及对动态链接库的分析上。如果能搞清楚 aspx 与 dll 之间的继承关系，各个 dll 之间的调用关系，以及找到对应的文件，将对解题很有帮助：</p>
<ol>
<li><p>检材 3 中搭建了名为 card 的网站，登录页面为 &#x2F;dl</p>
</li>
<li><p>登录页面的源文件为 dllogin.aspx，位于 &#x2F;dr&#x2F;login 目录下</p>
</li>
<li><p>源码继承自 App_Web_dllogin.aspx.7d7c2f33.dll，位于 &#x2F;bin 目录下</p>
</li>
<li><p>App_Web_dllogin.aspx.7d7c2f33.dll中调用了 DBManager.dll的 Encryption.AESEncrypt 方法，也位于 &#x2F;bin 目录下</p>
</li>
<li><p>DBManager.dll 中存储了连接数据库的默认配置信息和嫌疑人实际使用的配置信息，调用解密方法即可得到明文</p>
</li>
</ol>
<p>数据库名：v7sq3</p>
<p>用户名 &#x2F; 密码：sa &#x2F; c4f2737e88</p>
<p>数据库 IP 地址：192.168.1.174（检材 4 解压密码）</p>
<p>数据库端口号：1433</p>
<h1 id="检材-4"><a href="#检材-4" class="headerlink" title="检材 4"></a>检材 4</h1><p>请使用第 39 题的答案作为密码解压检材 4，分析并回答下列问题</p>
<h2 id="检材-4-的原始磁盘-SHA256值为"><a href="#检材-4-的原始磁盘-SHA256值为" class="headerlink" title="检材 4 的原始磁盘 SHA256值为"></a>检材 4 的原始磁盘 SHA256值为</h2><p>使用39题拿到的解压密码打开检材 4</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/73.png" class="">

<p>我们可以发现，从第 43 题起，后面几乎每一题都涉及“网站重构”。那么如何重构？客官别急且看下面</p>
<p>我们对检材 4 进行仿真，查看 history 可以发现，里面涉及到了许多数据库相关的操作（mssql），再结合检材 3 可以发现，这很明显是一个站库分离的架构，检材 3 是站，检材 4 是库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history | grep mssql</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/74.png" class="">

<p>此外我们还可以看到，history 中有 docker cp 命令对 LDF 文件（日志数据库文件）的操作，其中数据库的名字与检材 3 中分析到的完全相同，均为 v7sq3（可见第 40 题）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/75.png" class="">

<p>据此我们可以判断，真正的数据库就在docker中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker # 启动docker服务</span><br><span class="line">systemctl status docker # 查看服务状态</span><br><span class="line">docker ps -a # 查看所有容器</span><br><span class="line">docker start 3f17 # 开启容器</span><br></pre></td></tr></table></figure>

<p>通过检材 3 我们知道，数据库的连接地址为 192.168.1.174，所以我们要先修改检材 4 的静态 IP（关闭 DHCP服务）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/76.png" class="">

<p>修改网卡配置文件（CentOS）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip a # 查看配置文件名称 ens-33</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/77.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33 # 修改配置文件</span><br></pre></td></tr></table></figure>

<p>修改（红框）&#x2F;添加（黄框）以下内容</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/78.png" class="">

<p>重启网络配置，查看是否修改成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br><span class="line">ip a</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/79.png" class="">

<p>配置好检材 4 后，再配置检材 3，开启 DHCP 服务，查看网络配置，检测是否能 ping 通检材 4</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/80.png" class="">

<p>连接数据库（注意要选 SQL Server，而不是 MySQL ）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/81.png" class="">

<p>这时，如果我们是第一次连接 SQL Server 的话，会有报错“未发现数据源名称并且未指定默认驱动程序”。解决方法就是把 Navicat 安装目录下的 msodbcsql_64.msi 文件安装即可</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/82.png" class="">

<p>不过安装的时候要注意选择“Will be installed on local hard drive”</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/83.png" class="">

<p>安装完成后重新打开 Navicat 进行连接即可。然后竟然又报错了……</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/84.png" class="">

<p>网上搜了半天也搜不到有效的解决方法，把电脑重启一遍后重新过一遍刚刚的流程竟然奇迹般又连上了……感觉真的很离谱</p>
<p>回顾之前分析检材3时找到的网站登录时调用的“App_Web_dllogin.aspx.7d7c2f33.dll”文件，我们可以发现，在 dr_login_dllogin 类的 oCmd 方法中当用户登录信息与数据库比对时使用了 wduser.DUserLogin 函数</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/85.png" class="">

<p>跟进查看这个函数，在 WBus.dll 文件的 WDUser 类中</p>
<p>（ WBus.dll 文件也在 App_Web_dllogin.aspx.7d7c2f33.dll 文件开头引用）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/86.png" class="">

<p>DUserLogin 函数中调用了数据库中的 PD_UserLogin 函数</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/87.png" class="">

<p>PD_UserLogin 函数内容如下图</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/88.png" class="">

<p>函数中有几个关键点：</p>
<ol>
<li>先从 TD_Webs 表中根据 DW_Web 的取值取出 DW_Type 和 DW_DU_Id ，DW_Web 是域名&#x2F;IP</li>
</ol>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/89.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/90.png" class="">

<ol start="2">
<li>再根据 DW_Type 的取值（0&#x2F;1）进入两个条件分支，在 TD_User 表中取用户数据</li>
</ol>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/91.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/92.png" class="">

<ol start="3">
<li>TD_User 表中存放的密码是经过拼接、加密、MD5处理后的结果</li>
</ol>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/93.png" class="">

<p>通过检材 2 我们知道，嫌疑人的用户名为 liwente1314520，对应的 DU_Id 为 1001，根据以上代码的判断逻辑，我们只要让 DW_DU_Id 与 DU_Id 保持一致，再修改对应的 DW_Web 字段和 DU_Pwd 字段的值即可实现后台登录的绕过</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/94.png" class="">

<p>我们以修改密码为“123456”为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MD5(AESEncrypt(&#x27;123456&#x27;+&#x27;OvO&#x27;))</span><br><span class="line">Import-Module .\DBManager.dll</span><br><span class="line">[DBManager.Encryption]::AESEncrypt(&quot;123456OvO&quot;, &quot;forensix&quot;, &quot;HL&quot;)</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/95.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/96.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/97.png" class="">

<p>将 liwente1314520 用户名对应的密码修改为 “123456” 在经过拼接加密 md5 处理后的结果</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/98.png" class="">

<p>修改为后台网址的 IP</p>
<p>修改完后保存，重启容器：<code>docker restart 3f17</code></p>
<p>在检材 3 中开启 ASP.NET State Service 服务</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/99.png" class="">

<p>然后就可以在本机的浏览器上通过 192.168.1.176&#x2F;dl 来访问网站啦，用户名 liwente1314520，密码 123456 进行登录</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/100.png" class="">

<p>至此网站就重构成功啦</p>
<h2 id="重构该网站，分析嫌疑用户的推广链接中参数里包含的-ID-是"><a href="#重构该网站，分析嫌疑用户的推广链接中参数里包含的-ID-是" class="headerlink" title="重构该网站，分析嫌疑用户的推广链接中参数里包含的 ID 是"></a>重构该网站，分析嫌疑用户的推广链接中参数里包含的 ID 是</h2><p>重构网址后一找就有啦</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/101.png" class="">

<h2 id="重构该网站，该网站后台的代理用户数量为"><a href="#重构该网站，该网站后台的代理用户数量为" class="headerlink" title="重构该网站，该网站后台的代理用户数量为"></a>重构该网站，该网站后台的代理用户数量为</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/102.png" class="">

<p>一共三页数就完事 9+9+8&#x3D;26 个</p>
<h2 id="重构该网站，该网站注册用户中共有过（）个代理（包含删除的数据）"><a href="#重构该网站，该网站注册用户中共有过（）个代理（包含删除的数据）" class="headerlink" title="重构该网站，该网站注册用户中共有过（）个代理（包含删除的数据）"></a>重构该网站，该网站注册用户中共有过（）个代理（包含删除的数据）</h2><p>用与之前分析登录页面时相同的方法，先找到“用户列表”页面对应的 aspx 文件</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/103.png" class="">

<p>tyyhlb.aspx，然后找到它继承自哪个动态链接库</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/104.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/105.png" class="">

<p>App_Web_tyyhlb.aspx.df411ca0</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/106.png" class="">

<p>导出后使用 dnspy 打开，找到其中和数据库交互的函数</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/107.png" class="">

<p>寻找引用，在 WBus.dll 的 WUUser 类中，找到对应的表</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/108.png" class="">

<p>统计行数</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/109.png" class="">

<p>也可以这样</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/110.png" class="">

<h2 id="重构该网站，对补发记录进行统计，统计-2019-年-10-月-1-日后补发成功的金额总值"><a href="#重构该网站，对补发记录进行统计，统计-2019-年-10-月-1-日后补发成功的金额总值" class="headerlink" title="重构该网站，对补发记录进行统计，统计 2019 年 10 月 1 日后补发成功的金额总值"></a>重构该网站，对补发记录进行统计，统计 2019 年 10 月 1 日后补发成功的金额总值</h2><p>和第 45 题一样的步骤，找到对应的数据库表，这里对应的是一个视图（view）</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/111.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/112.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/113.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/114.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/115.png" class="">

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/116.png" class="">

<p>Page_Load 方法对于是否补发成功的判断如下</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/117.png" class="">

<p>可以看到当 YY1T_CState 字段值为 100 时，补发成功；我们使用 sql 语句进行查找（记得还要加上时间范围的限定哦）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SUM(YY1T_Money) FROM [dbo].[VY_TestLog] WHERE [YY1T_CState] = N&#x27;100&#x27; AND [YY1T_CDate] BETWEEN N&#x27;2019-10-01 00:00:00&#x27; AND N&#x27;2020-12-31 00:00:00&#x27;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/118.png" class="">

<h2 id="检材-4-中，对“TX-IpLog”表进行分析，所有在“武汉市”登录的次数为"><a href="#检材-4-中，对“TX-IpLog”表进行分析，所有在“武汉市”登录的次数为" class="headerlink" title="检材 4 中，对“TX_IpLog”表进行分析，所有在“武汉市”登录的次数为"></a>检材 4 中，对“TX_IpLog”表进行分析，所有在“武汉市”登录的次数为</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/119.png" class="">

<h2 id="重构该网站，该嫌疑人下属代理“liyun10”账户下的余额有（）元"><a href="#重构该网站，该嫌疑人下属代理“liyun10”账户下的余额有（）元" class="headerlink" title="重构该网站，该嫌疑人下属代理“liyun10”账户下的余额有（）元"></a>重构该网站，该嫌疑人下属代理“liyun10”账户下的余额有（）元</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/120.png" class="">

<p>点击“后台”无法直接跳转，此时我们需要在地址栏开头添加服务器的 IP</p>
<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/121.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.1.176/res/aspx/uin.aspx?user=liyun10&amp;pwd=F58249F4A628AE7B35753EA8416BA943&amp;t=fqgl</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/122.png" class="">

<h2 id="接上一题，该用户的推广-ID-是"><a href="#接上一题，该用户的推广-ID-是" class="headerlink" title="接上一题，该用户的推广 ID 是"></a>接上一题，该用户的推广 ID 是</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/123.png" class="">

<h2 id="接上一题，该代理商户的最后一次登陆时间是"><a href="#接上一题，该代理商户的最后一次登陆时间是" class="headerlink" title="接上一题，该代理商户的最后一次登陆时间是"></a>接上一题，该代理商户的最后一次登陆时间是</h2><img src="/2022/10/30/2020%E9%95%BF%E5%AE%89%E6%9D%AFwp/124.png" class="">

<h2 id="Part4-小结"><a href="#Part4-小结" class="headerlink" title="Part4 小结"></a><strong>Part4</strong> 小结</h2><p>本部分围绕“网站重构”展开，作为每年的保留项目，考察点也不完全相同。21年主要考察对数据库服务器的“ raid 重组”，而20年则主要考察对数据库的“改查”操作，当然前提是要弄清楚登录判断和密码校验的逻辑，找到对应的表和对应的数据，才能正确修改。重构网站后剩下的步骤就比较简单了，使用 sql 语句或导出至 excel 中使用表格进行统计都可以顺利完成题目</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后再整体梳理一遍所有检材间的关系：</p>
<ol>
<li><p>检材 1 作为反向代理服务器，对外开放的三个域名最终都会转发到由检材 3 和检材 4 共同搭建的网站后台（192.168.1.176:80）。此外，根据后台网站的内容和功能可以判断，这三个域名是嫌疑人专门留给下线代理访问管理平台的地址，账号需要嫌疑人审核通过后才能登录</p>
</li>
<li><p>检材 2 是嫌疑人的个人 PC ，嫌疑人通过在检材 2 上的 Win 7 虚拟机中使用 XShell 远程管理检材 1</p>
</li>
<li><p>嫌疑人使用手机上的 Telegram 与广告供应商进行联系，并通过虚拟货币 Dogecoin 与广告供应商进行交易，手机备份存储在检材 2 中</p>
</li>
<li><p>检材 3 和检材 4 共同搭建了管理后台，检材 3 上通过 IIS 服务搭建了网站，检材 4 上部署了网站的数据库。检材 3 的 IP 地址为 192.168.1.176，恰好符合检材 1 中 nginx 代理转发的规则，80 端口对应后台首页；检材 4 的 IP 地址为 192.168.1.174，所有关于数据库的连接信息都是通过对检材 3 中 的网站登录代码分析得到</p>
</li>
</ol>
]]></content>
      <categories>
        <category>电子数据取证</category>
      </categories>
      <tags>
        <tag>电子数据取证</tag>
      </tags>
  </entry>
  <entry>
    <title>2021长安杯wp</title>
    <url>/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/</url>
    <content><![CDATA[<p>本篇博客简单记录了我对2021长安杯电子数据取证比赛的学习复盘</p>
<span id="more"></span>

<h1 id="赛题背景"><a href="#赛题背景" class="headerlink" title="赛题背景"></a>赛题背景</h1><p>长安杯2021的赛题背景为时下热门的“裸聊诈骗”案例，主要涉及 apk 分析、服务器取证、PC取证、手机取证四大方向，其中 apk 分析与服务器取证为此次比赛的重点和难点</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu1.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu2.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/timu3.png" class="">

<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ol>
<li><p>检材发放采用 VC 加密容器，需要使用获取到的密码解密容器挂载后方可看到检材</p>
</li>
<li><p>下载来的检材其实不是真的 txt 文本，是 VC 加密容器的格式，这里加 txt 后缀只是为了方便上传到阿里云盘供大家下载</p>
</li>
</ol>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/1.png" class="">

<ol start="3">
<li><p>做题思路：APK分析 -&gt; 服务器集群 -&gt; 嫌疑人</p>
</li>
<li><p>注意题目中具体要求的答案格式</p>
</li>
<li><p>在安卓手机中，每个 APK 在手机里的安装目录都是以应用包名进行命名，都位于 app&#x2F;data 目录下</p>
</li>
</ol>
<h1 id="检材一（容器密码：2021第三届CAB-changancup-com）"><a href="#检材一（容器密码：2021第三届CAB-changancup-com）" class="headerlink" title="检材一（容器密码：2021第三届CAB-changancup.com）"></a>检材一（容器密码：2021第三届CAB-changancup.com）</h1><p>2021年4月25日，上午8点左右，警方接到被害人金某报案，声称自己被敲诈数万元；经询问，昨日金某被嫌疑人诱导裸聊， 下载了某“裸聊”软件，导致自己的通讯录和裸聊视频被嫌疑人获取，对其进行敲诈，最终金某不堪重负，选择了报警；警方从金某提供的本人手机中，定向采集到了该“裸聊”软件的安装包–zhibo.apk（检材一）</p>
<h2 id="请计算检材一Apk的SHA256值"><a href="#请计算检材一Apk的SHA256值" class="headerlink" title="请计算检材一Apk的SHA256值"></a>请计算检材一Apk的SHA256值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -hashfile filename sha256</span><br></pre></td></tr></table></figure>

<h2 id="该APK的应用包名为"><a href="#该APK的应用包名为" class="headerlink" title="该APK的应用包名为"></a>该APK的应用包名为</h2><p>APK题使用<strong>雷电APP智能分析</strong>软件（包含文件哈希，应用包名，APPID，静态权限、源码等信息）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/2.png" class="">

<p>想要获取 APK 的应用包名，还可以使用 jadx 进行反编译（雷电APP智能分析软件自带此功能），查看 AndroidManifest.xml 文件，package的值就是包名；也可以使用 GDA 进行分析，BaseInfo中 Package Name 的值就是包名</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/3.png" class="">

<h2 id="该APK程序在封装服务商的应用唯一标识（APPID）为"><a href="#该APK程序在封装服务商的应用唯一标识（APPID）为" class="headerlink" title="该APK程序在封装服务商的应用唯一标识（APPID）为"></a>该APK程序在封装服务商的应用唯一标识（APPID）为</h2><p>APK程序在封装服务商的应用唯一标识（APPID）即为给 APK 打包的专业厂商对应的调证值，是为了方便公安取证时溯源找到对应厂商，每个厂商对应唯一。雷电APP智能分析软件中的第三方服务模块中有直接给出；也可以在 assets 的 apps 目录下找到</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/4.png" class="">

<h2 id="该APK具备下列哪些危险权限"><a href="#该APK具备下列哪些危险权限" class="headerlink" title="该APK具备下列哪些危险权限"></a>该APK具备下列哪些危险权限</h2><p>手机 APP 权限申请主要集中在 AndroidManifest.xml 文件最上方，雷电APP智能分析软件做了可视化</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/5.png" class="">

<p>具体权限的对应关系可以查看 <a href="https://www.cnblogs.com/linn/p/4046180.html">https://www.cnblogs.com/linn/p/4046180.html</a></p>
<h2 id="该APK发送回后台服务器的数据包含一下哪些内容"><a href="#该APK发送回后台服务器的数据包含一下哪些内容" class="headerlink" title="该APK发送回后台服务器的数据包含一下哪些内容"></a>该APK发送回后台服务器的数据包含一下哪些内容</h2><p>在雷电APP智能分析软件中打开手机模拟器（雷电模拟器），在网络数据包模块中进行代理抓包（因为 APK 是框架编写，抓 HTTP 和 TCP 可能是抓不到包的），前提是在 APP 首页中选中“填写邀请码”，并输入了手机号和邀请码点击确定</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/6.png" class="">

<p>可以抓到</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/7.png" class="">

<p>上图可以看到，APK向后台服务器发送回了手机号、验证码和通讯录信息。其实最开始抓到的请求包里只有手机号和验证码，没有通讯录，这是因为模拟器里面的通讯录是空的……加上用户就好了</p>
<p>答案其实还有一个 GPS 定位信息，通过抓包方式不能成功抓取到，进行确认有两种方法：1. 通过静态代码分析，可以看到代码中有传送GPS 信息的部分；2. 后续第三部分网站重构后，可以从后台中查看到有 GPS 信息传送回去</p>
<p>其中，静态代码分析需要查看 index.html 文件。怎么找到这个文件的，其实有一个技巧，就是在 jadx 中搜索 APK 首页上出现的一些信息，比如“内涵一点，让您笑口常开。”</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/8.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/9.png" class="">

<p>（不过需要注意的是，在雷电APP智能分析软件中自带的 jadx 并没有搜索资源和注释的功能，想要用上述技巧可能还需要把 jadx 再安一遍）</p>
<p>index.html文件的具体路径在下图目录下</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/10.png" class="">

<p>本次比赛中涉及的 APK 为框架编写，真正的源码都在资源文件下。我们可以发现 index.html 文件为其主要逻辑代码（记录了 APK 首页的源码），在里面我们发现了一堆奇怪的东西（核心代码段经过加密）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/11.png" class="">

<p>这其实是使用了 sojson.v4 加密，找个在线网站解密就好了，<a href="https://ctf.bugku.com/tool/sojson4">https://ctf.bugku.com/tool/sojson4</a></p>
<p>解密后会发现代码中提到了以下内容，所以也就可以确定答案了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sjh：手机号</span><br><span class="line">yqm：邀请码（验证码）</span><br><span class="line">jingweidu、position：GPS定位</span><br><span class="line">address book、contact：通讯录</span><br></pre></td></tr></table></figure>

<h2 id="该APK程序回传通讯录时-使用的http请求方式为"><a href="#该APK程序回传通讯录时-使用的http请求方式为" class="headerlink" title="该APK程序回传通讯录时,使用的http请求方式为"></a>该APK程序回传通讯录时,使用的http请求方式为</h2><p>需要通过抓包获得，使用雷电APP分析软件或者 Fliddler 都可以捕捉到，答案其实在上面抓包时就已经得到</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/12.png" class="">

<h2 id="该APK程序的回传地址域名为"><a href="#该APK程序的回传地址域名为" class="headerlink" title="该APK程序的回传地址域名为"></a>该APK程序的回传地址域名为</h2><p>见第 6 题</p>
<h2 id="该APK程序代码中配置的变量apiserver的值为"><a href="#该APK程序代码中配置的变量apiserver的值为" class="headerlink" title="该APK程序代码中配置的变量apiserver的值为"></a>该APK程序代码中配置的变量apiserver的值为</h2><p>既然题目提示了要看代码，那肯定是通过分析静态代码（index.html文件）的方式获得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第16行：var apiserver =&#x27;http://www.honglian7001.com/api/uploads/&#x27;;</span><br><span class="line">第62行起：mui.ajax(apiserver + &#x27;apisms&#x27;,</span><br><span class="line">即为 www.honglian7001.com/api/uploads/apisms</span><br></pre></td></tr></table></figure>

<p>duanxin、SMS：短信</p>
<h2 id="分析该APK，发现该程序还具备获取短信回传到后台的功能，短信上传服务器接口地址为"><a href="#分析该APK，发现该程序还具备获取短信回传到后台的功能，短信上传服务器接口地址为" class="headerlink" title="分析该APK，发现该程序还具备获取短信回传到后台的功能，短信上传服务器接口地址为"></a>分析该APK，发现该程序还具备获取短信回传到后台的功能，短信上传服务器接口地址为</h2><p>见第 8 题</p>
<h2 id="经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该文件的文件名为"><a href="#经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该文件的文件名为" class="headerlink" title="经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该文件的文件名为"></a>经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该文件的文件名为</h2><p>此处涉及APK分析中的hook方法，技术难度较大。当然，在解题过程中我们可以使用雷电APP智能分析，其中内置了Frida和相应功能的hook脚本</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/13.png" class="">

<h2 id="经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该数据库的初始密码为"><a href="#经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该数据库的初始密码为" class="headerlink" title="经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该数据库的初始密码为"></a>经分析，发现该APK在运行过程中会在手机中产生一个数据库文件，该数据库的初始密码为</h2><p>见第 10 题</p>
<h1 id="检材二（容器密码：www-honglian7001-com-）"><a href="#检材二（容器密码：www-honglian7001-com-）" class="headerlink" title="检材二（容器密码：www.honglian7001.com ）"></a>检材二（容器密码：<a href="http://www.honglian7001.com/">www.honglian7001.com</a> ）</h1><p>经过掌握的APK程序后台服务器回连地址，警方成功调取该服务器的镜像，请使用第7题的答案对检材二进行解压进行分析</p>
<h2 id="检材二的原始硬盘的SHA256值为："><a href="#检材二的原始硬盘的SHA256值为：" class="headerlink" title="检材二的原始硬盘的SHA256值为："></a>检材二的原始硬盘的SHA256值为：</h2><p>使用火眼证据分析软件</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/14.png" class="">

<p>注意：对于原始硬盘的 hash 值计算，我们不能拿裸的 e01 镜像直接计算，裸的 e01 镜像和 zip 类似，是对原始文件进行压缩处理打包后的结果，我们需要先将其使用取证软件进行挂载，然后再进行计算。其实我们也能发现，对 e01 镜像挂载前后的大小是不一样的，上图我们可以看到设备实际大小是20G，但如果我们直接查看 e01 文件的属性信息，会发现它只有3.44G，所以 hash 计算的结果自然也就不同</p>
<h2 id="查询涉案于案发时间段内登陆服务器的IP地址为"><a href="#查询涉案于案发时间段内登陆服务器的IP地址为" class="headerlink" title="查询涉案于案发时间段内登陆服务器的IP地址为"></a>查询涉案于案发时间段内登陆服务器的IP地址为</h2><p>使用火眼仿真取证软件进行仿真（记得要重置所有用户的密码）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/15.png" class="">

<p>根据题目背景，我们可以确定案发时间在2021年4月24日。我们知道 last 命令可以用于显示用户最近的登录信息。单独执行 last 命令，它会读取 &#x2F;var&#x2F;log&#x2F;wtmp 文件，并把该文件记录的登入系统的用户名单全部显示出来。所以我们可以在终端中执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">last | grep &quot;Apr 24&quot;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/16.png" class="">

<h2 id="请对检材二进行分析，并回答该服务器在集群中承担的主要作用是"><a href="#请对检材二进行分析，并回答该服务器在集群中承担的主要作用是" class="headerlink" title="请对检材二进行分析，并回答该服务器在集群中承担的主要作用是"></a>请对检材二进行分析，并回答该服务器在集群中承担的主要作用是</h2><p>在做后续题时可以发现，这个服务器的作用其实就是把一些请求根据一定的条件转发到其他服务器上，用专业术语讲就是负载均衡（基于HTPP协议）</p>
<p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务</p>
<h2 id="上一题中，提到的主要功能对应的服务监听的端口为"><a href="#上一题中，提到的主要功能对应的服务监听的端口为" class="headerlink" title="上一题中，提到的主要功能对应的服务监听的端口为"></a>上一题中，提到的主要功能对应的服务监听的端口为</h2><p>当我们在普通用户权限下执行 history 指令时，会发现显示的历史命令比较少；所以我们执行 <code>su root</code> 指令，并输入密码123456，即可转到 root 用户。再执行 history 指令，就可以发现很多的历史命令。此外，我们也可以通过火眼证据分析软件，得到历史命令</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/17.png" class="">

<p>通过以上操作，我们可以确定服务器的工作目录就是<code>/opt/honglianjingsai</code></p>
<p>我们在仿真虚拟机中直接访问这个目录，发现该目录下有个 README.txt 文件（README 还是一个挺重要的文件，需要引起重视，没准就有宝藏）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/18.png" class="">

<p>于是查看 const.js 配置文件，可以发现端口改成了80（80端口是服务器中提供服务最常用的端口，这题蒙也要蒙80）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/19.png" class="">

<h2 id="上一题中，提到的服务所使用的启动命令为"><a href="#上一题中，提到的服务所使用的启动命令为" class="headerlink" title="上一题中，提到的服务所使用的启动命令为"></a>上一题中，提到的服务所使用的启动命令为</h2><p>通过观察历史命令可以发现，<code>node app.js</code> 命令总出现在 <code>cd honglianjingsai/</code> 和 <code>cd chronusNode/</code> 命令之后（下图1），还可以发现系统重启后只可能是 <code>node app.js</code> 来启动服务，因为其他的命令是清屏、查看 ip 配置、进入服务器目录和关闭服务（下图2）。我们打开 app.js 进行进一步验证，也可以发现里面涉及到了开启服务、关闭服务、运行服务的代码。其实 chronusNode 这个词就已经暗示的挺明白了，要用到 node 命令</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/20.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/21.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/22.png" class="">

<h2 id="经分析，该服务对于请求来源IP的处理依据是：根据请求源IP地址的第（）位进行判断"><a href="#经分析，该服务对于请求来源IP的处理依据是：根据请求源IP地址的第（）位进行判断" class="headerlink" title="经分析，该服务对于请求来源IP的处理依据是：根据请求源IP地址的第（）位进行判断"></a>经分析，该服务对于请求来源IP的处理依据是：根据请求源IP地址的第（）位进行判断</h2><p>根据之前 README.txt 的提示，该服务对于请求来源 IP 的处理应该在</p>
<p>&#x2F;opt&#x2F;honglianjingsai&#x2F;chronusNode&#x2F;controller&#x2F;ADProxy.js 文件中</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/23.png" class="">

<p>我们可以看出，代码对 ip 进行了切片，取第三段化为整型。其实我们从变量名 clientIP3Int 也能看出。个人感觉题目这个“第几位”的问法很奇怪，题目实际求的应该是“第几段”</p>
<h2 id="经分析，当判断条件小于50时，服务器会将该请求转发到IP为（）的服务器上"><a href="#经分析，当判断条件小于50时，服务器会将该请求转发到IP为（）的服务器上" class="headerlink" title="经分析，当判断条件小于50时，服务器会将该请求转发到IP为（）的服务器上"></a>经分析，当判断条件小于50时，服务器会将该请求转发到IP为（）的服务器上</h2><p>还是 ADProxy.js 文件，我们发现当判断条件小于 50 时服务器会将请求转发到名为 _proxy50 的服务器上，于是</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/24.png" class="">

<p>其实从这题中就可以印证前面关于服务器负载均衡作用的答案</p>
<h2 id="请分析，该服务器转发的目标服务器一共有几台"><a href="#请分析，该服务器转发的目标服务器一共有几台" class="headerlink" title="请分析，该服务器转发的目标服务器一共有几台"></a>请分析，该服务器转发的目标服务器一共有几台</h2><p>从上题图中就可以看到，一共 3 台</p>
<h2 id="请分析，受害者通讯录被获取时，其设备的IP地址为"><a href="#请分析，受害者通讯录被获取时，其设备的IP地址为" class="headerlink" title="请分析，受害者通讯录被获取时，其设备的IP地址为"></a>请分析，受害者通讯录被获取时，其设备的IP地址为</h2><p>20题和21题其实均考察了对于日志的审计，所以放到一起解决。我们可以发现在 <code>/opt/honglianjingsai/chronusNode/logs</code> 路径下保存了服务器的日志，并且根据题目背景，我们可以确定案发时间是4月24日（具体的案发时间可以查看手机，在手机取证时一些社交软件的聊天记录中会有很准确的时间信息），而4月24的日志只有一个，那就很好办了。我们可以看到，在这个日志文件中出现次数最多的几个 IP 地址分别是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.110.203</span><br><span class="line">192.168.110.252</span><br><span class="line">192.168.110.113</span><br></pre></td></tr></table></figure>

<p>而根据前面的题目我们知道，192.168.110.203是登陆服务器的 IP 地址，192.168.110.113是服务器请求转发的目标地址（21题答案），那么通过排除法，192.168.110.252显然就是本题的答案了</p>
<p>这题如不采用排除法，将是非常麻烦的。需要参考手机的聊天记录（伊对APP），再和日志中的时间相对照来得到答案（此处还需要注意，日志中的时间是 UTC 时间，所以还需要 +8 小时才是北京时间）</p>
<p>其实这道题目做完，我们是可以发现一个在应试 or 比赛中的小 Bug 的。那就是题目中出现的所有 ip 地址很可能都是属于同一网段的，比如本次比赛中所有的 ip 地址的答案都属于192.168.110.0网段。我们可以进一步查看 CentOS 7 的网卡配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/25.png" class="">

<p>可以看到，这个负载均衡服务器配置的是 static 静态IP，它的静态 IP 就是192.168.110.110</p>
<h2 id="请分析，受害者的通讯录被窃取之后，经由该服务器转发到了IP为（）的服务器上"><a href="#请分析，受害者的通讯录被窃取之后，经由该服务器转发到了IP为（）的服务器上" class="headerlink" title="请分析，受害者的通讯录被窃取之后，经由该服务器转发到了IP为（）的服务器上"></a>请分析，受害者的通讯录被窃取之后，经由该服务器转发到了IP为（）的服务器上</h2><p>见第 21 题</p>
<h1 id="检材三（容器密码：192-168-110-113-CAB2021）"><a href="#检材三（容器密码：192-168-110-113-CAB2021）" class="headerlink" title="检材三（容器密码：192.168.110.113-CAB2021）"></a>检材三（容器密码：192.168.110.113-CAB2021）</h1><p>通过对检材二的分析，警方进一步掌握并落地到了目标服务器地址，通过对服务器进行证据固定，得到服务器镜像–检材三，请使用第 21题答案对检材三进行解密并分析</p>
<h2 id="检材三的原始硬盘的SHA256值为"><a href="#检材三的原始硬盘的SHA256值为" class="headerlink" title="检材三的原始硬盘的SHA256值为"></a>检材三的原始硬盘的SHA256值为</h2><p>挂载检材三后我们可以得到三个 web 服务器的镜像，但是此时需要注意题目的要求，题目要求我们分析目标服务器，也就是说我们需要先判断出这三个服务器中到底哪一个对应着192.168.110.113，才能进一步解题</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/26.png" class="">

<p>我们利用火眼证据分析软件依次检查三个镜像，已知 <code>/etc/sysconfig/network-scripts/ifcfg-ens33</code> 路径是 CentOS 7 的网卡配置文件，我们可以在软件分析板块中的网络信息-网络接口模块中发现</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/27.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/28.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/29.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web1.E01镜像对应的静态IP为192.168.110.111</span><br><span class="line">web2.E01镜像对应的静态IP为192.168.110.112</span><br><span class="line">web3.E01镜像对应的静态IP为192.168.110.113，所以web3服务器才是我们要找的目标服务器</span><br></pre></td></tr></table></figure>

<p>其实我们也可以用火眼仿真取证软件直接打开三个镜像，然后查找相应的网卡配置文件，其中 IPADDR 就是我们要找的 IP 地址，也可以发现 web3 对应着目标服务器。然后我们要求检材三的原始硬盘的 SHA256 值就很简单啦</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/30.png" class="">

<p>吐槽一下，每次计算哈希时间都真的久……</p>
<h2 id="请分析第21题中，所指的服务器的开机密码为"><a href="#请分析第21题中，所指的服务器的开机密码为" class="headerlink" title="请分析第21题中，所指的服务器的开机密码为"></a>请分析第21题中，所指的服务器的开机密码为</h2><p>在我们对 web3.E01 镜像进行仿真时，火眼仿真取证软件会直接重置开机密码，不会显示原来的密码（Windows会显示原来的）。所以这题并不能直接通过检材三得到答案，需要依靠检材四的 PC 镜像，在对 PC 镜像进行仿真后可以看到桌面上有 xshell，我们可以直接通过一些工具查看 xshell 保存的密码，也可以用取证软件解析出来（Xshell中保存有会话记录，从中可以看到密码）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/31.png" class="">

<h2 id="嫌疑人架设网站使用了宝塔面板，请问面板的登陆用户名为"><a href="#嫌疑人架设网站使用了宝塔面板，请问面板的登陆用户名为" class="headerlink" title="嫌疑人架设网站使用了宝塔面板，请问面板的登陆用户名为"></a>嫌疑人架设网站使用了宝塔面板，请问面板的登陆用户名为</h2><p>这题的话其实火眼证据分析软件中是可以直接看到的</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/32.png" class="">

<p>也可以用以下方法。用火眼仿真取证软件对 web3.E01 镜像进行仿真时，会出现下图界面，和检材二仿真后的图像界面不一样了（还挺神奇的），我们尝试使用 root&#x2F;123456 进行登录，发现可以成功</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/33.png" class="">

<p>然后使用 <code>bt default</code> 命令即可查看宝塔面板的登陆用户名和密码了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/34.png" class="">

<p>由上图可知，宝塔后台的登录入口为 <a href="http://192.168.110.113:8888/12345678">http://192.168.110.113:8888/12345678</a> ，账号为 hl123 ，密码为 65606fc8</p>
<p>PS：宝塔面板在近几年的电诈案件中真的很常见</p>
<h2 id="请分析用于重置宝塔面板密码的函数名为"><a href="#请分析用于重置宝塔面板密码的函数名为" class="headerlink" title="请分析用于重置宝塔面板密码的函数名为"></a>请分析用于重置宝塔面板密码的函数名为</h2><p>根据经验我们知道，宝塔的面板文件目录在 <code>/www/server/panel</code> 路径下，这也是宝塔目录结构中最为重要的目录，重置宝塔面板密码的代码文件一定就在这个目录下。经过一番查找可以发现，宝塔面板重置网站密码功能调用的是 tools.py 文件，这其实也可由老版本宝塔重置密码命令得知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /www/server/panel &amp;&amp; python tools.py panel testpasswd</span><br></pre></td></tr></table></figure>

<p>因为当前虚拟机显示的是服务器的终端页面，而在终端查阅代码体验会很差，所以我们需要想办法登录到宝塔的 Web 端系统中。要想在Web 端上链接宝塔，需要将本地虚拟机的虚拟网络编辑器调整至 110 网段，并关闭 DHCP 服务。这种做法对于分析集群性服务器来说非常有用，因为这样可以保留服务器在原始真实环境中的 IP 地址，而并不是虚拟机 DHCP 服务分配的地址，可以降低网站重构的复杂程度</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/35.png" class="">

<p>可以访问宝塔后台的登录入口</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/36.png" class="">

<p>输入之前得到的用户名和密码进行登录</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/37.png" class="">

<p>找到 <code>/www/server/panel</code> 路径下的 tools.py 文件，选中编辑，打开在线文本编辑器，这样读代码可就舒服多了</p>
<p>注：如果想要将宝塔面板里的文件导出至本机，可以选中文件后点击右侧的下载按钮；文件夹右侧是没有下载按钮的，这时可以选择先把文件夹压缩，然后下载压缩包即可</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/38.png" class="">

<p>在这里，我们可以看到我们在终端执行 bt 命令时得到的反馈信息，其中就涉及修改面板密码这个选项（5）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/39.png" class="">

<p>当输入的参数等于5时，可以看到最终会执行 set_panel_pwd 这个函数，所以这就是我们要找的用于重置宝塔面板密码的函数名啦</p>
<h2 id="请分析宝塔面板登陆密码的加密方式所使用的哈希算法为"><a href="#请分析宝塔面板登陆密码的加密方式所使用的哈希算法为" class="headerlink" title="请分析宝塔面板登陆密码的加密方式所使用的哈希算法为"></a>请分析宝塔面板登陆密码的加密方式所使用的哈希算法为</h2><p>想要知道登陆密码的加密方式所使用的哈希算法，那就只能去找 set_panel_pwd 这个函数的具体定义了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/40.png" class="">

<p>所幸挺好找的，我们可以发现函数内部调用了 public 类的 md5 方法对我们输入的新密码进行了处理</p>
<h2 id="请分析宝塔面板对于其默认用户的密码一共执行了几次上题中的哈希算法"><a href="#请分析宝塔面板对于其默认用户的密码一共执行了几次上题中的哈希算法" class="headerlink" title="请分析宝塔面板对于其默认用户的密码一共执行了几次上题中的哈希算法"></a>请分析宝塔面板对于其默认用户的密码一共执行了几次上题中的哈希算法</h2><p>由26题图我们可以看到，当我们重置密码时，传入的新密码先经过了 public.md5 函数的处理，然后又和 uid 这个参数一起传进了 public.password_salt 这个函数。所以只要查清楚这两个函数，问题也就迎刃而解了。我们还可以知道，在 tools.py 文件最开头的 import 部分，说明了 public 的引用在目录 <code>/www/server/panel/class/</code> 下，所以我们去该目录下查找即可</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/41.png" class="">

<p>我们可以在该目录下的 public.py 文件里分别找到 password_salt 和 md5 两个方法</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/42.png" class="">

<p>可以看到 md5 方法一共执行了一次哈希</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/43.png" class="">

<p>可以看到在 password_salt 方法最后返回值时，对 password 添加后缀执行了一次哈希，然后加盐又进行了一次哈希，所以一共执行了两次哈希</p>
<p>综上，md5 方法和 password_salt 方法一共进行了 3 次哈希</p>
<h2 id="请分析当前宝塔面板密码加密过程中所使用的salt值为"><a href="#请分析当前宝塔面板密码加密过程中所使用的salt值为" class="headerlink" title="请分析当前宝塔面板密码加密过程中所使用的salt值为"></a>请分析当前宝塔面板密码加密过程中所使用的salt值为</h2><p>火眼证据分析软件可以直接得到</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/44.png" class="">

<p>也可以溯源</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/45.png" class="">

<p>还是分析先前代码可以发现，salt 是从数据库中读取的（users表中），而这个数据库是通过 M 方法调用，所以我们继续搜索 def M</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/46.png" class="">

<p>可以发现默认数据库为 <code>/wwww/server/panel/data/default.db</code> ，因为该文件不支持在线查看，所以我们下载后使用数据库查看工具打开（navicat 等），答案就在用户表内</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/47.png" class="">

<h2 id="请分析该服务器，网站源代码所在的绝对路径为"><a href="#请分析该服务器，网站源代码所在的绝对路径为" class="headerlink" title="请分析该服务器，网站源代码所在的绝对路径为"></a>请分析该服务器，网站源代码所在的绝对路径为</h2><p>在宝塔后台，我们可以找到网站源码所在的绝对路径</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/48.png" class="">

<h2 id="请分析，网站所使用的数据库位于IP为（）的服务器上"><a href="#请分析，网站所使用的数据库位于IP为（）的服务器上" class="headerlink" title="请分析，网站所使用的数据库位于IP为（）的服务器上"></a>请分析，网站所使用的数据库位于IP为（）的服务器上</h2><p>我们继续在网站根目录下查找相关的代码文件，最终在</p>
<p><code>/www/wwwroot/www.honglian7001/app/database.php</code> 文件中找到了网站的数据库配置</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/49.png" class="">

<p>自然也就不难发现数据库所在服务器的 IP 地址和数据库的登录密码啦</p>
<h2 id="请分析，数据库的登陆密码为"><a href="#请分析，数据库的登陆密码为" class="headerlink" title="请分析，数据库的登陆密码为"></a>请分析，数据库的登陆密码为</h2><p>见第 30 题</p>
<h2 id="请尝试重构该网站，并指出，该网站的后台管理界面的入口为"><a href="#请尝试重构该网站，并指出，该网站的后台管理界面的入口为" class="headerlink" title="请尝试重构该网站，并指出，该网站的后台管理界面的入口为"></a>请尝试重构该网站，并指出，该网站的后台管理界面的入口为</h2><p>从网站的目录结构可以发现 <code>/www/wwwroot/www.honglian7001/app/admin……</code> ，所以我们最先猜测网站后台管理界面的入口就是 <code>/admin</code>，当然我们还可以从后面嫌疑人 PC 端的检材的取证结果中的浏览器历史记录来验证网站后台管理界面的入口就在 <code>/admin</code> 下</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/50.png" class="">

<p>如果不对网站进行重构，我们在实际访问网站后台管理界面 <code>192.168.110.113/admin</code> 时就会报错</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/51.png" class="">

<p>很明显这个报错信息是指数据库连接不上，就是说现在缺数据库。看宝塔面板也可以发现，里面的数据库配置为空</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/52.png" class="">

<p>所以为了能顺利进入网站后台，我们将在下面简单介绍如何重构这个网站。这里首先需要使用网站数据库所在的服务器 IP 解压检材五，容器密码为：<code>192.168.110.115-CAB2021</code> ，然后发现检材五为一个raid重组后的阵列的三个镜像，需要对其进行raid重组</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/53.png" class="">

<p>我们使用 R-Studio 这个工具</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/54.png" class="">

<p>点击“打开镜像”</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/55.png" class="">

<p>需要改为全部文件，否则识别不到 dd 文件</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/56.png" class="">

<p>导入成功后，点击“创建虚拟RAID”</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/57.png" class="">

<p>选择“创建虚拟块RAID和自动检测”，并将三个镜像文件“添加到RAID”</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/58.png" class="">

<p>添加后点击“自动检测”</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/59.png" class="">

<p>检测结束后会告诉我们可能的重组方式</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/60.png" class="">

<p>我们可以看到，可能性最高的重组方式就是 123 RAID5左同步，数据块大小为 64k 。于是我们点击“应用”，如果成功，一般会恢复出一些分区</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/61.png" class="">

<p>接着我们需要导出恢复出的镜像，选中“虚拟块RAID 1”，点击“创建镜像”，选择“逐字节镜像”</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/62.png" class="">

<p>然后我们就得到了一个可以用来仿真的服务器镜像，我们使用火眼仿真取证软件进行仿真</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/63.png" class="">

<p>常规操作，先登录，然后 <code>ifconfig</code> 一下确认 IP 是否为192.168.110.115，然后再次访问 <code>192.168.110.113/admin</code> 就可以成功啦（当然这时也得保证 Web3 的镜像也在仿真ing）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/64.png" class="">

<p>这时可以发现，地址自动变更为了 <a href="http://192.168.110.113/admin/common/login.shtml">http://192.168.110.113/admin/common/login.shtml</a></p>
<h2 id="已该涉案网站代码中对登录用户的密码做了加密处理。请找出加密算法中的salt值"><a href="#已该涉案网站代码中对登录用户的密码做了加密处理。请找出加密算法中的salt值" class="headerlink" title="已该涉案网站代码中对登录用户的密码做了加密处理。请找出加密算法中的salt值"></a>已该涉案网站代码中对登录用户的密码做了加密处理。请找出加密算法中的salt值</h2><p>同理，涉及管理员用户密码的代码肯定在 <code>/admin</code> 目录下，最终查找发现 common.php 文件中有写到管理员密码的加密方式</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/65.png" class="">

<p>我们可以看到在加密过程中，在原密码 md5 后又拼接了 password_code 的 md5 ，此外在注释中也写到了 password_code 是密码额外加密字符，这不就说明参与拼接的字符串 password_code 就是我们要找的 salt 值吗</p>
<h2 id="请分析该网站的管理员用户的密码为"><a href="#请分析该网站的管理员用户的密码为" class="headerlink" title="请分析该网站的管理员用户的密码为"></a>请分析该网站的管理员用户的密码为</h2><p>这需要我们去查找网站运行时的日志文件，我们首先查看 <code>/www/wwwlogs/www.honglian7001.log</code> 文件，很可惜里面没有有关 password 的信息，然后就在网站的目录里继续寻找，最终可以发现在 <code>/www/wwwroot/www.honglian7001/runtime/log</code> 路径下有很可疑的 202104 文件夹，进入文件夹发现了 24.log 这个简直要将答案“呼之欲出”的日志文件，赶紧打开全局搜索一下 password</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/66.png" class="">

<p>但是此时搜到了两个不同结果，分别是 123456 和 security ，对应用户名还都是 admin 。这时的解决方法就是拿这两对用户名密码去尝试登录之前已经重构好的网页后台，能够顺利登录的就是正确的用户名密码。最终发现，admin&#x2F;security 可以顺利登录</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/67.png" class="">

<h2 id="在对后台账号的密码加密处理过程中，后台一共计算几次哈希值"><a href="#在对后台账号的密码加密处理过程中，后台一共计算几次哈希值" class="headerlink" title="在对后台账号的密码加密处理过程中，后台一共计算几次哈希值"></a>在对后台账号的密码加密处理过程中，后台一共计算几次哈希值</h2><p>继续查看之前找到的 common.php 文件就一目了然啦（三次）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/68.png" class="">

<h2 id="请统计，后台中，一共有多少条设备记录"><a href="#请统计，后台中，一共有多少条设备记录" class="headerlink" title="请统计，后台中，一共有多少条设备记录"></a>请统计，后台中，一共有多少条设备记录</h2><p>进入后台很轻松就查到了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/69.png" class="">

<h2 id="请通过后台确认，本案中受害者的手机号码为"><a href="#请通过后台确认，本案中受害者的手机号码为" class="headerlink" title="请通过后台确认，本案中受害者的手机号码为"></a>请通过后台确认，本案中受害者的手机号码为</h2><p>37和38两题其实需要结合检材四的取证分析才能知道（拿到伊对APP中的聊天记录，就可以大致确定受害者第一次打开APP的时间），然后再去后台查找时间上最接近的登录记录即可</p>
<p>注：如果我们没有找到网站后台的管理员用户名密码，该怎么进入网站后台呢？</p>
<p>我们已知检材五是为网站提供数据库的服务器，即意味着在检材五上一定有和数据库相关的服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl | grep sql</span><br><span class="line">service mysqld status</span><br></pre></td></tr></table></figure>

<p>进行查看</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/70.png" class="">

<p>我们通过之前的题目已知登录数据库的服务器地址以及用户名和密码还有端口</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/71.png" class="">

<p>我们就可以通过命令 <code>mysql -uwww_honglian7001 -pwxrM5GtNXk5k5EPX</code> 来连接数据库，但在第一次连接时会报错（直接原因是由于数据库中有空用户存在，导致使用工具无法连接数据库，跳过后删除空用户，还原配置则可以成功登陆数据库）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/72.png" class="">

<p>解决方法也很简单，修改 mysql 的配置文件即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure>

<p>在 [mysqld] 后加一句 <code>skip-grant-tables</code> 跳过登录的权限检查，保存后重启 mysql 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service mysqld restart </span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/73.png" class="">

<p>接着，我们通过 Navicat 连接数据库</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/74.png" class="">

<p>然后就能很快找到网站后台管理员登录密码的 hash 值</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/75.png" class="">

<p>因为我们已知网站对于登录用户的密码处理方式</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/76.png" class="">

<p>所以我们可以自己构造密码进行处理，然后替换掉数据库中对应 admin 用户的密码，下面我们以 123456 为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$password = &#x27;123456&#x27;</span><br><span class="line">md5($password) = e10adc3949ba59abbe56e057f20f883e</span><br><span class="line">md5($password_code) = 7f5918fe56f4a01d8b206f6a8aee40f2</span><br><span class="line">md5(md5($password) . md5($password_code)) = 9eb2b9ad495a75f80f9cf67ed08bbaae</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/77.png" class="">

<p>修改后就可以直接使用 admin&#x2F;132456 登录网站后台啦</p>
<h2 id="请分析，本案中受害者的通讯录一共有多少条记录"><a href="#请分析，本案中受害者的通讯录一共有多少条记录" class="headerlink" title="请分析，本案中受害者的通讯录一共有多少条记录"></a>请分析，本案中受害者的通讯录一共有多少条记录</h2><p>见第 37 题</p>
<h1 id="检材四（容器密码：192-168-110-203-CAB2021）"><a href="#检材四（容器密码：192-168-110-203-CAB2021）" class="headerlink" title="检材四（容器密码：192.168.110.203-CAB2021）"></a>检材四（容器密码：192.168.110.203-CAB2021）</h1><p>通过对检材二和三进行分析，警方通过 IP 落地，警方掌成功抓获犯罪嫌疑人，现将嫌疑人的 PC 机和手机进行了取证，分别制作了镜像，请使用第 13 题的答案对检材四进行解密</p>
<h2 id="请计算检材四-PC的原始硬盘的SHA256值"><a href="#请计算检材四-PC的原始硬盘的SHA256值" class="headerlink" title="请计算检材四-PC的原始硬盘的SHA256值"></a>请计算检材四-PC的原始硬盘的SHA256值</h2><p>当使用火眼证据分析软件分析PC.E01镜像时，会提示</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/78.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/79.png" class="">

<p>这说明 pc 机本身是系统级 BitLocker 加密，因此直接用火眼加载的时候没有密钥是分析不出内容的。所以，在未解密分区 3 之前，无法正确计算检材四-PC的原始硬盘的 SHA256 值。但是不难发现，该 PC 还有几个分区是未被加密的，那么 BitLocker 恢复密钥很可能就在这几个分区中，其实在文件系统中搜索 Bitlocker 就能找到</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/80.png" class="">

<p>选中文件，右键，选中“使用本地默认程序打开”</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/81.png" class="">

<p>里面就有我们需要的BitLocker恢复密钥，然后就可以成功解密分区3啦。之后自然就可以正确计算检材四-PC的原始硬盘的 SHA256 值了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/82.png" class="">

<h2 id="请分析，检材四-PC的Bitlocker加密分区的解密密钥为"><a href="#请分析，检材四-PC的Bitlocker加密分区的解密密钥为" class="headerlink" title="请分析，检材四-PC的Bitlocker加密分区的解密密钥为"></a>请分析，检材四-PC的Bitlocker加密分区的解密密钥为</h2><p>由 39 题可知，检材四-PC的 Bitlocker 加密分区的解密密钥为 <code>511126-518936-161612-135234-698357-082929-144705-622578</code></p>
<h2 id="请分析，检材四-PC的开机密码为"><a href="#请分析，检材四-PC的开机密码为" class="headerlink" title="请分析，检材四-PC的开机密码为"></a>请分析，检材四-PC的开机密码为</h2><p>在完成分区 3 的解密后，火眼证据分析软件就自动给出了检材四-PC的开机账号和密码</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/83.png" class="">

<p>或者使用火眼仿真取证软件进行仿真（填入恢复密钥），也能自动获取 PC 的开机密码</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/84.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/85.png" class="">

<h2 id="经分析发现，检材四-PC是嫌疑人用于管理服务器的设备，其主要通过哪个浏览器控制网站后台"><a href="#经分析发现，检材四-PC是嫌疑人用于管理服务器的设备，其主要通过哪个浏览器控制网站后台" class="headerlink" title="经分析发现，检材四-PC是嫌疑人用于管理服务器的设备，其主要通过哪个浏览器控制网站后台"></a>经分析发现，检材四-PC是嫌疑人用于管理服务器的设备，其主要通过哪个浏览器控制网站后台</h2><p>查看火眼证据分析软件的分析板块可以发现，嫌疑人的 PC 上一共有三个浏览器，那么直接查看浏览器的历史记录即可判断</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/86.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/87.png" class="">

<p>最终可以确定是Chrome浏览器</p>
<h2 id="请计算PC检材中用户目录下的zip文件的sha256值"><a href="#请计算PC检材中用户目录下的zip文件的sha256值" class="headerlink" title="请计算PC检材中用户目录下的zip文件的sha256值"></a>请计算PC检材中用户目录下的zip文件的sha256值</h2><p>直接找就是了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/88.png" class="">

<p>然后计算哈希</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/89.png" class="">

<h2 id="请分析检材四-phone，该手机的IMEI号为"><a href="#请分析检材四-phone，该手机的IMEI号为" class="headerlink" title="请分析检材四-phone，该手机的IMEI号为"></a>请分析检材四-phone，该手机的IMEI号为</h2><p>IMEI是国际移动设备识别码，即通常所说的手机序列号、手机“串号”，用于在移动电话网络中识别每一部独立的手机等移动通信设备，相当于移动电话的身份证。手机 IMEI 码由15-17位数字组成。我们使用火眼证据分析软件打开 phone.image ，很快就能找到</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/90.png" class="">

<p>双卡手机，有两个 IMEI 号</p>
<h2 id="请分析检材四-phone，嫌疑人和本案受害者是通过什么软件开始接触的"><a href="#请分析检材四-phone，嫌疑人和本案受害者是通过什么软件开始接触的" class="headerlink" title="请分析检材四-phone，嫌疑人和本案受害者是通过什么软件开始接触的"></a>请分析检材四-phone，嫌疑人和本案受害者是通过什么软件开始接触的</h2><p>先看看受害者手机上有啥APP</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/91.png" class="">

<p>结合裸聊受骗的题目背景，伊对和 Uki 这两个社交软件是最有可能的，分别对这两软件进行深入查找，可以发现伊对里的聊天记录时间和案发时间 4.24 是最重合的</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/92.png" class="">

<p>看到“马铃薯视频”这几个字相信可以直接确定答案了（伊对）。同时，通过继续查看聊天记录，我们能大概确定受害人是在 2021-04-24 14:39:26 时间左右（北京时间）第一次打开了裸聊app</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/93.png" class="">

<p>所以我们就可以回到之前在网站后台查找受害者手机号码和通讯录记录的问题，找到最后登陆时间和上述消息时间最接近的记录，就可以确定受害人的一些具体信息啦</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/94.png" class="">

<h2 id="请分析检材四-phone，受害者下载恶意APK安装包的地址为"><a href="#请分析检材四-phone，受害者下载恶意APK安装包的地址为" class="headerlink" title="请分析检材四-phone，受害者下载恶意APK安装包的地址为"></a>请分析检材四-phone，受害者下载恶意APK安装包的地址为</h2><p>聊天记录中也有</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/95.png" class="">

<h2 id="请分析检材四-phone，受害者的微信内部ID号为"><a href="#请分析检材四-phone，受害者的微信内部ID号为" class="headerlink" title="请分析检材四-phone，受害者的微信内部ID号为"></a>请分析检材四-phone，受害者的微信内部ID号为</h2><p>注意，这里问的是受害者不是嫌疑人，由之前伊对的聊天记录可以知道，受害者叫金先生，那么继续找微信的聊天记录就好啦</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/96.png" class="">

<h2 id="请分析检材四-phone，嫌疑人用于敲诈本案受害者的QQ账号为"><a href="#请分析检材四-phone，嫌疑人用于敲诈本案受害者的QQ账号为" class="headerlink" title="请分析检材四-phone，嫌疑人用于敲诈本案受害者的QQ账号为"></a>请分析检材四-phone，嫌疑人用于敲诈本案受害者的QQ账号为</h2><p>注意，这里问的是嫌疑人不是受害者，那么继续找 QQ 的聊天记录就好啦</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/97.png" class="">

<h2 id="请综合分析，嫌疑人用于管理敲诈对象的容器文件的SHA256值为"><a href="#请综合分析，嫌疑人用于管理敲诈对象的容器文件的SHA256值为" class="headerlink" title="请综合分析，嫌疑人用于管理敲诈对象的容器文件的SHA256值为"></a>请综合分析，嫌疑人用于管理敲诈对象的容器文件的SHA256值为</h2><p>由之前的取证可以知道（前面计算 zip 文件的哈希时其实已经在为后面做铺垫了），“我的赚钱工具.zip”这个压缩包，大小竟然有 8.7G 左右，这很明显不正常，我们将其导出解压（密码12306，即PC的开机密码，这个需要猜一下）</p>
<p>我们在解压后可以看到得到的文件实际上是一个虚拟机目录</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/98.png" class="">

<p>于是我们将其导入VMware（直接双击 vmx 文件即可），发现有开机密码，这时就可以先用火眼仿真取证软件进行仿真（选择那个不带后缀000002的 vmdk 镜像文件），即可拿到密码</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/99.png" class="">

<p>进行登录，发现桌面干干净净啥东西都没有</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/100.png" class="">

<p>这时想起之前解压的虚拟机目录下有快照，所以我们还原快照</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/101.png" class="">

<p>重新启动，这下该有的都有了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/102.png" class="">

<p>我们可以发现桌面上没什么有价值的文件，所以就打开我的电脑，看一眼快速访问，好家伙果然发现了些奇奇怪怪的文件（名为小白鼠.txt 的疑似加密文件和名为 key.rar 的疑似密钥文件，小白鼠这个名字加上 1GB 的 txt 文件真的很暗示，小白鼠感觉很明显就是在暗指题目所说的敲诈对象嘛）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/103.png" class="">

<p>我们试着用桌面上的 VeraCrypt 进行解密</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/104.png" class="">

<p>VeraCrypt 一打开也有小白鼠.txt ，这几乎属于明示了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/105.png" class="">

<p>果然成功，赶紧进到 A 盘里看看有啥好东西。打开一看，里面不就是所有敲诈对象们的信息嘛</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/106.png" class="">

<p>这也同时说明小白鼠.txt 就是我们要找的嫌疑人用于管理敲诈对象的容器文件，接下来算哈希就好办了</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/107.png" class="">

<p>此外，从上述分析也可知道，嫌疑人的主要电脑并没有被用于敲诈过程，整个过程是在嫌疑人电脑中的虚拟机里完成（嫌疑人很聪明，每次干完坏事，直接在虚拟机里打个快照然后把东西全删了）</p>
<h2 id="请综合分析嫌疑人检材，另外一受害者“郭先生”的手机号码为"><a href="#请综合分析嫌疑人检材，另外一受害者“郭先生”的手机号码为" class="headerlink" title="请综合分析嫌疑人检材，另外一受害者“郭先生”的手机号码为"></a>请综合分析嫌疑人检材，另外一受害者“郭先生”的手机号码为</h2><p>直接进“郭先生”的文件夹里找就行了，设备通讯录的文件名中的电话号就是郭先生的手机号啦</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/108.png" class="">

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/109.png" class="">

<h2 id="通过嫌疑人检材，其中记录了几位受害者的信息"><a href="#通过嫌疑人检材，其中记录了几位受害者的信息" class="headerlink" title="通过嫌疑人检材，其中记录了几位受害者的信息"></a>通过嫌疑人检材，其中记录了几位受害者的信息</h2><p>很明显 5 位</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/110.png" class="">

<h2 id="请使用第11题的密码解压“金先生转账-zip”文件，并对压缩包中的文件计算SHA256值"><a href="#请使用第11题的密码解压“金先生转账-zip”文件，并对压缩包中的文件计算SHA256值" class="headerlink" title="请使用第11题的密码解压“金先生转账.zip”文件，并对压缩包中的文件计算SHA256值"></a>请使用第11题的密码解压“金先生转账.zip”文件，并对压缩包中的文件计算SHA256值</h2><p>已知“金先生转账.zip”就在桌面上，解压密码为 <code>c74d97b01eae257e44aa9d5bade97baf</code> ，我们解压后发现只有一个文件“金先生转账.jpg”，所以就简单在终端算一下哈希就好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -hashfile 金先生转账.jpg sha256</span><br></pre></td></tr></table></figure>

<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/111.png" class="">

<h2 id="请综合分析，受害者一共被嫌疑人敲诈了多少钱（转账截图被隐藏在多个地方）"><a href="#请综合分析，受害者一共被嫌疑人敲诈了多少钱（转账截图被隐藏在多个地方）" class="headerlink" title="请综合分析，受害者一共被嫌疑人敲诈了多少钱（转账截图被隐藏在多个地方）"></a>请综合分析，受害者一共被嫌疑人敲诈了多少钱（转账截图被隐藏在多个地方）</h2><p>此处受害人单指金先生，说实话这个还是挺难找的（太费时间且很难找全，性价比不高，可以放弃去做其他题）</p>
<p>手机里有三笔</p>
<p>伊对：1000元</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/112.png" class="">

<p>微信：2000元</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/113.png" class="">

<p>QQ：600元</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/114.png" class="">

<p>此外 QQ 聊天记录中还提到了另外两笔转账</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/115.png" class="">

<p>有一笔就在上面拿到的“金先生转账.jpg”里，2000元</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/116.png" class="">

<p>最后一笔比较难找，在检材五的数据库里，找到“我的账单”表，右键保存数据为 1.jpg（数据库里是可以存图片的，blob格式）</p>
<img src="/2022/10/30/2021%E9%95%BF%E5%AE%89%E6%9D%AFwp/117.png" class="">

<p>最后一算，一共是 <code>1000 + 2000 + 600 + 2000 + 1000 = 6600元</code></p>
<p>（其实短信中也有相关敲诈剧情，但没成功罢了）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>题目间的关联性很强，很多题目没法第一次就出答案，要等做到后面题时回过头来再完成。此次长安杯把入口点设在了 APK 上，并且涉及到了许多服务器取证的相关知识，延续了长安杯一贯的风格；网站重构也基本是年年都考，具体的重构方法也需要好好学习一下</p>
]]></content>
      <categories>
        <category>电子数据取证</category>
      </categories>
      <tags>
        <tag>电子数据取证</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog使用中一些常见报错的解决方法</title>
    <url>/2022/11/15/Blog%E4%BD%BF%E7%94%A8%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本篇博客简单记录了Blog在使用中遇到的一些常见报错的解决方法</p>
<span id="more"></span>

<h1 id="Error：spawn-failed"><a href="#Error：spawn-failed" class="headerlink" title="Error：spawn failed"></a>Error：spawn failed</h1><p>解决方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除Blog根目录下的.deploy_git文件夹</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>解决方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除Blog根目录下的.deploy_git和public文件夹</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog搭建小结</title>
    <url>/2022/10/09/Blog%E6%90%AD%E5%BB%BA%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>耗时两天终于把博客搭了个七七八八……做个简单记录吧</p>
<span id="more"></span>

<p>网上有很多关于Next主题的优化，但经仔细考虑，我还是决定不采用那些“花里胡哨”的改动。一是个人素喜欢简洁点的搭配，二是花样多了难免加大博客的加载负担。话虽如此，当前搭建的博客仍有三处使我不太满意，故留此记录，以后有时间一定要再优化一番</p>
<p>一是菜单栏photos那，我更改languages目录下的<code>zh-CN.yml</code>文件后，photos还是无法翻译，不知是哪出了问题……</p>
<p>二是文章设置了主页预览后，点击阅读全文会直接接着从预览文字后头开始显示，个人不太喜欢这种方案，感觉文章还是重新从头开始显示的好……</p>
<p>三是用户评论那感觉有些繁琐，发个评论还需要注册个畅言账号，不太友好，现在有点懒的换，以后争取有时间换一个便捷点的……</p>
<p>总体来看，现在的博客还是不错的，像模像样了，凑合先用着吧</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架-Django框架及Python3语法</title>
    <url>/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>本篇博客简单记录了Django框架学习中的<strong>Django框架及Python3语法</strong>的相关内容（AcWing-day21）</p>
<span id="more"></span>

<h1 id="Django框架"><a href="#Django框架" class="headerlink" title="Django框架"></a>Django框架</h1><h2 id="Django简介"><a href="#Django简介" class="headerlink" title="Django简介"></a>Django简介</h2><ul>
<li>Django是后起之秀，近些年越来越流行，Youtube（月活20亿+）、Instagram（月活10亿+）等公司均采用了Django框架</li>
<li>Django框架可以作为Web、App、小程序、AcWing云端App（AC APP）等各种项目的后端</li>
</ul>
<h2 id="Django优势"><a href="#Django优势" class="headerlink" title="Django优势"></a>Django优势</h2><ul>
<li>开发效率高，生态完善，有 <a href="https://www.djangoproject.com/">官方社区</a> 长期支持</li>
<li>运行效率高（常见误区：<code>Python</code> 运行效率低，所以 <code>Python</code> 写的应用运行效率也低）<ol>
<li>项目运行效率的瓶颈有很多，如：数据库查询、网络带宽&#x2F;延迟、硬盘读写速度等，这些均与框架关系不大</li>
<li>计算密集型的模块可以用 <code>C/C++</code> 实现，然后编译成动态链接库再 <code>import</code> 进来</li>
<li>计算密集型的微服务可以通过 <code>thrift</code> 等工具对接，微服务的 <code>Server</code> 端代码可以用 <code>C/C++</code> 实现</li>
<li>有很多工具可以将 <code>Python</code> 代码翻译成 <code>C/C++</code> ，如 <code>Cython</code> 、<code>Pypy</code> 等。AcWing 题库中的不少题目，会发现 <code>Python3</code> 比 <code>Java</code> 还快一些</li>
</ol>
</li>
<li>既适合大公司，也适合个人开发者，平均开发一个Web&#x2F;AC App只需要半个月到一个月</li>
</ul>
<h2 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h2><p>在之后的Django框架学习中，会尝试开发一款支持在线联机对战的简易版吃鸡游戏，前后端分离，前端支持AC APP端和Web端</p>
<p>功能包括：</p>
<ul>
<li>游戏菜单、游戏设置：熟悉 <code>http</code> 协议</li>
<li>存储对局信息、账户信息：熟悉数据库操作</li>
<li>在 <code>Redis</code> 中存储每局对战状态：熟悉内存数据库操作</li>
<li>在线聊天室、实时移动、实时放技能：熟悉 <code>websocket</code> 协议</li>
<li>在线匹配系统：熟悉 <code>thrift</code> 和微服务</li>
<li>配置 <code>nginx</code> ：熟悉 <code>nginx</code> 部署云服务</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/1.png" class="">

<ul>
<li>完全无需配置本地环境。利用 <code>Terminal</code> 直接在云端开发，使用工具：<code>vim</code> 、<code>tmux</code> 等。不推荐在本地开发<ol>
<li>实战项目会涉及多台服务器间的网络通信，如在本地开发，未来将不方便调试与部署</li>
<li>在本地开发无法统一开发环境，部分 <code>Python</code> 包在 <code>Windows</code> 系统上安装困难</li>
</ol>
</li>
<li>需要一台具有 <code>公网IP</code> 的云服务器，并安装 <code>docker</code><ol>
<li>服务器配置无要求</li>
<li>后期可以利用 <code>docker</code> 随意迁移</li>
</ol>
</li>
<li>使用统一的 <code>docker</code> 镜像<ol>
<li>标准化开发环境，避免未来出现软件版本不兼容的情况</li>
<li>省去极为麻烦的配环境环节</li>
</ol>
</li>
<li>使用 <code>AC Git</code> 管理项目代码<ol>
<li>方便回滚代码</li>
</ol>
</li>
</ul>
<h1 id="Python3语法"><a href="#Python3语法" class="headerlink" title="Python3语法"></a>Python3语法</h1><p>面向<a href="https://docs.python.org/zh-cn/3/tutorial/index.html">Python3官方文档</a> 学习</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>Flask框架太轻量，功能远没有Django框架全面</li>
<li>Python容易调试，且Python是完备的语言，最大的好处是可以跟着官方文档来学</li>
<li>后端主要负责管理各种服务，如mysql、redis、云盘、thrift等</li>
<li>前后端分离的好处在于一个后端可以对接多个前端</li>
<li>推荐直接在云端进行开发</li>
<li>Python文件的开头建议加上以下两行</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行Python文件可用 <code>python3 main.py</code> 或 <code>./main.py</code></li>
<li>Python中使用 <code>#</code> 进行注释</li>
<li>Python中 <code>/</code> 默认是浮点数运算，<code>//</code> 才是整除（向下取整），<code>**</code> 是乘方</li>
<li>Python中无需特别定义变量，为变量赋值即为定义变量</li>
<li>交互模式下，上一次输出的表达式的值会赋给变量 <code>_</code> </li>
<li>Python中无论 <code>&#39;&#39;</code> 还是 <code>&quot;&quot;</code> 都表示字符串，<code>\</code> 用于转义；单引号中的双引号无需转义，双引号中的双引号需要转义；字符串前加 <code>r</code> 可以原样输出字符串；<code>&quot;&quot;&quot;</code> 也表示字符串</li>
<li>Python中的字符串支持索引（下标访问，就像数组那样）；索引还支持负数，即从左往右访问，下标从 0 开始，从右往左访问，下标从 -1 开始；除了索引，字符串还支持切片（用于提取子字符串，左闭右开）；字符串常与 <code>split()</code> 方法搭配使用</li>
<li>Python中的字符串是不能修改的，因此为字符串中某个索引位置赋值会报错；要生成不同的字符串，应新建一个字符串</li>
<li>Python的内置函数 <code>len()</code> 可以返回Python中所有类型变量的长度</li>
<li>Python中共有三个常用的数据结构，<code>list</code>（列表）、<code>set</code>（集合）、<code>dict</code>（字典）</li>
<li>列表就是数组，是用中括号标注、逗号分隔的一组值，列表可以包含不同类型的元素；和字符串一样，列表也支持索引和切片；列表还支持合并操作；列表可以打包，也可以解包</li>
<li>与字符串不同，列表的内容可以改变；<code>append()</code> 方法可以在列表结尾添加新元素；为切片赋值可以改变列表大小，甚至清空整个列表；还可以嵌套列表；<code>sorted()</code> 函数可以对列表进行排序，<code>reversed()</code> 函数可以对列表进行反转，但它们均不会对原列表产生修改；列表的 <code>sort()</code> 方法可以对列表进行排序，列表的 <code>reverse()</code> 方法可以对列表进行反转，且它们均是对原列表的修改</li>
<li>Python通过缩进区分代码块</li>
<li>Python中的 <code>for</code> 语句是迭代列表或字符串等任意序列；也可以遍历集合，但遍历集合时会修改集合的内容，容易生成错误的结果，因此不能直接进行循环，而是应遍历该集合的副本或创建新的集合</li>
<li>Python的内置函数 <code>range()</code> 常用于遍历数字序列，左闭右开，还可以设置步长（可以为负）</li>
<li>Python中的循环语句支持 <code>else</code> 子句；<code>for</code> 循环中，可迭代对象中的元素全部循环完毕，或 <code>while</code> 循环的条件为假时，执行该子句；<code>break</code> 语句没有终止循环时，执行该子句</li>
<li>Python中的 <code>True</code> 和 <code>False</code> 首字母需大写</li>
<li>Python中的函数若没有定义返回值，则默认返回 <code>None</code> ；当函数的参数是变量时，若函数内部对变量值进行了修改，也不会影响函数外的变量值；当函数的参数是列表时，若函数内部对列表进行了修改，则会影响函数外的列表，此时传入函数的参数其实是对象的引用；函数的参数可以包含在一个列表或字典中，在调用函数时，可以用 <code>*</code> 操作符把参数从列表或字典中解包出来（ <code>*</code> 列表 or  <code>**</code> 字典）</li>
<li>使用列表推导式创建列表的方式更简洁、易读，如</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<ol start="26">
<li>元组和列表非常相似，唯一的区别在于元组使用小括号（定义的时候甚至可以省略小括号），且元组内的元素不可修改；元组可以打包，也可以解包</li>
<li>集合是由不重复元素组成的无序容器，创建集合用花括号或 <code>set()</code> 函数，创建空集合只能用 <code>set()</code> ，不能用花括号，花括号创建的是空字典；集合常用于成员检测、消除重复元素等。集合对象还支持合集、交集、差集、对称差分等数学运算</li>
<li>Python中的 <code>type()</code> 函数可以返回变量的类型</li>
<li>字典可以理解为键值对的集合，键值对用逗号分隔，且字典的键必须是唯一的；字典的值可以修改；字典的 <code>items()</code> 方法可以将字典转换为列表，列表中的每一元素都是一个二元对</li>
<li>同时循环两个或多个序列时，用 <code>zip()</code> 函数可以将其内的元素一一匹配</li>
<li>为了方便维护程序，最好把脚本拆分成多个文件，然后作为子模块导入主模块。在模块内部，通过全局变量 <code>__name__</code> 可以获取模块名（即字符串）</li>
<li>Python自带一个标准模块的库，非常好用</li>
<li>Python中 <code>%</code> 运算符也可用于字符串格式化。给定 <code>&#39;string&#39; % values</code> ，则 <code>string</code> 中的 <code>%</code> 实例会以零个或多个 <code>values</code> 元素替换，此操作被称为字符串插值</li>
<li>在处理文件对象（读写文件）时，最好使用 <code>with</code> 关键字。优点是子句体结束后，文件会正确关闭，即便触发异常也可以</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">	fout.write(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="35">
<li>Python中的异常处理只需学会以下代码块即可。如不发生异常，则执行 <code>else</code> 代码段；无论是否发生异常，均执行 <code>finally</code> 代码段</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = x / y</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;result is&quot;</span>, result)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;executing finally clause&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="36">
<li>Python中的类只需学会以下代码块即可</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;created!&quot;</span>)</span><br><span class="line">		self.a = [x, y]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.a)):</span><br><span class="line">			self.a[i] *= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ol start="37">
<li>Python中的输入函数是 <code>input()</code> ，多搭配 <code>split()</code> 方法和 <code>map()</code> 函数使用，如一行输入用空格隔开的两个整数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))</span><br></pre></td></tr></table></figure>

<ol start="38">
<li>Python中的或逻辑运算符是 <code>or</code> ，如</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a % b == <span class="number">0</span> <span class="keyword">or</span> b % a == <span class="number">0</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Sao Multiplos&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="39">
<li>Python中求平方根可以使用 <code>math</code> 包的 <code>sqrt()</code> 函数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">x = math.sqrt(y)</span><br></pre></td></tr></table></figure>

<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="AcWing-608-差"><a href="#AcWing-608-差" class="headerlink" title="AcWing 608. 差"></a>AcWing 608. 差</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/2.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">B = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">C = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">D = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># X = A * B - C * D</span></span><br><span class="line"><span class="comment"># print(&quot;DIFERENCA =&quot;, X)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DIFERENCA = %d&quot;</span> % (A * B - C * D))</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-665-倍数"><a href="#AcWing-665-倍数" class="headerlink" title="AcWing 665. 倍数"></a>AcWing 665. 倍数</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/3.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A, B = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> A % B == <span class="number">0</span> <span class="keyword">or</span> B % A == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sao Multiplos&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Nao sao Multiplos&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-670-动物"><a href="#AcWing-670-动物" class="headerlink" title="AcWing 670. 动物"></a>AcWing 670. 动物</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/4.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>()</span><br><span class="line">b = <span class="built_in">input</span>()</span><br><span class="line">c = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a == <span class="string">&#x27;vertebrado&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">&#x27;ave&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;carnivoro&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;aguia&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;pomba&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;onivoro&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;homem&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;vaca&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">&#x27;inseto&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;hematofago&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;pulga&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;lagarta&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;hematofago&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;sanguessuga&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;minhoca&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-660-零食"><a href="#AcWing-660-零食" class="headerlink" title="AcWing 660. 零食"></a>AcWing 660. 零食</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/5.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">prices = [<span class="number">0</span>, <span class="number">4.00</span> , <span class="number">4.50</span>, <span class="number">5.00</span>, <span class="number">2.00</span>, <span class="number">1.50</span>]</span><br><span class="line"><span class="built_in">sum</span> = prices[x] * y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total: R$ %.2f&quot;</span> % <span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-760-字符串长度"><a href="#AcWing-760-字符串长度" class="headerlink" title="AcWing 760. 字符串长度"></a>AcWing 760. 字符串长度</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/6.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">input</span>()))</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-721-递增序列"><a href="#AcWing-721-递增序列" class="headerlink" title="AcWing 721. 递增序列"></a>AcWing 721. 递增序列</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/7.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> a != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, a + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(i, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="AcWing-726-质数"><a href="#AcWing-726-质数" class="headerlink" title="AcWing 726. 质数"></a>AcWing 726. 质数</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/8.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(x)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> x % j == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(x, <span class="string">&quot;is not prime&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(x, <span class="string">&quot;is prime&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-745-数组的右上半部分"><a href="#AcWing-745-数组的右上半部分" class="headerlink" title="AcWing 745. 数组的右上半部分"></a>AcWing 745. 数组的右上半部分</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/9.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">op = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">sum</span>, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        <span class="keyword">if</span> j &gt; i:</span><br><span class="line">            <span class="built_in">sum</span> += a[j]</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> op == <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%.1f&quot;</span> % <span class="built_in">sum</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%.1f&quot;</span> % (<span class="built_in">sum</span> / count))</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-756-蛇形矩阵"><a href="#AcWing-756-蛇形矩阵" class="headerlink" title="AcWing 756. 蛇形矩阵"></a>AcWing 756. 蛇形矩阵</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/10.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此题在面试时考察频率很高</span></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">res = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">dx, dy = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x, y, d = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n * m + <span class="number">1</span>):</span><br><span class="line">    res[x][y] = i</span><br><span class="line">    a, b = x + dx[d], y + dy[d]</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">or</span> a == n <span class="keyword">or</span> b &lt; <span class="number">0</span> <span class="keyword">or</span> b == m <span class="keyword">or</span> res[a][b]:</span><br><span class="line">        d = (d + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">        a, b = x + dx[d], y + dy[d]</span><br><span class="line">    x, y = a, b</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="built_in">print</span>(res[i][j], end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-823-排列"><a href="#AcWing-823-排列" class="headerlink" title="AcWing 823. 排列"></a>AcWing 823. 排列</h2><img src="/2022/12/09/Django%E6%A1%86%E6%9E%B6-Django%E6%A1%86%E6%9E%B6%E5%8F%8APython3%E8%AF%AD%E6%B3%95/11.png" class="">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">path = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">used = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">if</span> u == n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="built_in">print</span>(path[i] + <span class="number">1</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                path[u] = i</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                dfs(u + <span class="number">1</span>)</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                path[u] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django框架</category>
      </categories>
      <tags>
        <tag>Django框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架-配置docker、git环境与项目创建</title>
    <url>/2022/12/22/Django%E6%A1%86%E6%9E%B6-%E9%85%8D%E7%BD%AEdocker%E3%80%81git%E7%8E%AF%E5%A2%83%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>本篇博客简单记录了Django框架学习中的<strong>配置docker、git环境与项目创建</strong>的相关内容（AcWing-day22）</p>
<span id="more"></span>

<h1 id="配置-docker-环境"><a href="#配置-docker-环境" class="headerlink" title="配置 docker 环境"></a>配置 docker 环境</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 Django 镜像上传到自己的云服务器</span></span><br><span class="line">scp /var/lib/acwing/docker/images/ django_lesson_1_0.tar txy:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录自己的云服务器</span></span><br><span class="line">ssh txy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载上传的镜像</span></span><br><span class="line">docker load -i django_lesson_1_0.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用镜像 django_lesson 创建并启动容器 django_server</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时将该容器的 22 端口（ssh登录端口）和 8000 端口（Django调试端口）映射到云服务器的 20000 和 8000 端口上</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器的 20000 和 8000 端口要自己去云平台放行</span></span><br><span class="line">docker run -p 20000:22 -p 8000:8000 --name django_server -itd django_lesson:1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入创建的 docker 容器</span></span><br><span class="line">docker attach django_server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建普通用户 acs 并给予 sudo 权限</span></span><br><span class="line">adduser acs</span><br><span class="line">usermode -aG sudo acs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂起容器</span></span><br><span class="line">ctrl p</span><br><span class="line">ctrl q</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回 AC Terminal 为 acs 用户配置别名（django）和免密登录</span></span><br><span class="line">vim .ssh/config</span><br><span class="line">ssh-copy-id django</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置容器环境，找回初恋的感觉</span></span><br><span class="line">scp .vimrc .bashrc .tmux.conf django:</span><br></pre></td></tr></table></figure>

<h1 id="创建项目并配置-git-环境"><a href="#创建项目并配置-git-环境" class="headerlink" title="创建项目并配置 git 环境"></a>创建项目并配置 git 环境</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回到容器，并打开tumx</span></span><br><span class="line">ssh django</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Django 版本</span></span><br><span class="line">django-admin --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 Django 项目 acapp</span></span><br><span class="line">django-admin startproject acapp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 git 对项目进行管理，生成密钥并将公钥添加至 AC Git</span></span><br><span class="line">ssh-keygen</span><br><span class="line">cat .ssh/id_rsa.pub</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 acapp ，将其初始化为 git 仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 AC Git 上新建名为 acapp 的空白项目，然后依照以下常规流程继续操作</span></span><br><span class="line">git config --global user.name xxx</span><br><span class="line">git config --global user.email xxx@xxx.com</span><br><span class="line">git remote add origin git@git.acwing.com:xxx/XXX.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>

<h1 id="配置-Django-项目"><a href="#配置-Django-项目" class="headerlink" title="配置 Django 项目"></a>配置 Django 项目</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新启一个 tmux ，检查项目能否正常启动</span></span><br><span class="line">python3 manage.py runserver 0.0.0.0:8000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在浏览器中访问 121.5.155.117:8000 （云服务器ip + 8000端口）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提示<span class="string">&quot;Invalid HTTP_HOST header: &#x27;121.5.155.117:8000&#x27;. You may need to add &#x27;121.5.155.117:8000&#x27; to ALLOWED_HOSTS.&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要求我们将 121.5.155.117 添加至 ALLOWED_HOSTS ，故使用 ag 全局搜索  ALLOWED_HOSTS</span></span><br><span class="line">ag ALLOWED-HOSTS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 ag 命令找到 ALLOWED_HOSTS 位于 acapp/settings.py ，打开并完成修改</span></span><br><span class="line">vim acapp/settings.py</span><br><span class="line"></span><br><span class="line">******</span><br><span class="line">ALLOWED_HOSTS = [&quot;121.5.155.117&quot;]</span><br><span class="line">******</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用浏览器再次访问 121.5.155.117:8000 ，提示成功<span class="string">&quot;The install worked successfully! Congratulations!&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 git 仓库的根目录下（acapp），我们可以创建 .gitignore 文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">它可以使项目开发中产生的缓存文件、可执行文件、编译文件等不再通过 git add 提交至暂存区，如：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编写 .gitignore 文件也是我们需要掌握的一项重要技能</span></span><br><span class="line">*/__pycache__</span><br><span class="line">*.swp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建名为 game 的 app</span></span><br><span class="line">python3 manage.py startapp game</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步数据库的修改，消除红字警告</span></span><br><span class="line">python3 manage.py migrate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建管理员账户</span></span><br><span class="line">python3 manage.py createsuperuser</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用浏览器访问 121.5.155.117:8000/admin 即可进入管理员界面，输入刚才创建的账号密码即可登录管理员后台</span></span><br></pre></td></tr></table></figure>

<h1 id="尝试创建-game-app-的主页及更多页面"><a href="#尝试创建-game-app-的主页及更多页面" class="headerlink" title="尝试创建 game app 的主页及更多页面"></a>尝试创建 game app 的主页及更多页面</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd game</span><br><span class="line">touch urls.py</span><br><span class="line">mkdir templates</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">game 目录下各文件（夹）的作用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">models.py : 存放各种数据结构，如 class User</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">views.py : 存放服务器端所有可以被调用的函数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">urls.py : 存放路由（根据浏览器的 url ，决定该调用哪些函数）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">templates : 存放网页模板</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要实现的路由重定向</span></span><br><span class="line">url 输入网址 -&gt; acapp.urls -&gt; game.urls -&gt; game.views.index -&gt; 展示页面</span><br></pre></td></tr></table></figure>

<h2 id="game-views"><a href="#game-views" class="headerlink" title="game.views"></a>game.views</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    line1 = <span class="string">&#x27;&lt;h1 style=&quot;text-align:center&quot;&gt;术士之战&lt;/h1&gt;&#x27;</span></span><br><span class="line">    line2 = <span class="string">&#x27;&lt;img src=&quot;https://img0.baidu.com/it/u=2896101387,78902208&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=480&amp;h=270&quot; width=1500&gt;&#x27;</span></span><br><span class="line">    line3 = <span class="string">&#x27;&lt;a href=&quot;/play/&quot;&gt;进入游戏&lt;/a&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(line1 + line2 + line3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">request</span>):</span><br><span class="line">    line1 = <span class="string">&#x27;&lt;h1 style=&quot;text-align:center&quot;&gt;游戏界面&lt;/h1&gt;&#x27;</span></span><br><span class="line">    line2 = <span class="string">&#x27;&lt;img src=&quot;https://img0.baidu.com/it/u=4141538169,3290815714&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=666&amp;h=500&quot; width=1500&gt;&#x27;</span></span><br><span class="line">    line3 = <span class="string">&#x27;&lt;a href=&quot;/&quot;&gt;返回主页面&lt;/a&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(line1 + line2 + line3)</span><br></pre></td></tr></table></figure>

<h2 id="game-urls"><a href="#game-urls" class="headerlink" title="game.urls"></a>game.urls</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> game.views <span class="keyword">import</span> index, play</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;&quot;</span>, index, name=<span class="string">&quot;index&quot;</span>),</span><br><span class="line">    path(<span class="string">&quot;play/&quot;</span>, play, name=<span class="string">&quot;play&quot;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="acapp-urls"><a href="#acapp-urls" class="headerlink" title="acapp.urls"></a>acapp.urls</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;game.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后，使用浏览器访问 121.5.155.117:8000 即可显示 index 函数返回的页面</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 Pycharm 连接服务器可以参考 https://www.acwing.com/solution/content/107657/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Django框架</category>
      </categories>
      <tags>
        <tag>Django框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-git</title>
    <url>/2022/11/22/Linux%E5%9F%BA%E7%A1%80-git/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>git</strong>的相关内容（AcWing-day17）</p>
<span id="more"></span>

<h1 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h1><p><a href="">git.acwing.com</a></p>
<h1 id="git基本概念"><a href="#git基本概念" class="headerlink" title="git基本概念"></a>git基本概念</h1><p><strong>工作区：</strong>仓库的目录。工作区是独立于各个分支的。<br><strong>暂存区：</strong>数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。<br><strong>版本库：</strong>存放所有已经提交到本地仓库的代码版本。<br><strong>版本结构：</strong>树结构，树中每个节点代表一个代码版本。</p>
<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><ol>
<li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在 <code>~/.gitconfig</code> 文件中</li>
<li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在 <code>~/.gitconfig</code> 文件中</li>
<li><code>git init</code>：将当前目录配置成 <code>git</code> 仓库，信息记录在隐藏的 <code>.git</code> 文件夹中</li>
<li><code>git add XX</code>：将XX文件添加到暂存区</li>
<li><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</li>
<li><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</li>
<li><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将暂存区的内容提交到当前分支</li>
<li><code>git status</code>：查看仓库状态</li>
<li><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</li>
<li><code>git log</code>：查看当前分支的所有版本，按 <code>Q</code> 退出</li>
<li><code>git reflog</code>：查看 <code>HEAD指针</code> 的移动历史（包括被回滚的版本）</li>
<li><code>git reset --hard HEAD^</code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li>
<li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li>
<li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li>
<li><code>git checkout -- XX</code> 或 <code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</li>
<li><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</li>
<li><code>git push -u</code> (第一次需要 <code>-u</code> 以后不需要)：将当前分支推送到远程仓库</li>
<li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li>
<li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li>
<li><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</li>
<li><code>git branch</code>：查看所有分支和当前所处分支</li>
<li><code>git checkout branch_name</code>：切换到branch_name这个分支</li>
<li><code>git merge branch_name</code>：将分支branch_name合并到当前分支上</li>
<li><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</li>
<li><code>git branch branch_name</code>：创建新分支</li>
<li><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</li>
<li><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</li>
<li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</li>
<li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li>
<li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</li>
<li><code>git checkout -t origin/branch_name</code>：将远程的branch_name分支拉取到本地</li>
<li><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</li>
<li><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li>
<li><code>git stash drop</code>：删除栈顶存储的修改</li>
<li><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li>
<li><code>git stash list</code>：查看栈中所有元素</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><p><code>git</code> 是一个很强大的版本管理工具，可持久化，支持多人协同合作</p>
</li>
<li><p><code>git status</code> 红色表示文件在工作区，绿色表示文件在暂存区</p>
</li>
<li><p><code>git rm --cached &lt;file&gt;</code> 将文件从仓库索引目录中删除，不希望管理这个文件</p>
</li>
<li><p><code>git restore --staged &lt;file&gt;</code> 将文件从暂存区中移除，仍管理这个文件，<code>staged</code> 就是暂存区的意思</p>
</li>
<li><p><code>git log</code> 显示从起始结点到当前 <code>HEAD指针</code> 所在结点路径上的所有结点，从下往上看，最下面是最老版本，最上面是最新版本，各结点的前7个字符就是各版本的版本号</p>
</li>
<li><p><code>git log --pretty=oneline</code> 每个版本用一行显示，更加精简</p>
</li>
<li><p><code>git reset --hard HEAD^</code> 代码库回滚到上一个版本，且不会删除回滚前的版本，回滚前的版本会成为一个悬挂结点</p>
</li>
<li><p><code>git reflog</code> 显示 <code>HEAD指针</code> 所有走过的历史结点，同样是从下往上看，最下面是 <code>HEAD指针</code> 所在的最早起始位置，最上面是 <code>HEAD指针</code> 当前所在的最终位置，同时还可以查看各版本的版本号，便于回滚到某一特定的版本（注意，回滚可以是往早前的版本滚，也可以从早前的版本滚回新版本）</p>
</li>
<li><p><code>git restore &lt;file&gt;</code> 将文件在尚未加入暂存区前的修改全部撤销（回滚到当前暂存区中存储的文件版本，如果当前暂存区为空，那么就回滚到 <code>HEAD指针</code> 所在的文件版本）</p>
</li>
<li><p><code>git commit</code> 其实就是将暂存区持久化，每次 <code>commit</code> 可以只 <code>commit</code> 已修改的部分文件，不一定要 <code>commit</code> 所有文件，想 <code>commit</code> 哪个文件将它加到暂存区即可</p>
</li>
<li><p><code>git add</code> 是将工作区中文件的所有修改（新建文件、删除文件、修改文件）提交到暂存区</p>
</li>
<li><p>如果工作区中的文件被误删，在删除操作提交至暂存区之前，都是可以通过 <code>git restore &lt;file&gt;</code> 命令进行回滚的，误删文件即可恢复</p>
</li>
<li><p>删除结点用的不多，故此处暂未提及</p>
</li>
<li><p>在 <code>AC Git</code>（云端）新建项目时，要注意项目名称需和本地的项目文件夹名称一致，每个用户最多可以新建十个项目，如果本地已有项目的仓库，要注意把“使用自述文件初始化仓库”的默认勾选取消</p>
</li>
</ol>
<img src="/2022/11/22/Linux%E5%9F%BA%E7%A1%80-git/1.png" class="">

<ol start="15">
<li><code>git</code> 往云端传文件是通过 <code>ssh</code> 和 <code>scp</code> 实现的，所以需要配置ssh密钥</li>
<li>在推送现有文件夹时，注意本地分支是 <code>master</code> 还是 <code>main</code></li>
</ol>
<img src="/2022/11/22/Linux%E5%9F%BA%E7%A1%80-git/2.png" class="">

<ol start="17">
<li><p>本地删除项目文件夹时，需要加上 <code>-f</code> ，即 <code>rm &lt;file&gt; -rf</code></p>
</li>
<li><p>从云端 <code>clone</code> 项目仓库时，<code>git reflog</code> 会清空，且通常只有一个分支</p>
</li>
<li><p>如果是多人开发，通常不会在主分支上进行开发，一般都会开辟一个新的分支；如果是个人开发，可以直接在主分支上进行开发</p>
</li>
<li><p>可以从任意结点出发创建新的分支，创建新分支后还不会产生新的分支结点，需要等 <code>commit</code> 后才会产生。新分支的起始内容和创建新分支的结点所表示的版本内容完全一致</p>
</li>
<li><p><code>git branch</code>  <code>*</code> 号表示当前所在的分支</p>
</li>
<li><p>工作区和暂存区独立于各个分支，所有分支共用一个暂存区和工作区。每一次 <code>commit</code> ，就会为当前所在的分支创建新结点</p>
</li>
<li><p><code>git merge branch_name</code> 将branch_name分支合并到当前分支的当前结点上</p>
</li>
<li><p>合并分支后需要将无用的分支删去</p>
</li>
<li><p><code>git push --set-upstream origin branch_name</code> 将本地的branch_name分支推送到远程仓库，如果远程仓库没有branch_name这个分支则创建它</p>
</li>
<li><p>云端分支和本地分支是独立的，删除云端分支本地分支不会被删除，删除本地分支云端分支不会被删除，并且云端分支和本地分支的名字也可以不同</p>
</li>
<li><p>删除本地分支时，需要先切换到其他分支才可删除待删除的分支</p>
</li>
<li><p>多人协同开发时，只要没有两人及以上共同修改同一个文件，就不会产生冲突。解决冲突的方法也很简单，<code>git pull</code> 下来对产生冲突的地方进行修改即可</p>
</li>
<li><p><code>git push</code> 和 <code>git pull</code> 很好地解决了在公司和在家开发的问题。无论在哪完成开发，就 <code>git push</code> 到云端，无论在哪需要开发，就从云端 <code>git pull</code> ，从而实现不同机器间的代码同步</p>
</li>
<li><p>在云端删除项目：进入需要删除的项目，“设置—&gt;通用—&gt;高级—&gt;删除项目”</p>
</li>
<li><p>个人独立开发的话一般也就用到四个命令：<code>git pull</code>、<code>git add</code>、<code>git commit</code>、<code>git push</code>，然后 <code>master</code> 到底就可以了</p>
</li>
<li><p>趁早开始维护自己的项目，越早越对找工作有利</p>
</li>
<li><p>建议在配置 <code>git</code> 全局用户名和邮箱时，和 <code>AC Git</code> 的用户名、邮箱保持一致</p>
</li>
<li><p>每使用一台新的机器，如需使用 <code>git</code> ，都需要配置 <code>git</code> 的全局用户名和邮箱，并 <code>ssh-keygen</code> 生成新的公钥，将公钥保存到云端</p>
</li>
<li><p>作业做错了可以用 <code>git reset --hard HEAD^</code> 回滚重做</p>
</li>
</ol>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_5/，然后：</span><br><span class="line">(0) 在当前目录下创建文件夹homework，并将homework目录配置成git仓库。后续作业均在homework目录下操作；</span><br><span class="line">(1) 创建文件readme.txt，内容包含一行：111；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">(2) 在readme.txt文件末尾新增一行：222；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">(3) 创建文件夹：problem1和problem2；</span><br><span class="line">创建文件problem1/main.cpp。文件内容为下述链接中的代码：https://www.acwing.com/problem/content/submission/code_detail/7834813/；</span><br><span class="line">创建文件problem2/main.cpp。文件内容为下述链接中的代码：https://www.acwing.com/problem/content/submission/code_detail/7834819/；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">(4) 删除文件夹problem2；</span><br><span class="line">创建文件夹problem3；</span><br><span class="line">创建文件problem3/main.cpp。文件内容为下述链接中的代码：https://www.acwing.com/problem/content/submission/code_detail/7834841/；</span><br><span class="line">将readme.txt中最后一行222删掉，然后添加一行333；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">(5) 在https://git.acwing.com/上注册账号并创建仓库，仓库名称为homework；</span><br><span class="line">将本地git仓库上传到AC Git云端仓库；</span><br><span class="line">(6) 创建并切换至新分支dev；</span><br><span class="line">在readme.txt文件中添加一行444；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">将dev分支推送至AC Git远程仓库；</span><br><span class="line">(7) 切换回master分支；</span><br><span class="line">在readme.txt文件中添加一行555；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">(8) 将dev分支合并到master分支；</span><br><span class="line">手动处理冲突，使readme文件最终内容包含4行：111、333、555、444；</span><br><span class="line">将修改提交一个commit；</span><br><span class="line">(9) 将master分支的版本库push到AC Git云端仓库；</span><br><span class="line">登录myserver服务器（4. ssh作业中配置的服务器）；</span><br><span class="line">创建并清空文件夹：~/homework/lesson_5/；</span><br><span class="line">将AC Git云端仓库clone到~/homework/lesson_5/中；</span><br></pre></td></tr></table></figure>

<p>(0) 在当前目录下创建文件夹homework，并将homework目录配置成git仓库。后续作业均在homework目录下操作；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir homework</span><br><span class="line">cd homework</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>(1) 创建文件readme.txt，内容包含一行：111；<br>将修改提交一个commit；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim readme.txt</span><br><span class="line">***</span><br><span class="line">111</span><br><span class="line">***</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add readme.txt&quot;</span><br></pre></td></tr></table></figure>

<p>(2) 在readme.txt文件末尾新增一行：222；<br>将修改提交一个commit；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim readme.txt</span><br><span class="line">***</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">***</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add 222&quot;</span><br></pre></td></tr></table></figure>

<p>(3) 创建文件夹：problem1和problem2；<br>创建文件problem1&#x2F;main.cpp。文件内容为下述链接中的代码：</p>
<p><a href="https://www.acwing.com/problem/content/submission/code_detail/7834813/%EF%BC%9B">https://www.acwing.com/problem/content/submission/code_detail/7834813/；</a><br>创建文件problem2&#x2F;main.cpp。文件内容为下述链接中的代码：</p>
<p><a href="https://www.acwing.com/problem/content/submission/code_detail/7834819/%EF%BC%9B">https://www.acwing.com/problem/content/submission/code_detail/7834819/；</a><br>将修改提交一个commit；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir problem1 problem2</span><br><span class="line">cd problem1</span><br><span class="line">vim main.cpp</span><br><span class="line">***</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">***</span><br><span class="line">cd ../problem2</span><br><span class="line">vim main.cpp</span><br><span class="line">***</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    while (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        int v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        for (int j = m; j &gt;= v; j -- )</span><br><span class="line">            f[j] = max(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">***</span><br><span class="line">cd ..</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add problem1 problem2&quot;</span><br></pre></td></tr></table></figure>

<p>(4) 删除文件夹problem2；<br>创建文件夹problem3；<br>创建文件problem3&#x2F;main.cpp。文件内容为下述链接中的代码：</p>
<p><a href="https://www.acwing.com/problem/content/submission/code_detail/7834841/%EF%BC%9B">https://www.acwing.com/problem/content/submission/code_detail/7834841/；</a><br>将readme.txt中最后一行222删掉，然后添加一行333；<br>将修改提交一个commit；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm problem2 -r</span><br><span class="line">mkdir problem3</span><br><span class="line">cd problem3</span><br><span class="line">vim main.cpp</span><br><span class="line">***</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    while (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        int v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        for (int j = v; j &lt;= m; j ++ )</span><br><span class="line">            f[j] = max(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">vim readme.txt</span><br><span class="line">***</span><br><span class="line">111</span><br><span class="line">333</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;many operations&quot;</span><br></pre></td></tr></table></figure>

<p>(5) 在 <a href="https://git.acwing.com/">https://git.acwing.com/</a> 上注册账号并创建仓库，仓库名称为homework；<br>将本地git仓库上传到AC Git云端仓库；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地操作</span></span><br><span class="line">git remote add origin git@git.acwing.com:yxc/homework.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>(6) 创建并切换至新分支dev；<br>在readme.txt文件中添加一行444；<br>将修改提交一个commit；<br>将dev分支推送至AC Git远程仓库；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">vim readme.txt</span><br><span class="line">***</span><br><span class="line">111</span><br><span class="line">333</span><br><span class="line">444</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add 444&quot;</span><br><span class="line"></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>

<p>(7) 切换回master分支；<br>在readme.txt文件中添加一行555；<br>将修改提交一个commit；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master  # 切换回master分支</span><br><span class="line"></span><br><span class="line">vim readme.txt</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">111</span><br><span class="line">333</span><br><span class="line">555</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add 555&quot;</span><br></pre></td></tr></table></figure>

<p>(8) 将dev分支合并到master分支；<br>手动处理冲突，使readme文件最终内容包含4行：111、333、555、444；<br>将修改提交一个commit；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge dev  # 将dev分支合并到当前分支</span><br><span class="line"></span><br><span class="line">vim readme.txt</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">111</span><br><span class="line">333</span><br><span class="line">555</span><br><span class="line">444</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;fix conflicts&quot;</span><br></pre></td></tr></table></figure>

<p>(9) 将master分支的版本库push到AC Git云端仓库；<br>登录myserver服务器（4. ssh作业中配置的服务器）；<br>创建并清空文件夹：~&#x2F;homework&#x2F;lesson_5&#x2F;；<br>将AC Git云端仓库clone到~&#x2F;homework&#x2F;lesson_5&#x2F;中；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh myserver</span><br><span class="line">cd homework</span><br><span class="line">mkdir lesson_5</span><br><span class="line">cd lesson_5</span><br><span class="line"></span><br><span class="line">git clone git@git.acwing.com:yxc/homework.git</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-ssh</title>
    <url>/2022/11/20/Linux%E5%9F%BA%E7%A1%80-ssh/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>ssh</strong>的相关内容（AcWing-day16）</p>
<span id="more"></span>

<h1 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>远程登录服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure>

<ul>
<li><code>user</code>：用户名</li>
<li><code>hostname</code>：IP地址或域名</li>
</ul>
<p>第一次登录时会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;123.57.47.211 (123.57.47.211)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])?</span><br></pre></td></tr></table></figure>

<p>输入 <code>yes</code> ，然后回车即可。</p>
<p>这样会将该服务器的信息记录在 <code>~/.ssh/known_hosts</code> 文件中。</p>
<p>然后输入密码即可登录到远程服务器中。</p>
<p>默认登录端口号为22。如果想登录某一特定端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname -p 22</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>创建文件 <code>~/.ssh/config</code></p>
<p>然后在文件中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure>

<p>之后再使用服务器时，可以直接使用别名 <code>myserver1</code> 、<code>myserver2</code></p>
<h2 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h2><p>创建密钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>然后一直回车即可。</p>
<p>执行结束后，<code>~/.ssh/</code> 目录下会多两个文件：</p>
<ul>
<li><code>id_rsa</code>：私钥</li>
<li><code>id_rsa.pub</code>：公钥</li>
</ul>
<p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p>
<p>例如，想免密登录 <code>myserver</code> 服务器。则将公钥中的内容，复制到 <code>myserver</code> 中的 <code>~/.ssh/authorized_keys</code> 文件里即可。</p>
<p>也可以使用如下命令一键添加公钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure>

<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname command</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname ls -a</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单引号中的<span class="variable">$i</span>可以求值，因为单引号中的内容不会在本地服务器转义，会原样传给云端服务器执行</span></span><br><span class="line">ssh myserver &#x27;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&#x27;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">双引号中的<span class="variable">$i</span>不可以求值，因为双引号中的内容会先在本地服务器解析，由于本地服务器中没有定义<span class="variable">$i</span>这个变量（全局变量），所以此时<span class="variable">$i</span>的值为空，最终本地服务器传给云端服务器的指令就变成了：<span class="keyword">for</span> ((i = 0; i &lt; 10; i ++ )) <span class="keyword">do</span> <span class="built_in">echo</span> 空; <span class="keyword">done</span></span></span><br><span class="line">ssh myserver &quot;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&quot;</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>退出 <code>ssh</code> 登录：<code>Ctrl + D</code> 或 <code>exit</code> 或 <code>logout</code></p>
</li>
<li><p>如果没有 <code>.ssh</code> 文件夹，自己创建即可</p>
</li>
<li><p>配置服务器别名后，直接使用 <code>ssh 别名</code> 即可登录</p>
</li>
<li><p>如需在 <code>authorized_keys</code> 文件中保存多个公钥，则每个公钥间需用回车分隔</p>
</li>
<li><p>开发的时候不推荐在 <code>root</code> 用户下开发，因为这样可能会把服务器搞坏</p>
</li>
<li><p>非常建议配置免密登录</p>
</li>
<li><p>使用 <code>ssh</code> 执行命令时，为避免命令中空格等特殊符号的干扰，<strong>建议使用单引号将整个命令括起来</strong>，因为单引号中的内容不会在本地服务器转义，会原样传给云端服务器执行</p>
</li>
<li><p>使用 <code>ssh</code> 执行命令时，如果一行命令中包含多个子命令，则每个子命令间需要用 <code>;</code>（分号）隔开</p>
</li>
</ol>
<h1 id="scp传文件"><a href="#scp传文件" class="headerlink" title="scp传文件"></a>scp传文件</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp source destination</span><br></pre></td></tr></table></figure>

<p>将 <code>source</code> 路径下的文件复制到 <code>destination</code> 中</p>
<p>一次复制多个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp source1 source2 destination</span><br></pre></td></tr></table></figure>

<p>复制文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r ~/tmp myserver:/home/acs/</span><br></pre></td></tr></table></figure>

<p>将本地家目录中的 <code>tmp</code> 文件夹复制到 <code>myserver</code> 服务器中的 <code>/home/acs/</code> 目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r ~/tmp myserver:homework/</span><br></pre></td></tr></table></figure>

<p>将本地家目录中的 <code>tmp</code> 文件夹复制到 <code>myserver</code> 服务器中的 <code>~/homework/</code> 目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r myserver:homework .</span><br></pre></td></tr></table></figure>

<p>将 <code>myserver</code> 服务器中的 <code>~/homework/</code> 文件夹复制到本地的当前路径下。</p>
<p>指定服务器的端口号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P 22 source1 source2 destination</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> scp的 <code>-r</code> <code>-P</code> 等参数尽量加在 <code>source</code> 和 <code>destination</code> 之前。</p>
<h2 id="使用scp配置其他服务器的vim和tmux"><a href="#使用scp配置其他服务器的vim和tmux" class="headerlink" title="使用scp配置其他服务器的vim和tmux"></a>使用scp配置其他服务器的vim和tmux</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp ~/.vimrc ~/.tmux.conf myserver:</span><br></pre></td></tr></table></figure>

<h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p><code>scp</code> 的参数 <code>-r</code> 和 <code>-P</code> 一定要放到 <code>source</code> 和 <code>destination</code> 的前面</p>
</li>
<li><p>如果需要在两个服务器间传文件，通常的做法是利用本地机做媒介，即一台服务器先将文件传给本地，再由本地传文件给另一台服务器</p>
</li>
<li><p><code>ssh</code> 指定端口用 <code>-p</code>（小p），<code>scp</code> 指定端口用 <code>-P</code>（大P）</p>
</li>
<li><p>无论是上传文件到服务器还是下载文件到本地，同名文件都会直接覆盖，文件夹不覆盖</p>
</li>
</ol>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_4/，然后：</span><br><span class="line">(0) 进入homework_0文件夹，要求：</span><br><span class="line">    [1] 该文件夹内容为空</span><br><span class="line">    [2] 配置服务器账号的密钥登陆方式。服务器信息可以通过如下命令获得：</span><br><span class="line">        homework 4 getinfo</span><br><span class="line">        将服务器账号的名称（Host）配置成：myserver</span><br><span class="line">(1) 进入homework_1文件夹，下列描述中的“本地”均表示当前文件夹。要求：</span><br><span class="line">    [1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_1/</span><br><span class="line">    [2] 将本地的main.cpp文件上传到myserver中的~/homework/lesson_4/homework_1/目录中。</span><br><span class="line">    [3] 在本地创建文件夹dir。</span><br><span class="line">    [4] 将myserver中的/etc/lsb-release文件复制到dir中。</span><br><span class="line">(2) 进入homework_2文件夹，下列描述中的“本地”均表示当前文件夹，要求：</span><br><span class="line">    [1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_2/</span><br><span class="line">    [2] 将本地的dir文件夹上传到myserver中的~/homework/lesson_4/homework_2/目录中。</span><br><span class="line">(3) 进入homework_3文件夹，下列描述中的“本地”均表示当前文件夹，要求：</span><br><span class="line">    [1] 在本地创建文件夹dir。</span><br><span class="line">    [2] 将myserver中的/var/lib/locales/supported.d文件夹下载到本地dir文件夹中。</span><br><span class="line">(4) 进入homework_4文件夹，编写脚本remote_mkdir.sh和remote_rmdir.sh，要求：</span><br><span class="line">    [1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_4/</span><br><span class="line">    [2] 本地目录下仅包含remote_mkdir.sh和remote_rmdir.sh</span><br><span class="line">    [3] remote_mkdir.sh和remote_rmdir.sh具有可执行权限</span><br><span class="line">    [4] remote_mkdir.sh接收一个传入参数。格式为 ./remote_mkdir.sh directory_name</span><br><span class="line">        该操作可以在myserver服务器上的~/homework/lesson_4/homework_4/目录下，创建一个名为directory_name的文件夹</span><br><span class="line">    [5] remote_rmdir.sh接收一个传入传输。格式为 ./remote_rmdir.sh directory_name</span><br><span class="line">        该操作可以将myserver服务器上的~/homework/lesson_4/homework_4/目录下的名为directory_name的文件夹删掉。</span><br><span class="line">    [6] 注意：传入的文件参数可能包含空格。两个脚本均不需要判断传入参数的合法性。</span><br></pre></td></tr></table></figure>

<p>(0) 进入homework_0文件夹，要求：<br>     [1] 该文件夹内容为空<br>     [2] 配置服务器账号的密钥登陆方式。服务器信息可以通过如下命令获得：<br>           homework 4 getinfo<br>           将服务器账号的名称（Host）配置成：myserver</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置服务器别名</span></span><br><span class="line">在`~/.ssh`目录下创建文件：`config`</span><br><span class="line">内容：</span><br><span class="line">Host myserver</span><br><span class="line">    HostName 123.57.47.211</span><br><span class="line">    User acs_8718</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置密钥登录</span></span><br><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure>

<p>(1) 进入homework_1文件夹，下列描述中的“本地”均表示当前文件夹。要求：<br>     [1] 在myserver服务器上创建并清空文件夹：~&#x2F;homework&#x2F;lesson_4&#x2F;homework_1&#x2F;<br>     [2] 将本地的main.cpp文件上传到myserver中的~&#x2F;homework&#x2F;lesson_4&#x2F;homework_1&#x2F;目录中。<br>     [3] 在本地创建文件夹dir。<br>     [4] 将myserver中的&#x2F;etc&#x2F;lsb-release文件复制到dir中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在myserver端</span></span><br><span class="line">mkdir ~/homework/lesson_4/homework_1/ -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在本地</span></span><br><span class="line">scp main.cpp myserver:homework/lesson_4/homework_1</span><br><span class="line">mkdir dir</span><br><span class="line">scp myserver:/etc/lsb-release dir</span><br></pre></td></tr></table></figure>

<p>(2) 进入homework_2文件夹，下列描述中的“本地”均表示当前文件夹，要求：<br>     [1] 在myserver服务器上创建并清空文件夹：~&#x2F;homework&#x2F;lesson_4&#x2F;homework_2&#x2F;<br>     [2] 将本地的dir文件夹上传到myserver中的~&#x2F;homework&#x2F;lesson_4&#x2F;homework_2&#x2F;目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在myserver端</span></span><br><span class="line">cd homework/lesson_4</span><br><span class="line">mkdir homework_2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在本地</span></span><br><span class="line">scp -r dir/ myserver:homework/lesson_4/homework_2</span><br></pre></td></tr></table></figure>

<p>(3) 进入homework_3文件夹，下列描述中的“本地”均表示当前文件夹，要求：<br>     [1] 在本地创建文件夹dir。<br>     [2] 将myserver中的&#x2F;var&#x2F;lib&#x2F;locales&#x2F;supported.d文件夹下载到本地dir文件夹中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在本地</span></span><br><span class="line">mkdir dir</span><br><span class="line">scp -r myserver:/var/lib/locales/supported.d dir</span><br></pre></td></tr></table></figure>

<p>(4) 进入homework_4文件夹，编写脚本remote_mkdir.sh和remote_rmdir.sh，要求：<br>     [1] 在myserver服务器上创建并清空文件夹：~&#x2F;homework&#x2F;lesson_4&#x2F;homework_4&#x2F;<br>     [2] 本地目录下仅包含remote_mkdir.sh和remote_rmdir.sh<br>     [3] remote_mkdir.sh和remote_rmdir.sh具有可执行权限<br>     [4] remote_mkdir.sh接收一个传入参数。格式为 .&#x2F;remote_mkdir.sh directory_name<br>           该操作可以在myserver服务器上的~&#x2F;homework&#x2F;lesson_4&#x2F;homework_4&#x2F;目录下，创建一个名为directory_name的文件夹<br>     [5] remote_rmdir.sh接收一个传入传输。格式为 .&#x2F;remote_rmdir.sh directory_name<br>           该操作可以将myserver服务器上的~&#x2F;homework&#x2F;lesson_4&#x2F;homework_4&#x2F;目录下的名为directory_name的文件夹删掉。<br>     [6] 注意：传入的文件参数可能包含空格。两个脚本均不需要判断传入参数的合法性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">remote_mkdir.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">ssh myserver mkdir homework/lesson_4/homework_4/\&quot;$1\&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">remote_rmdir.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">ssh myserver rm homework/lesson_4/homework_4/\&quot;$1\&quot; -r</span><br><span class="line"></span><br><span class="line">因为传入的文件参数可能包含空格，所以需要把$1用双引号括起来，又为了避免双引号导致$1在本地服务器解析，所以需要在双引号前加上`\`进行转义</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-shell语法</title>
    <url>/2022/11/18/Linux%E5%9F%BA%E7%A1%80-shell%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>shell语法</strong>的相关内容（AcWing-day15）</p>
<span id="more"></span>

<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>shell是我们通过命令行与操作系统沟通的语言。</p>
<p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。</p>
<p>Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。</p>
<p>Linux中常见的shell脚本有很多种，常见的有：</p>
<ul>
<li>Bourne Shell ( <code>/usr/bin/sh</code> 或 <code>/bin/sh</code> )</li>
<li>Bourne Again Shell ( <code>/bin/bash</code> )</li>
<li>C Shell ( <code>/usr/bin/csh</code> )</li>
<li>K Shell ( <code>/usr/bin/ksh</code> )</li>
<li>zsh</li>
<li>…</li>
</ul>
<p>Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。<br>文件开头需要写 <code>#! /bin/bash</code> ，指明bash为脚本解释器。</p>
<h2 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h2><p>不要死记硬背，遇到含糊不清的地方，可以在Terminal里实际运行一遍。</p>
<h2 id="脚本示例"><a href="#脚本示例" class="headerlink" title="脚本示例"></a>脚本示例</h2><p>新建一个 <code>test.sh</code> 文件，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">echo &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>

<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>作为可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 使脚本具有可执行权限</span><br><span class="line">acs@9e0ebfcd82d7:~$ ./test.sh  # 当前路径下执行</span><br><span class="line">Hello World!  # 脚本输出</span><br><span class="line">acs@9e0ebfcd82d7:~$ /home/acs/test.sh  # 绝对路径下执行</span><br><span class="line">Hello World!  # 脚本输出</span><br><span class="line">acs@9e0ebfcd82d7:~$ ~/test.sh  # 家目录路径下执行</span><br><span class="line">Hello World!  # 脚本输出</span><br></pre></td></tr></table></figure>

<p>用解释器执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ bash test.sh</span><br><span class="line">Hello World!  # 脚本输出</span><br></pre></td></tr></table></figure>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>每行中 <code>#</code> 之后的内容均是注释，和python一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一行注释</span></span><br><span class="line">echo &#x27;Hello World&#x27;  #  这也是注释</span><br></pre></td></tr></table></figure>

<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">第三行注释</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>其中 <code>EOF</code> 可以换成其它任意字符串。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;abc</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">第三行注释</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">第三行注释</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量，不需要加 <code>$</code> 符号，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name1=&#x27;yxc&#x27;  # 单引号定义字符串</span><br><span class="line">name2=&quot;yxc&quot;  # 双引号定义字符串</span><br><span class="line">name3=yxc    # 也可以不加引号，同样表示字符串</span><br></pre></td></tr></table></figure>

<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用变量，需要加上 <code>$</code> 符号，或者 <code>$&#123;&#125;</code> 符号。大括号是可选的，主要为了帮助解释器识别变量边界。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=yxc</span><br><span class="line">echo $name  # 输出yxc</span><br><span class="line">echo $&#123;name&#125;  # 输出yxc</span><br><span class="line">echo $&#123;name&#125;acwing  # 输出yxcacwing</span><br></pre></td></tr></table></figure>

<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 <code>readonly</code> 或者 <code>declare</code> 可以将变量变为只读。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=yxc</span><br><span class="line">readonly name</span><br><span class="line">declare -r name  # 两种写法均可</span><br><span class="line"></span><br><span class="line">name=abc  # 会报错，因为此时name只读</span><br></pre></td></tr></table></figure>

<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p><code>unset</code> 可以删除变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=yxc</span><br><span class="line">unset name</span><br><span class="line">echo $name  # 输出空行</span><br></pre></td></tr></table></figure>

<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ol>
<li>自定义变量（局部变量），子进程不能访问的变量</li>
<li>环境变量（全局变量），子进程可以访问的变量</li>
</ol>
<p>自定义变量改成环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ name=yxc  # 定义变量</span><br><span class="line">acs@9e0ebfcd82d7:~$ export name  # 第一种方法</span><br><span class="line">acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法</span><br></pre></td></tr></table></figure>

<p>环境变量改为自定义变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量</span><br><span class="line">acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<p>单引号与双引号的区别：</p>
<ul>
<li>单引号中的内容会原样输出，不会执行、不会取变量</li>
<li>双引号中的内容可以执行、可以取变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=yxc  # 不用引号</span><br><span class="line">echo &#x27;hello, $name \&quot;hh\&quot;&#x27;  # 单引号字符串，输出 hello, $name \&quot;hh\&quot;</span><br><span class="line">echo &quot;hello, $name \&quot;hh\&quot;&quot;  # 双引号字符串，输出 hello, yxc &quot;hh&quot;</span><br></pre></td></tr></table></figure>

<p>获取字符串长度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$&#123;#&#125;</span>一般都是取长度，可以取字符串的长度，也可以取数组的长度</span></span><br><span class="line">name=&quot;yxc&quot;</span><br><span class="line">echo $&#123;#name&#125;  # 输出3</span><br></pre></td></tr></table></figure>

<p>提取子串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=&quot;hello, yxc&quot;</span><br><span class="line">echo $&#123;name:0:5&#125;  # 提取从0开始的5个字符</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>shell中定义的变量默认均为字符串，当变量需要为整数时，会自动将变量转换成整数</p>
</li>
<li><p>定义变量时，等号两边一定不能有空格，不然会报错</p>
</li>
<li><p>使用变量时建议使用 <code>$&#123;&#125;</code> 的形式，这样有助于解释器识别变量边界</p>
</li>
<li><p>句尾不需要加分号</p>
</li>
<li><p>在Terminal中输入“ <code>type + 命令</code> ”可以解释该命令的来源（内嵌命令、第三方命令等）</p>
</li>
<li><p>一个变量如果不存在，他的值为空字符串</p>
</li>
<li><p>被声明为只读（ <code>readonly</code> ）的变量无法被 <code>unset</code> 删除</p>
</li>
<li><p>在Terminal中输入 <code>bash</code> ，可以开启一个新bash，<code>exit</code> 或 <code>Ctrl+d</code> 可以退出新bash</p>
</li>
<li><p>字符串中，不加引号和加双引号效果相同</p>
</li>
</ol>
<h1 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h1><h2 id="文件参数变量"><a href="#文件参数变量" class="headerlink" title="文件参数变量"></a>文件参数变量</h2><p>在执行shell脚本时，可以向脚本传递参数。<code>$1</code> 是第一个参数，<code>$2</code> 是第二个参数，以此类推。特殊的，<code>$0</code> 是文件名（包含路径）。例如：</p>
<p>创建文件 <code>test.sh</code> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;文件名：&quot;$0</span><br><span class="line">echo &quot;第一个参数：&quot;$1</span><br><span class="line">echo &quot;第二个参数：&quot;$2</span><br><span class="line">echo &quot;第三个参数：&quot;$3</span><br><span class="line">echo &quot;第四个参数：&quot;$4</span><br></pre></td></tr></table></figure>

<p>然后执行该脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ chmod +x test.sh </span><br><span class="line">acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4</span><br><span class="line">文件名：./test.sh</span><br><span class="line">第一个参数：1</span><br><span class="line">第二个参数：2</span><br><span class="line">第三个参数：3</span><br><span class="line">第四个参数：4</span><br></pre></td></tr></table></figure>

<h2 id="其它参数相关变量"><a href="#其它参数相关变量" class="headerlink" title="其它参数相关变量"></a>其它参数相关变量</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$#</code></td>
<td>代表文件传入的参数个数，如上例中值为4</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>由所有参数构成的用空格隔开的字符串，如上例中值为 <code>&quot;$1 $2 $3 $4&quot;</code></td>
</tr>
<tr>
<td><code>$@</code></td>
<td>每个参数分别用双引号括起来的字符串，如上例中值为 <code>&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;$4&quot;</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>脚本当前运行的进程ID</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误</td>
</tr>
<tr>
<td><code>$(command)</code></td>
<td>返回 <code>command</code> 这条命令的stdout（可嵌套）</td>
</tr>
<tr>
<td>`command`</td>
<td>返回 <code>command</code> 这条命令的stdout（不可嵌套）</td>
</tr>
</tbody></table>
<h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>当向脚本传递的参数个数超过一位数时，数字需要用大括号括起来，如：<code>echo $&#123;10&#125;</code></p>
</li>
<li><p><code>$*</code> 和 <code>$@</code> 在大多数情况下的输出可能都一样</p>
</li>
<li><p>什么叫“退出状态”？举个例子，<code>C++</code> 代码中 <code>main</code> 函数中最后 <code>return</code> 的值就是退出状态（是 <code>exit code</code> ，而不是标准输出 <code>stdout</code> ）。一个进程 <code>return 0</code> 表示正常结束</p>
</li>
<li><p><code>$?</code> 和 <code>$(command)</code> 以及 `command` 的区别一定要搞清楚</p>
</li>
</ol>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。<br>数组下标从0开始。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组用小括号表示，元素之间用空格隔开。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array=(1 abc &quot;def&quot; yxc)</span><br></pre></td></tr></table></figure>

<p>也可以直接定义数组中某个元素的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array[0]=1</span><br><span class="line">array[1]=abc</span><br><span class="line">array[2]=&quot;def&quot;</span><br><span class="line">array[3]=yxc</span><br></pre></td></tr></table></figure>

<h2 id="读取数组中某个元素的值"><a href="#读取数组中某个元素的值" class="headerlink" title="读取数组中某个元素的值"></a>读取数组中某个元素的值</h2><p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array[index]&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array=(1 abc &quot;def&quot; yxc)</span><br><span class="line">echo $&#123;array[0]&#125;</span><br><span class="line">echo $&#123;array[1]&#125;</span><br><span class="line">echo $&#123;array[2]&#125;</span><br><span class="line">echo $&#123;array[3]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取整个数组"><a href="#读取整个数组" class="headerlink" title="读取整个数组"></a>读取整个数组</h2><p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array[@]&#125;  <span class="comment"># 第一种写法</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array[*]&#125;  <span class="comment"># 第二种写法</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array=(1 abc &quot;def&quot; yxc)</span><br><span class="line"></span><br><span class="line">echo $&#123;array[@]&#125;  # 第一种写法</span><br><span class="line">echo $&#123;array[*]&#125;  # 第二种写法</span><br></pre></td></tr></table></figure>

<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>类似于字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#array[@]&#125;  # 第一种写法</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#array[*]&#125;  # 第二种写法</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array=(1 abc &quot;def&quot; yxc)</span><br><span class="line"></span><br><span class="line">echo $&#123;#array[@]&#125;  # 第一种写法</span><br><span class="line">echo $&#123;#array[*]&#125;  # 第二种写法</span><br></pre></td></tr></table></figure>

<h2 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>shell中的数组支持跳跃赋值，如赋值（启用）下标0，下标2，下标4，那么此时数组的长度为3，其他下标是没有对应赋值的（不启用）</p>
</li>
<li><p><code>*</code> 和 <code>@</code> 的作用是等价的</p>
</li>
</ol>
<h1 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h1><p>expr命令用于求表达式的值，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr 表达式</span><br></pre></td></tr></table></figure>

<p>表达式说明：</p>
<ul>
<li>用空格隔开每一项</li>
<li>用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）</li>
<li>对包含空格和其他特殊字符的字符串要用引号括起来</li>
<li><code>expr</code> 会在 <code>stdout</code> 中输出结果。如果为逻辑关系表达式，则结果为真，<code>stdout</code> 为1，否则为0。</li>
<li><code>expr</code> 的 <code>exit code</code> ：如果为逻辑关系表达式，则结果为真，<code>exit code</code> 为0，否则为1。</li>
</ul>
<h2 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h2><ul>
<li><p><code>length STRING</code></p>
<p>返回 <code>STRING</code> 的长度</p>
</li>
<li><p><code>index STRING CHARSET</code></p>
<p><code>CHARSET</code> 中任意单个字符在 <code>STRING</code> 中最前面的字符位置，下标从1开始。如果在 <code>STRING</code> 中完全不存在 <code>CHARSET</code> 中的字符，则返回0</p>
</li>
<li><p><code>substr STRING POSITION LENGTH</code></p>
<p>返回 <code>STRING</code> 字符串中从 <code>POSITION</code> 开始，长度最大为 <code>LENGTH</code> 的子串。如果 <code>POSITION</code> 或 <code>LENGTH</code> 为负数，0或非数值，则返回空字符串</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str=&quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">echo `expr length &quot;$str&quot;`  # ``不是单引号，表示执行该命令，输出12</span><br><span class="line">echo `expr index &quot;$str&quot; aWd`  # 输出7，下标从1开始</span><br><span class="line">echo `expr substr &quot;$str&quot; 2 3`  # 输出 ell</span><br></pre></td></tr></table></figure>

<h2 id="整数表达式"><a href="#整数表达式" class="headerlink" title="整数表达式"></a>整数表达式</h2><p><code>expr</code> 支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。</p>
<ul>
<li><p><code>+ -</code></p>
<p>加减运算。两端参数会转换为整数，如果转换失败则报错。</p>
</li>
<li><p><code>* / %</code></p>
<p>乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。</p>
</li>
<li><p><code>()</code></p>
<p>可以改变优先级，但需要用反斜杠转义</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line"></span><br><span class="line">echo `expr $a + $b`  # 输出7</span><br><span class="line">echo `expr $a - $b`  # 输出-1</span><br><span class="line">echo `expr $a \* $b`  # 输出12，*需要转义</span><br><span class="line">echo `expr $a / $b`  # 输出0，整除</span><br><span class="line">echo `expr $a % $b` # 输出3</span><br><span class="line">echo `expr \( $a + 1 \) \* \( $b + 1 \)`  # 输出20，值为(a + 1) * (b + 1)</span><br></pre></td></tr></table></figure>

<h2 id="逻辑关系表达式"><a href="#逻辑关系表达式" class="headerlink" title="逻辑关系表达式"></a>逻辑关系表达式</h2><ul>
<li><p><code>|</code></p>
<p>如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。</p>
</li>
<li><p><code>&amp;</code></p>
<p>如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。</p>
</li>
<li><p><code>&lt; &lt;= = == != &gt;= &gt;</code></p>
<p>比较两端的参数，如果为true，则返回1，否则返回0。”&#x3D;&#x3D;”是”&#x3D;”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。</p>
</li>
<li><p><code>()</code></p>
<p>可以改变优先级，但需要用反斜杠转义。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line"></span><br><span class="line">echo `expr $a \&gt; $b`  # 输出0，&gt;需要转义</span><br><span class="line">echo `expr $a &#x27;&lt;&#x27; $b`  # 输出1，也可以将特殊字符用引号引起来</span><br><span class="line">echo `expr $a &#x27;&gt;=&#x27; $b`  # 输出0</span><br><span class="line">echo `expr $a \&lt;\= $b`  # 输出1</span><br><span class="line"></span><br><span class="line">c=0</span><br><span class="line">d=5</span><br><span class="line"></span><br><span class="line">echo `expr $c \&amp; $d`  # 输出0</span><br><span class="line">echo `expr $a \&amp; $b`  # 输出3</span><br><span class="line">echo `expr $c \| $d`  # 输出5</span><br><span class="line">echo `expr $a \| $b`  # 输出3</span><br></pre></td></tr></table></figure>

<h2 id="补充-3"><a href="#补充-3" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>expr其实是一个第三方实现的命令（不是bash中的命令）</p>
</li>
<li><p>bash中是不能直接做运算的，expr命令就是来帮助我们在bash中实现运算的</p>
</li>
<li><p>expr是在stdout中输出结果，所以需要搭配 <code>$()</code> 或 &#96;&#96; 一起使用</p>
</li>
<li><p>在调用一个字符串变量的值时最好加上双引号</p>
</li>
<li><p><code>*</code>（乘号）和 <code>()</code> （小括号）等特殊字符需要在前面加上反斜杠来进行转义</p>
</li>
<li><p>逻辑关系表达式具有<strong>“短路原则”</strong></p>
</li>
<li><p>在expr中，<code>=</code>（等号）和 <code>==</code>（双等号）是等价的</p>
</li>
<li><p>expr命令只支持整数和字符串，不支持浮点数</p>
</li>
<li><p><code>|</code> 和 <code>&amp;</code> 是expr中自己定义的</p>
</li>
</ol>
<h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><p><code>read</code> 命令用于从标准输入中读取单行数据。当读到文件结束符时，<code>exit code</code> 为1，否则为0。</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p><code>-p</code> : 后面可以接提示信息<br><code>-t</code> ：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令</p>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ read name  # 读入name的值</span><br><span class="line">acwing yxc  # 标准输入</span><br><span class="line">acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值</span><br><span class="line">acwing yxc  #标准输出</span><br><span class="line">acs@9e0ebfcd82d7:~$ read -p &quot;Please input your name: &quot; -t 30 name  # 读入name的值，等待时间30秒</span><br><span class="line">Please input your name: acwing yxc  # 标准输入</span><br><span class="line">acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值</span><br><span class="line">acwing yxc  # 标准输出</span><br></pre></td></tr></table></figure>

<h2 id="补充-4"><a href="#补充-4" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>类似于 <code>C++</code> 里的 <code>cin</code></p>
</li>
<li><p>文件结束符是 <code>Ctrl+D</code></p>
</li>
</ol>
<h1 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h1><p><code>echo</code> 用于输出字符串。命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo STRING</span><br></pre></td></tr></table></figure>

<h2 id="显示普通字符串"><a href="#显示普通字符串" class="headerlink" title="显示普通字符串"></a>显示普通字符串</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello AC Terminal&quot;</span><br><span class="line">echo Hello AC Terminal  # 引号可以省略</span><br></pre></td></tr></table></figure>

<h2 id="显示转义字符"><a href="#显示转义字符" class="headerlink" title="显示转义字符"></a>显示转义字符</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;\&quot;Hello AC Terminal\&quot;&quot;  # 注意只能使用双引号，如果使用单引号，则不转义</span><br><span class="line">echo \&quot;Hello AC Terminal\&quot;  # 也可以省略双引号</span><br></pre></td></tr></table></figure>

<h2 id="显示变量"><a href="#显示变量" class="headerlink" title="显示变量"></a>显示变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=yxc</span><br><span class="line">echo &quot;My name is $name&quot;  # 输出 My name is yxc</span><br></pre></td></tr></table></figure>

<h2 id="显示换行"><a href="#显示换行" class="headerlink" title="显示换行"></a>显示换行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;Hi\n&quot;  # -e 开启转义</span><br><span class="line">echo &quot;acwing&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi</span><br><span class="line"></span><br><span class="line">acwing</span><br></pre></td></tr></table></figure>

<h2 id="显示不换行"><a href="#显示不换行" class="headerlink" title="显示不换行"></a>显示不换行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;Hi \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;acwing&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi acwing</span><br></pre></td></tr></table></figure>

<h2 id="显示结果定向至文件"><a href="#显示结果定向至文件" class="headerlink" title="显示结果定向至文件"></a>显示结果定向至文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello World&quot; &gt; output.txt  # 将内容以覆盖的方式输出到output.txt中</span><br></pre></td></tr></table></figure>

<h2 id="原样输出字符串，不进行转义或取变量-用单引号"><a href="#原样输出字符串，不进行转义或取变量-用单引号" class="headerlink" title="原样输出字符串，不进行转义或取变量(用单引号)"></a>原样输出字符串，不进行转义或取变量(用单引号)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=acwing</span><br><span class="line">echo &#x27;$name\&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">name\&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="显示命令的执行结果"><a href="#显示命令的执行结果" class="headerlink" title="显示命令的执行结果"></a>显示命令的执行结果</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Wed Sep 1 11:45:33 CST 2021</span><br></pre></td></tr></table></figure>

<h2 id="补充-5"><a href="#补充-5" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p><code>help echo</code> 查看echo命令的详细用法</p>
</li>
<li><p><code>echo</code> 默认执行后换行，默认输出到终端</p>
</li>
<li><p>用单引号括起来即原样输出</p>
</li>
</ol>
<h1 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h1><p><code>printf</code> 命令用于格式化输出，类似于 <code>C/C++</code> 中的printf函数。</p>
<p>默认不会在字符串末尾添加换行符。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf format-string [arguments...]</span><br></pre></td></tr></table></figure>

<h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><p>脚本内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &quot;%10d.\n&quot; 123  # 占10位，右对齐</span><br><span class="line">printf &quot;%-10.2f.\n&quot; 123.123321  # 占10位，保留2位小数，左对齐</span><br><span class="line">printf &quot;My name is %s\n&quot; &quot;yxc&quot;  # 格式化输出字符串</span><br><span class="line">printf &quot;%d * %d = %d\n&quot;  2 3 `expr 2 \* 3` # 表达式的值作为参数</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">       123.</span><br><span class="line">123.12    .</span><br><span class="line">My name is yxc</span><br><span class="line">2 * 3 = 6</span><br></pre></td></tr></table></figure>

<h2 id="补充-6"><a href="#补充-6" class="headerlink" title="补充"></a>补充</h2><ol>
<li>保留小数是四舍五入（不严格，如9.825保留2位小数还是9.82，但9.8251保留2位小数就是9.83了）</li>
</ol>
<h1 id="test命令与判断符号"><a href="#test命令与判断符号" class="headerlink" title="test命令与判断符号[]"></a>test命令与判断符号[]</h1><h2 id="逻辑运算符-amp-amp-和"><a href="#逻辑运算符-amp-amp-和" class="headerlink" title="逻辑运算符&amp;&amp;和||"></a>逻辑运算符&amp;&amp;和||</h2><p><code>&amp;&amp;</code> 表示与，<code>||</code> 表示或<br>二者具有短路原则：<br><code>expr1 &amp;&amp; expr2</code>：当 <code>expr1</code> 为假时，直接忽略 <code>expr2</code><br><code>expr1 || expr2</code>：当 <code>expr1</code> 为真时，直接忽略 <code>expr2</code><br>表达式的 <code>exit code</code> 为0，表示真；为非零，表示假。（与 <code>C/C++</code> 中的定义相反）</p>
<h2 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h2><p>在命令行中输入 <code>man test</code> ，可以查看 <code>test</code> 命令的用法。</p>
<p><code>test</code> 命令用于判断文件类型，以及对变量做比较。</p>
<p><code>test</code> 命令用 <code>exit code</code> 返回结果，而不是使用 <code>stdout</code> 。0表示真，非0表示假。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test 2 -lt 3  # 为真，返回值为0</span><br><span class="line">echo $?  # 输出上个命令的返回值，输出0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件</span><br><span class="line">homework  output.txt  test.sh  tmp</span><br><span class="line">acs@9e0ebfcd82d7:~$ test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</span><br><span class="line">exist  # test.sh 文件存在</span><br><span class="line">acs@9e0ebfcd82d7:~$ test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</span><br><span class="line">Not exist  # testh2.sh 文件不存在</span><br></pre></td></tr></table></figure>

<h2 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test -e filename  # 判断文件是否存在</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>是否为文件</td>
</tr>
<tr>
<td>-d</td>
<td>是否为目录</td>
</tr>
</tbody></table>
<h2 id="文件权限判断"><a href="#文件权限判断" class="headerlink" title="文件权限判断"></a>文件权限判断</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test -r filename  # 判断文件是否可读</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>文件是否可读</td>
</tr>
<tr>
<td>-w</td>
<td>文件是否可写</td>
</tr>
<tr>
<td>-x</td>
<td>文件是否可执行</td>
</tr>
<tr>
<td>-s</td>
<td>是否为非空文件</td>
</tr>
</tbody></table>
<h2 id="整数间的比较"><a href="#整数间的比较" class="headerlink" title="整数间的比较"></a>整数间的比较</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test $a -eq $b  # a是否等于b</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>a是否等于b</td>
</tr>
<tr>
<td>-ne</td>
<td>a是否不等于b</td>
</tr>
<tr>
<td>-gt</td>
<td>a是否大于b</td>
</tr>
<tr>
<td>-lt</td>
<td>a是否小于b</td>
</tr>
<tr>
<td>-ge</td>
<td>a是否大于等于b</td>
</tr>
<tr>
<td>-le</td>
<td>a是否小于等于b</td>
</tr>
</tbody></table>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>test -z STRING</td>
<td>判断STRING是否为空，如果为空，则返回true</td>
</tr>
<tr>
<td>test -n STRING</td>
<td>判断STRING是否非空，如果非空，则返回true（-n可以省略）</td>
</tr>
<tr>
<td>test str1 &#x3D;&#x3D; str2</td>
<td>判断str1是否等于str2</td>
</tr>
<tr>
<td>test str1 !&#x3D; str2</td>
<td>判断str1是否不等于str2</td>
</tr>
</tbody></table>
<h2 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test -r filename -a -x filename</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>测试参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>两条件是否同时成立</td>
</tr>
<tr>
<td>-o</td>
<td>两条件是否至少一个成立</td>
</tr>
<tr>
<td>!</td>
<td>取反。如 test ! -x file，当file不可执行时，返回true</td>
</tr>
</tbody></table>
<h2 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号[]"></a>判断符号[]</h2><p><code>[]</code> 与 <code>test</code> 用法几乎一模一样，更常用于 <code>if</code> 语句中。另外 <code>[[]]</code> 是 <code>[]</code> 的加强版，支持的特性更多。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 2 -lt 3 ]  # 为真，返回值为0</span><br><span class="line">echo $?  # 输出上个命令的返回值，输出0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件</span><br><span class="line">homework  output.txt  test.sh  tmp</span><br><span class="line">acs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</span><br><span class="line">exist  # test.sh 文件存在</span><br><span class="line">acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</span><br><span class="line">Not exist  # testh2.sh 文件不存在</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>[]</code> 内的每一项都要用空格隔开</li>
<li>中括号内的变量，最好用双引号括起来</li>
<li>中括号内的常数，最好用单或双引号括起来</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=&quot;acwing yxc&quot;</span><br><span class="line">[ $name == &quot;acwing yxc&quot; ]  # 错误，等价于 [ acwing yxc == &quot;acwing yxc&quot; ]，参数太多</span><br><span class="line">[ &quot;$name&quot; == &quot;acwing yxc&quot; ]  # 正确</span><br></pre></td></tr></table></figure>

<h2 id="补充-7"><a href="#补充-7" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p><code>test</code> 是shell内嵌的一个命令</p>
</li>
<li><p><code>[]</code>（中括号）的功能和test几乎一模一样，<code>[</code> 其实也是shell内嵌的一个命令（很神奇）</p>
</li>
<li><p><code>&amp;&amp;</code> 和 <code>||</code> 是bash自有的，两者的优先级相同</p>
</li>
<li><p>常利用 <code>&amp;&amp;</code> 和 <code>||</code> 的短路原则来实现 <code>if/else</code> 的功能</p>
</li>
<li><p><code>test</code> 命令和 <code>[]</code> 均使用 <code>exit code</code> 返回结果，所以需搭配 <code>echo $?</code> 一起使用</p>
</li>
<li><p><code>test</code> 和 <code>[]</code> 判断真假的条件（0为真，1为假）恰好与 <code>expr</code> 相反</p>
</li>
<li><p>注意区分整数比较和字符串比较所使用的参数</p>
</li>
</ol>
<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="if…then形式"><a href="#if…then形式" class="headerlink" title="if…then形式"></a>if…then形式</h2><p>类似于 <code>C/C++</code> 中的 <code>if-else</code> 语句。</p>
<h2 id="单层if"><a href="#单层if" class="headerlink" title="单层if"></a>单层if</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line"></span><br><span class="line">if [ &quot;$a&quot; -lt &quot;$b&quot; ] &amp;&amp; [ &quot;$a&quot; -gt 2 ]</span><br><span class="line">then</span><br><span class="line">    echo $&#123;a&#125;在范围内</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3在范围内</span><br></pre></td></tr></table></figure>

<h2 id="单层if-else"><a href="#单层if-else" class="headerlink" title="单层if-else"></a>单层if-else</h2><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">else</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line"></span><br><span class="line">if ! [ &quot;$a&quot; -lt &quot;$b&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo $&#123;a&#125;不小于$&#123;b&#125;</span><br><span class="line">else</span><br><span class="line">    echo $&#123;a&#125;小于$&#123;b&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3小于4</span><br></pre></td></tr></table></figure>

<h2 id="多层if-elif-elif-else"><a href="#多层if-elif-elif-else" class="headerlink" title="多层if-elif-elif-else"></a>多层if-elif-elif-else</h2><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">elif condition</span><br><span class="line">then</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">elif condition</span><br><span class="line">then</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">else</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=4</span><br><span class="line"></span><br><span class="line">if [ $a -eq 1 ]</span><br><span class="line">then</span><br><span class="line">    echo $&#123;a&#125;等于1</span><br><span class="line">elif [ $a -eq 2 ]</span><br><span class="line">then</span><br><span class="line">    echo $&#123;a&#125;等于2</span><br><span class="line">elif [ $a -eq 3 ]</span><br><span class="line">then</span><br><span class="line">    echo $&#123;a&#125;等于3</span><br><span class="line">else</span><br><span class="line">    echo 其他</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">其他</span><br></pre></td></tr></table></figure>

<h2 id="case…esac形式"><a href="#case…esac形式" class="headerlink" title="case…esac形式"></a>case…esac形式</h2><p>类似于 <code>C/C++</code> 中的 <code>switch</code> 语句。</p>
<p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名称 in</span><br><span class="line">    值1)</span><br><span class="line">        语句1</span><br><span class="line">        语句2</span><br><span class="line">        ...</span><br><span class="line">        ;;  # 类似于C/C++中的break</span><br><span class="line">    值2)</span><br><span class="line">        语句1</span><br><span class="line">        语句2</span><br><span class="line">        ...</span><br><span class="line">        ;;</span><br><span class="line">    *)  # 类似于C/C++中的default</span><br><span class="line">        语句1</span><br><span class="line">        语句2</span><br><span class="line">        ...</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=4</span><br><span class="line"></span><br><span class="line">case $a in</span><br><span class="line">    1)</span><br><span class="line">        echo $&#123;a&#125;等于1</span><br><span class="line">        ;;  </span><br><span class="line">    2)</span><br><span class="line">        echo $&#123;a&#125;等于2</span><br><span class="line">        ;;  </span><br><span class="line">    3)                                                </span><br><span class="line">        echo $&#123;a&#125;等于3</span><br><span class="line">        ;;  </span><br><span class="line">    *)</span><br><span class="line">        echo 其他</span><br><span class="line">        ;;  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">其他</span><br></pre></td></tr></table></figure>

<h2 id="补充-8"><a href="#补充-8" class="headerlink" title="补充"></a>补充</h2><p>在shell脚本中，使用 <code>-eq</code> 、<code>-ne</code> 、<code>-gt</code> 、<code>-ge</code> 、<code>-lt</code> 、<code>-le</code> 进行整数的比较。英文意思分别为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-eq ：equal（相等）</span><br><span class="line">-ne ：not equal（不等）</span><br><span class="line">-gt ：greater than（大于）</span><br><span class="line">-ge ：greater than or equal（大于或等于）</span><br><span class="line">-lt ：less than（小于）</span><br><span class="line">-le ：less than or equal（小于或等于）</span><br></pre></td></tr></table></figure>

<p>注意：在shell中这些符号只能用于整数的比较，不能用于字符串。</p>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="for…in…do…done"><a href="#for…in…do…done" class="headerlink" title="for…in…do…done"></a>for…in…do…done</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in val1 val2 val3</span><br><span class="line">do</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>示例1，输出a 2 cc，每个元素一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in a 2 cc</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>示例2，输出当前路径下的所有文件名，每个文件名一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for file in `ls`</span><br><span class="line">do</span><br><span class="line">    echo $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>示例3，输出1-10</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 10)</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>示例4，使用{1..10} 或者 {a..z}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in &#123;a..z&#125;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="for-…-…-…-do…done"><a href="#for-…-…-…-do…done" class="headerlink" title="for ((…;…;…)) do…done"></a>for ((…;…;…)) do…done</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((expression; condition; expression))</span><br><span class="line">do</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>示例，输出1-10，每个数占一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((i=1; i&lt;=10; i++))</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="while…do…done循环"><a href="#while…do…done循环" class="headerlink" title="while…do…done循环"></a>while…do…done循环</h2><p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>示例，文件结束符为 <code>Ctrl+D</code> ，输入文件结束符后 <code>read</code> 指令返回false。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while read name</span><br><span class="line">do</span><br><span class="line">    echo $name</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="until…do…done循环"><a href="#until…do…done循环" class="headerlink" title="until…do…done循环"></a>until…do…done循环</h2><p>当条件为真时结束。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>示例，当用户输入 <code>yes</code> 或者 <code>YES</code> 时结束，否则一直等待读入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ &quot;$&#123;word&#125;&quot; == &quot;yes&quot; ] || [ &quot;$&#123;word&#125;&quot; == &quot;YES&quot; ]</span><br><span class="line">do</span><br><span class="line">    read -p &quot;Please input yes/YES to stop this program: &quot; word</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h2><p>跳出当前一层循环，注意与 <code>C/C++</code> 不同的是：<code>break</code> 不能跳出 <code>case</code> 语句。</p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while read name</span><br><span class="line">do</span><br><span class="line">    for ((i=1;i&lt;=10;i++))</span><br><span class="line">    do</span><br><span class="line">        case $i in</span><br><span class="line">            8)</span><br><span class="line">                break</span><br><span class="line">                ;;</span><br><span class="line">            *)</span><br><span class="line">                echo $i</span><br><span class="line">                ;;</span><br><span class="line">        esac</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>该示例每读入非EOF的字符串，会输出一遍1-7。<br>该程序可以输入 <code>Ctrl+D</code> 文件结束符来结束，也可以直接用 <code>Ctrl+C</code> 杀掉该进程。</p>
<h2 id="continue命令"><a href="#continue命令" class="headerlink" title="continue命令"></a>continue命令</h2><p>跳出当前循环。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((i=1;i&lt;=10;i++))</span><br><span class="line">do</span><br><span class="line">    if [ `expr $i % 2` -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>该程序输出1-10中的所有奇数。</p>
<h2 id="死循环的处理方式"><a href="#死循环的处理方式" class="headerlink" title="死循环的处理方式"></a>死循环的处理方式</h2><p>如果Terminal可以打开该程序，则输入 <code>Ctrl+C</code> 即可。</p>
<p>否则可以直接关闭进程：</p>
<ol>
<li>使用 <code>top</code> 命令找到进程的PID</li>
<li>输入 <code>kill -9 PID</code> 即可关掉此进程</li>
</ol>
<h2 id="补充-9"><a href="#补充-9" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>注意，<code>while</code> 和 <code>until</code> 是反着来的，<code>condition</code> 为真时 <code>while</code> 才继续执行，而 <code>condition</code> 为假时 <code>until</code> 才继续执行</p>
</li>
<li><p>与 <code>C/C++</code> 不同的是：shell中的 <code>break</code> 命令在 <code>switch</code> 里执行后就会跳出最近的外层循环；而 <code>C/C++</code> 中的 <code>break</code> 命令只会跳出<code>switch</code> ，之后会继续执行外层循环</p>
</li>
<li><p><code>ps aux</code> 或 <code>top</code> 查看当前打开的所有进程（ <code>Shift+F</code> 按内存排序）</p>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><code>bash</code> 中的函数类似于 <code>C/C++</code> 中的函数，但 <code>return</code> 的返回值与 <code>C/C++</code> 不同，返回的是 <code>exit code</code> ，取值为0-255，0表示正常结束。</p>
<p>如果想获取函数的输出结果，可以通过 <code>echo</code> 输出到 <code>stdout</code> 中，然后通过 <code>$(function_name)</code> 来获取 <code>stdout</code> 中的结果。</p>
<p>函数的 <code>return</code> 值可以通过 <code>$?</code> 来获取。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[function] func_name() &#123;  # function关键字可以省略</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不获取return值和stdout值"><a href="#不获取return值和stdout值" class="headerlink" title="不获取return值和stdout值"></a>不获取return值和stdout值</h2><p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func() &#123;</span><br><span class="line">    name=yxc</span><br><span class="line">    echo &quot;Hello $name&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello yxc</span><br></pre></td></tr></table></figure>

<h2 id="获取return值和stdout值"><a href="#获取return值和stdout值" class="headerlink" title="获取return值和stdout值"></a>获取return值和stdout值</h2><p>不写 <code>return</code> 时，默认 <code>return 0</code> 。</p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func() &#123;</span><br><span class="line">    name=yxc</span><br><span class="line">    echo &quot;Hello $name&quot;</span><br><span class="line"></span><br><span class="line">    return 123</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output=$(func)</span><br><span class="line">ret=$?</span><br><span class="line"></span><br><span class="line">echo &quot;output = $output&quot;</span><br><span class="line">echo &quot;return = $ret&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">output = Hello yxc</span><br><span class="line">return = 123</span><br></pre></td></tr></table></figure>

<h2 id="函数的输入参数"><a href="#函数的输入参数" class="headerlink" title="函数的输入参数"></a>函数的输入参数</h2><p>在函数内，<code>$1</code> 表示第一个输入参数，<code>$2</code> 表示第二个输入参数，依此类推。</p>
<p>注意：函数内的 <code>$0</code> 仍然是文件名，而不是函数名。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func() &#123;  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0</span><br><span class="line">    word=&quot;&quot;</span><br><span class="line">    while [ &quot;$&#123;word&#125;&quot; != &#x27;y&#x27; ] &amp;&amp; [ &quot;$&#123;word&#125;&quot; != &#x27;n&#x27; ]</span><br><span class="line">    do</span><br><span class="line">        read -p &quot;要进入func($1)函数吗？请输入y/n：&quot; word</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    if [ &quot;$word&quot; == &#x27;n&#x27; ]</span><br><span class="line">    then</span><br><span class="line">        echo 0</span><br><span class="line">        return 0</span><br><span class="line">    fi  </span><br><span class="line"></span><br><span class="line">    if [ $1 -le 0 ] </span><br><span class="line">    then</span><br><span class="line">        echo 0</span><br><span class="line">        return 0</span><br><span class="line">    fi  </span><br><span class="line"></span><br><span class="line">    sum=$(func $(expr $1 - 1))</span><br><span class="line">    echo $(expr $sum + $1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $(func 10)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure>

<h2 id="函数内的局部变量"><a href="#函数内的局部变量" class="headerlink" title="函数内的局部变量"></a>函数内的局部变量</h2><p>可以在函数内定义局部变量，作用范围仅在当前函数内。</p>
<p>可以在递归函数中定义局部变量。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local 变量名=变量值</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">func() &#123;</span><br><span class="line">    local name=yxc</span><br><span class="line">    echo $name</span><br><span class="line">&#125;</span><br><span class="line">func</span><br><span class="line"></span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yxc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行为函数内的 <code>name</code> 变量，第二行为函数外调用 <code>name</code> 变量，会发现此时该变量不存在。</p>
<h2 id="补充-10"><a href="#补充-10" class="headerlink" title="补充"></a>补充</h2><ol>
<li>shell中调用函数直接使用函数名即可，不需要加小括号，类似于命令的调用方式；而 <code>C/C++</code> 中调用函数是需要加小括号的</li>
</ol>
<h1 id="exit命令"><a href="#exit命令" class="headerlink" title="exit命令"></a>exit命令</h1><p><code>exit</code> 命令用来退出当前shell进程，并返回一个退出状态；使用 <code>$?</code> 可以接收这个退出状态。</p>
<p><code>exit</code> 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。</p>
<p><code>exit</code> 退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。</p>
<p>示例：</p>
<p>创建脚本 <code>test.sh</code> ，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $# -ne 1 ]  # 如果传入参数个数等于1，则正常退出；否则非正常退出。</span><br><span class="line">then</span><br><span class="line">    echo &quot;arguments not valid&quot;</span><br><span class="line">    exit 1</span><br><span class="line">else</span><br><span class="line">    echo &quot;arguments valid&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>执行该脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ chmod +x test.sh </span><br><span class="line">acs@9e0ebfcd82d7:~$ ./test.sh acwing</span><br><span class="line">arguments valid</span><br><span class="line">acs@9e0ebfcd82d7:~$ echo $?  # 传入一个参数，则正常退出，exit code为0</span><br><span class="line">0</span><br><span class="line">acs@9e0ebfcd82d7:~$ ./test.sh </span><br><span class="line">arguments not valid</span><br><span class="line">acs@9e0ebfcd82d7:~$ echo $?  # 传入参数个数不是1，则非正常退出，exit code为1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="补充-11"><a href="#补充-11" class="headerlink" title="补充"></a>补充</h2><ol>
<li><code>return</code> 和 <code>exit</code> 的共同之处是都会返回 <code>exit code</code> ，区别是 <code>return</code> 是结束当前函数，<code>exit</code> 是结束整个shell脚本</li>
</ol>
<h1 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h1><p>每个进程默认打开3个文件描述符：</p>
<ul>
<li><code>stdin</code> 标准输入，从命令行读取数据，文件描述符为0</li>
<li><code>stdout</code> 标准输出，向命令行输出数据，文件描述符为1</li>
<li><code>stderr</code> 标准错误输出，向命令行输出数据，文件描述符为2</li>
</ul>
<p>可以用文件重定向将这三个文件重定向到其他文件中。</p>
<h2 id="重定向命令列表"><a href="#重定向命令列表" class="headerlink" title="重定向命令列表"></a>重定向命令列表</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>command &gt; file</code></td>
<td>将 <code>stdout</code> 重定向到 <code>file</code> 中</td>
</tr>
<tr>
<td><code>command &lt; file</code></td>
<td>将 <code>stdin</code> 重定向到 <code>file</code> 中</td>
</tr>
<tr>
<td><code>command &gt;&gt; file</code></td>
<td>将 <code>stdout</code> 以追加方式重定向到 <code>file</code> 中</td>
</tr>
<tr>
<td><code>command n&gt; file</code></td>
<td>将文件描述符 <code>n</code> 重定向到 <code>file</code> 中</td>
</tr>
<tr>
<td><code>command n&gt;&gt; file</code></td>
<td>将文件描述符 <code>n</code> 以追加方式重定向到 <code>file</code> 中</td>
</tr>
</tbody></table>
<h2 id="输入和输出重定向"><a href="#输入和输出重定向" class="headerlink" title="输入和输出重定向"></a>输入和输出重定向</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;Hello \c&quot; &gt; output.txt  # 将stdout重定向到output.txt中</span><br><span class="line">echo &quot;World&quot; &gt;&gt; output.txt  # 将字符串追加到output.txt中</span><br><span class="line"></span><br><span class="line">read str &lt; output.txt  # 从output.txt中读取字符串</span><br><span class="line"></span><br><span class="line">echo $str  # 输出结果：Hello World</span><br></pre></td></tr></table></figure>

<h2 id="同时重定向stdin和stdout"><a href="#同时重定向stdin和stdout" class="headerlink" title="同时重定向stdin和stdout"></a>同时重定向stdin和stdout</h2><p>创建 <code>bash</code> 脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">read a</span><br><span class="line">read b</span><br><span class="line"></span><br><span class="line">echo $(expr &quot;$a&quot; + &quot;$b&quot;)</span><br></pre></td></tr></table></figure>

<p>创建 <code>input.txt</code> ，里面的内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限</span><br><span class="line">acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中</span><br><span class="line">acs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h2 id="补充-12"><a href="#补充-12" class="headerlink" title="补充"></a>补充</h2><ol>
<li><code>&gt;</code>（一个大于号）是直接覆盖重定向文件的内容；<code>&gt;&gt;</code>（两个大于号）是在重定向文件中追加内容</li>
</ol>
<h1 id="引入外部脚本"><a href="#引入外部脚本" class="headerlink" title="引入外部脚本"></a>引入外部脚本</h1><p>类似于 <code>C/C++</code> 中的 <code>include</code> 操作，<code>bash</code> 也可以引入其他文件中的代码。</p>
<p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. filename  # 注意点和文件名之间有一个空格</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">source filename</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建 <code>test1.sh</code> ，内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">name=yxc  # 定义变量name</span><br></pre></td></tr></table></figure>

<p>然后创建 <code>test2.sh</code> ，内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">source test1.sh # 或 . test1.sh</span><br><span class="line"></span><br><span class="line">echo My name is: $name  # 可以使用test1.sh中的变量</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acs@9e0ebfcd82d7:~$ chmod +x test2.sh </span><br><span class="line">acs@9e0ebfcd82d7:~$ ./test2.sh </span><br><span class="line">My name is: yxc</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Shell语言比较适合用于处理文件、自动化运维等</p>
<p><code>ag</code> 命令——全文查找，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ag the</span><br></pre></td></tr></table></figure>

<p><code>tree</code> 命令——树状显示文件目录，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree homework/</span><br></pre></td></tr></table></figure>

<p>用 <code>printf</code> 加注释法是调试最快的，不推荐使用 <code>gdb</code></p>
<h2 id="小技巧：如何将服务器中的文件整体复制出来？"><a href="#小技巧：如何将服务器中的文件整体复制出来？" class="headerlink" title="小技巧：如何将服务器中的文件整体复制出来？"></a>小技巧：如何将服务器中的文件整体复制出来？</h2><ol>
<li>退出 <code>tmux</code></li>
<li><code>cat filename</code>：展示 <code>filename</code> 的文件内容</li>
<li>鼠标选中文本开头的若干字符</li>
<li>用滚轮滑到文件结尾</li>
<li>按住 <code>Shift</code> ，同时鼠标点击文件结尾，此时会选中文件所有内容</li>
<li>Windows&#x2F;Linux下，按 <code>Ctrl + insert</code> 可以复制全文；Mac下，按 <code>Command + C</code> 可以复制全文</li>
</ol>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_3/，然后：</span><br><span class="line">(0) 进入homework_0文件夹，编写自动完成lesson_1作业的脚本helper.sh。要求：</span><br><span class="line">    [1] 当前目录下仅包含helper.sh</span><br><span class="line">    [2] helper.sh具有可执行权限</span><br><span class="line">    [3] 在任意路径依次执行下列命令后，lesson_1的作业可以得到满分：</span><br><span class="line">        1) homework 1 create</span><br><span class="line">        2) /home/acs/homework/lesson_3/homework_0/helper.sh</span><br><span class="line">(1) 进入homework_1文件夹，编写脚本check_file.sh。要求：</span><br><span class="line">    [1] 当前目录下仅包含check_file.sh。</span><br><span class="line">    [2] check_file.sh具有可执行权限。</span><br><span class="line">    [3] check_file.sh接收一个传入参数。格式为 ./check_file.sh file</span><br><span class="line">    [4] 判断传递参数，分别在标准输出中输出如下内容（不包括双引号）：</span><br><span class="line">        1) 如果传入参数个数不是1，则输出一行：&quot;arguments not valid&quot;，然后退出，退出状态等于1。</span><br><span class="line">        2) 如果file文件不存在，则输出一行：&quot;not exist&quot;，然后退出，退出状态等于2。</span><br><span class="line">        3) 如果file文件存在，则输出分别进行如下5个判断，然后退出，退出状态等于0。</span><br><span class="line">            1] 如果file为普通文件，则输出一行：&quot;regular file&quot;</span><br><span class="line">            2] 如果file为目录（文件夹），则输出一行：&quot;directory&quot;</span><br><span class="line">            3] 如果file具有可读权限，则输出一行：&quot;readable&quot;</span><br><span class="line">            4] 如果file具有可写权限，则输出一行：&quot;writable&quot;</span><br><span class="line">            5] 如果file具有可执行权限，则输出一行：&quot;executable&quot;</span><br><span class="line">(2) 进入homework_2文件夹，编写脚本main.sh。要求：</span><br><span class="line">    [1] 当前目录下仅包含main.sh</span><br><span class="line">    [2] main.sh具有可执行权限</span><br><span class="line">    [3] 该文件从stdin(标准输入)中读取一个整数n</span><br><span class="line">    [4] 在stdout(标准输出)输出斐波那契数列的第n项。即：a[0] = 1, a[1] = 1, a[i] = a[i - 1] + a[i - 2], 求a[n]。</span><br><span class="line">    [5] 数据保证 0 &lt;= n &lt;= 20，脚本不需要判断n的合法性。</span><br><span class="line">(3) 进入homework_3文件夹，编写脚本main.sh。要求：</span><br><span class="line">    [1] 当前目录下仅包含main.sh</span><br><span class="line">    [2] main.sh具有可执行权限</span><br><span class="line">    [3] 该文件从stdin(标准输入)中读取两行整数n和m</span><br><span class="line">    [4] 在stdout(标准输出)中输出1~n的按字典序从小到大的顺序数第m个全排列，输出一行，用空格隔开所有数，行末可以有多余空格。</span><br><span class="line">    [5] 数据保证 1 &lt;= n &lt;= 10, 1 &lt;= m &lt;= min(100, n!)，脚本不需要判断数据的合法性。</span><br><span class="line">(4) 进入homework_4文件夹，编写脚本main.sh。要求：</span><br><span class="line">    [1] 当前目录下仅包含main.sh</span><br><span class="line">    [2] main.sh具有可执行权限</span><br><span class="line">    [3] main.sh接收两个传入参数。格式为 ./main.sh input_file output_file</span><br><span class="line">    [4] 从input_file中读取一个正整数n，然后将前n个正整数的平方和写入output_file中</span><br><span class="line">    [5] 数据保证 1 &lt;= n &lt;= 100，脚本不需要判断所有数据的合法性。</span><br></pre></td></tr></table></figure>

<p>(0) 进入homework_0文件夹，编写自动完成lesson_1作业的脚本helper.sh。要求：<br>     [1] 当前目录下仅包含helper.sh<br>     [2] helper.sh具有可执行权限<br>     [3] 在任意路径依次执行下列命令后，lesson_1的作业可以得到满分：<br>           1) homework 1 create<br>           2) &#x2F;home&#x2F;acs&#x2F;homework&#x2F;lesson_3&#x2F;homework_0&#x2F;helper.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homeowrk_0  # 进入作业目录</span><br><span class="line">vim helper.sh  # 创建作业脚本</span><br><span class="line">chmod +x helper.sh  # 添加可执行权限</span><br><span class="line"></span><br><span class="line"># helpers.sh</span><br><span class="line"></span><br><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line"># *********  homework_0 **********</span><br><span class="line"></span><br><span class="line">dir0=/home/acs/homework/lesson_1/homework_0</span><br><span class="line"></span><br><span class="line">for i in dir_a dir_b dir_c</span><br><span class="line">do</span><br><span class="line">    mkdir $&#123;dir0&#125;/$i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># *********  homwork_1 **********</span><br><span class="line"></span><br><span class="line">dir1=/home/acs/homework/lesson_1/homework_1</span><br><span class="line"></span><br><span class="line">for i in a.txt b.txt c.txt</span><br><span class="line">do</span><br><span class="line">    cp $&#123;dir1&#125;/$&#123;i&#125; $&#123;dir1&#125;/$&#123;i&#125;.bak</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># *********  homwork_2 **********</span><br><span class="line"></span><br><span class="line">dir2=/home/acs/homework/lesson_1/homework_2</span><br><span class="line"></span><br><span class="line">for i in a b c</span><br><span class="line">do</span><br><span class="line">    mv $&#123;dir2&#125;/$&#123;i&#125;.txt $&#123;dir2&#125;/$&#123;i&#125;_new.txt</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># *********  homwork_3 **********</span><br><span class="line"></span><br><span class="line">dir3=/home/acs/homework/lesson_1/homework_3</span><br><span class="line"></span><br><span class="line">for i in a.txt b.txt c.txt</span><br><span class="line">do</span><br><span class="line">    mv $&#123;dir3&#125;/dir_a/$i $&#123;dir3&#125;/dir_b/</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># *********  homwork_4 **********</span><br><span class="line"></span><br><span class="line">dir4=/home/acs/homework/lesson_1/homework_4</span><br><span class="line"></span><br><span class="line">rm $&#123;dir4&#125;/*</span><br><span class="line"></span><br><span class="line"># *********  homwork_5 **********</span><br><span class="line"></span><br><span class="line">dir5=/home/acs/homework/lesson_1/homework_5</span><br><span class="line"></span><br><span class="line">rm $&#123;dir5&#125;/* -r</span><br><span class="line"></span><br><span class="line"># *********  homwork_6 **********</span><br><span class="line"></span><br><span class="line">dir6=/home/acs/homework/lesson_1/homework_6</span><br><span class="line"></span><br><span class="line">mv $&#123;dir6&#125;/task.txt &quot;$&#123;dir6&#125;/done.txt&quot;</span><br><span class="line">mkdir $&#123;dir6&#125;/dir_a</span><br><span class="line">mv &quot;$&#123;dir6&#125;/done.txt&quot; $&#123;dir6&#125;/dir_a</span><br><span class="line"></span><br><span class="line"># *********  homwork_7 **********</span><br><span class="line"></span><br><span class="line">dir7=/home/acs/homework/lesson_1/homework_7</span><br><span class="line"></span><br><span class="line">for ((i=0;i&lt;3;i++))</span><br><span class="line">do</span><br><span class="line">    mkdir $&#123;dir7&#125;/dir_$i</span><br><span class="line">    for j in a b c</span><br><span class="line">    do</span><br><span class="line">        cp $&#123;dir7&#125;/$&#123;j&#125;.txt $&#123;dir7&#125;/dir_$&#123;i&#125;/$&#123;j&#125;$&#123;i&#125;.txt</span><br><span class="line">    done</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># *********  homwork_8 **********</span><br><span class="line"></span><br><span class="line">dir8=/home/acs/homework/lesson_1/homework_8</span><br><span class="line"></span><br><span class="line">rm $&#123;dir8&#125;/dir_a/a.txt</span><br><span class="line">mv $&#123;dir8&#125;/dir_b/b.txt $&#123;dir8&#125;/dir_b/b_new.txt</span><br><span class="line">cp $&#123;dir8&#125;/dir_c/c.txt $&#123;dir8&#125;/dir_c/c.txt.bak</span><br><span class="line"></span><br><span class="line"># *********  homwork_9 **********</span><br><span class="line"></span><br><span class="line">dir9=/home/acs/homework/lesson_1/homework_9</span><br><span class="line"></span><br><span class="line">rm $&#123;dir9&#125;/*.txt</span><br></pre></td></tr></table></figure>

<p>(1) 进入homework_1文件夹，编写脚本check_file.sh。要求：<br>     [1] 当前目录下仅包含check_file.sh。<br>     [2] check_file.sh具有可执行权限。<br>     [3] check_file.sh接收一个传入参数。格式为 .&#x2F;check_file.sh file<br>     [4] 判断传递参数，分别在标准输出中输出如下内容（不包括双引号）：<br>           1) 如果传入参数个数不是1，则输出一行：”arguments not valid”，然后退出，退出状态等于1。<br>           2) 如果file文件不存在，则输出一行：”not exist”，然后退出，退出状态等于2。<br>           3) 如果file文件存在，则输出分别进行如下5个判断，然后退出，退出状态等于0。<br>               1] 如果file为普通文件，则输出一行：”regular file”<br>               2] 如果file为目录（文件夹），则输出一行：”directory”<br>               3] 如果file具有可读权限，则输出一行：”readable”<br>               4] 如果file具有可写权限，则输出一行：”writable”<br>               5] 如果file具有可执行权限，则输出一行：”executable”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $# -ne 1 ]</span><br><span class="line">then</span><br><span class="line">    echo arguments not valid</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -e &quot;$1&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo not exist</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$1&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo regular file</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$1&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo directory</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -r &quot;$1&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo readable</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -w &quot;$1&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo writable</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -x &quot;$1&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo executable</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>(2) 进入homework_2文件夹，编写脚本main.sh。要求：<br>     [1] 当前目录下仅包含main.sh<br>     [2] main.sh具有可执行权限<br>     [3] 该文件从stdin(标准输入)中读取一个整数n<br>     [4] 在stdout(标准输出)输出斐波那契数列的第n项。即：a[0] &#x3D; 1, a[1] &#x3D; 1, a[i] &#x3D; a[i - 1] + a[i - 2], 求a[n]。<br>     [5] 数据保证 0 &lt;&#x3D; n &lt;&#x3D; 20，脚本不需要判断n的合法性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">read n</span><br><span class="line"></span><br><span class="line">a[0]=1</span><br><span class="line">a[1]=1</span><br><span class="line"></span><br><span class="line">for ((i = 2; i &lt;= n; i ++ ))</span><br><span class="line">do</span><br><span class="line">    x=$(expr $i - 1)</span><br><span class="line">    y=$(expr $i - 2)</span><br><span class="line">    a[$i]=$(expr $&#123;a[$x]&#125; + $&#123;a[$y]&#125;)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $&#123;a[$n]&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 进入homework_3文件夹，编写脚本main.sh。要求：<br>     [1] 当前目录下仅包含main.sh<br>     [2] main.sh具有可执行权限<br>     [3] 该文件从stdin(标准输入)中读取两行整数n和m<br>     [4] 在stdout(标准输出)中输出1~n的按字典序从小到大的顺序数第m个全排列，输出一行，用空格隔开所有数，行末可以有多余空格。<br>     [5] 数据保证 1 &lt;&#x3D; n &lt;&#x3D; 10, 1 &lt;&#x3D; m &lt;&#x3D; min(100, n!)，脚本不需要判断数据的合法性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">read n</span><br><span class="line">read m</span><br><span class="line"></span><br><span class="line">for ((i = 1; i &lt;= n; i ++ ))</span><br><span class="line">do</span><br><span class="line">    st[$i]=0</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">dfs() &#123;</span><br><span class="line">    if [ $1 -eq $n ]</span><br><span class="line">    then</span><br><span class="line">        m=`expr $m - 1`</span><br><span class="line">        if [ $m -eq 0 ] </span><br><span class="line">        then</span><br><span class="line">            echo $&#123;path[@]&#125;</span><br><span class="line">            return 0</span><br><span class="line">        fi</span><br><span class="line">        return 1</span><br><span class="line">    fi  </span><br><span class="line"></span><br><span class="line">    local j=0</span><br><span class="line">    for ((j = 1; j &lt;= n; j ++ ))</span><br><span class="line">    do  </span><br><span class="line">        if [ $&#123;st[$j]&#125; -eq 0 ] </span><br><span class="line">        then</span><br><span class="line">            path[$1]=$j</span><br><span class="line">            st[$j]=1</span><br><span class="line"></span><br><span class="line">            if dfs `expr $1 + 1`</span><br><span class="line">            then</span><br><span class="line">                return 0</span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            st[$j]=0</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs 0</span><br></pre></td></tr></table></figure>

<p>(4) 进入homework_4文件夹，编写脚本main.sh。要求：<br>     [1] 当前目录下仅包含main.sh<br>     [2] main.sh具有可执行权限<br>     [3] main.sh接收两个传入参数。格式为 .&#x2F;main.sh input_file output_file<br>     [4] 从input_file中读取一个正整数n，然后将前n个正整数的平方和写入output_file中<br>     [5] 数据保证 1 &lt;&#x3D; n &lt;&#x3D; 100，脚本不需要判断所有数据的合法性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">input_file=$1</span><br><span class="line">output_file=$2</span><br><span class="line"></span><br><span class="line">read n &lt; $input_file</span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line">for ((i = 1; i &lt;= n; i ++ ))</span><br><span class="line">do</span><br><span class="line">    sqr=`expr $i \* $i`</span><br><span class="line">    sum=`expr $sum + $sqr`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum &gt; $output_file</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-thrift</title>
    <url>/2022/11/23/Linux%E5%9F%BA%E7%A1%80-thrift/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>thrift</strong>的相关内容（AcWing-day18）</p>
<p><strong>当前二刷，两天时间终于完成第一次复现，二刷过程中自觉对thrift熟悉了不少，有空还得坚持三刷四刷</strong></p>
<span id="more"></span>

<h1 id="thrift教程"><a href="#thrift教程" class="headerlink" title="thrift教程"></a>thrift教程</h1><p><strong>Apache Thrift</strong>软件框架用于可伸缩的跨语言服务开发，它将<strong>软件栈</strong>和<strong>代码生成引擎</strong>结合在一起，以构建在C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk、OCaml和Delphi等语言之间高效、无缝地工作的服务</p>
<p><strong>thrift官网：</strong><a href="https://thrift.apache.org/">https://thrift.apache.org/</a> ，对照Tutorial进行学习（tutorial.thrift）</p>
<p><strong>项目地址：</strong><a href="https://git.acwing.com/gulu_sy/thrift_lesson">https://git.acwing.com/gulu_sy/thrift_lesson</a> ，实现简单的游戏匹配服务，并将匹配结果保存</p>
<p>在今后的实际项目中，可以直接以上述实现的代码为模板进行开发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 参考资料（两篇博客都写的非常全非常好）</span><br><span class="line">https://git.acwing.com/fashen/thrift_learning#include-thread</span><br><span class="line">https://git.acwing.com/ycr2022/thrift/-/blob/master/readme.md</span><br></pre></td></tr></table></figure>

<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><p>如果一台服务器上的某个进程（服务&#x2F;函数）想要调用另一台服务器上的某个进程（服务&#x2F;函数），就需要<strong>thrift</strong>来帮忙。不同进程可以用完全不同的编程语言来实现，不同服务器的进程间可以利用<strong>thrift</strong>进行通信</p>
</li>
<li><p><strong>三步创建thrift服务</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义接口来实现对应的请求操作（创建一个thrift文件夹来存储.thrift文件，.thrift文件定义服务接口）</span><br><span class="line">如果作为服务端（提供函数的进程），需要生成server</span><br><span class="line">如果作为请求端（请求服务的进程），需要生成client</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>thrift</strong>也被称为<strong>rpc</strong>框架，<strong>rpc</strong>（远程过程调用）可以理解为<strong>远程函数调用</strong></p>
</li>
<li><p>写<strong>thrift</strong>时，在定义完后先编译跑通，再逐步往里添加模块</p>
</li>
<li><p><code>C++</code> 的编译需要经过两步，每一次 <code>.cpp</code> 文件的修改都需要接上以下两步</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">编译 g++ -c main.cpp &lt;包括所有修改后需要编译的.cpp文件&gt;</span><br><span class="line">链接 g++ *.o -o main</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行 <code>.cpp</code> 文件：<code>./main</code></li>
<li>使用 <code>git</code> 往云端仓库存文件时，最好只存源文件，不要存编译好的文件和可执行文件（如 <code>Python</code> 中的 <code>.pyc</code> 文件和 <code>C++</code> 中的 <code>.o</code> 文件，还有没有后缀的可执行文件），因为这样只会占用网络带宽，且显得仓库很不专业</li>
<li>并行、多线程、生产者-消费者模型、消息队列、锁、信号量、mutex（互斥量）、条件变量</li>
<li>文件命名时尽量不要使用 <code>-</code> ，因为 <code>Python</code> 中 <code>import</code> 的时候 <code>-</code> 会被识别成减号</li>
<li>写工程最好 <code>0 warning</code></li>
<li><code>C++</code> 中，<code>#include &lt; &gt;</code> 引用的是编译器的类库路径里的头文件。<code>#include &quot; &quot; </code> 引用的是程序目录的相对路径中的头文件，如果在程序目录中没有找到引用的头文件则到编译器的类库路径的目录下寻找该头文件</li>
<li>要养成看官方文档的好习惯</li>
<li><strong>thrift</strong>相比<strong>socket</strong>开发使用中会更加便捷</li>
<li>一个应用会有很多服务，这些服务通常会被分配到不同的服务器上，这就是我们常说的<strong>“微服务”框架</strong></li>
<li>服务器端用**C++**实现效率较高</li>
<li>多人开发时，代码中最好不要加 <code>using namespace std;</code></li>
<li>计算<strong>md5值</strong>时，在命令行中输入 <code>md5sum</code> 后要按 <code>Ctrl+D</code> 才会输出结果</li>
<li>今后写项目，<strong>thrift</strong>必不可少，同时也是工程中除业务逻辑外最难的部分了</li>
<li>数据库不需要自己学，框架里都帮你整合好了</li>
<li><strong>thrift</strong>采用<strong>IDL</strong>（Interface Definition Language 接口定义语言）来定义通用的服务接口，通过命令调用<strong>thrift</strong>提供的编译器，可以将服务接口编译成不同语言编写的代码，从而实现跨语言的功能</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thrift -r --gen &lt;language&gt; &lt;thrift filename&gt;</span><br></pre></td></tr></table></figure>

<ol start="21">
<li>在未来的项目中，很可能有人已经将服务接口实现（实现服务端），我们只需实现客户端即可</li>
<li><strong>thrift</strong>中的命名空间类似于 <code>C++</code> 中的 <code>namespace</code> 和 <code>Java</code> 中的 <code>package</code> ，它们提供了一种组织（隔离）代码的简便方式。名字空间也可以用于解决类型定义中的名字冲突。由于每种语言均有自己的命名空间定义方式（如：<code>Python</code> 中有 <code>module</code> ），<strong>thrift</strong>允许开发者针对特定语言定义 <code>namespace</code></li>
<li>服务（Service）的定义方法在语义上等同于面向对象语言中的接口。比如 <code>Java</code> 中的接口，只是参数前需要加上编号</li>
<li>定义接口方法时可以额外定义一个参数（通常用 <code>string info</code> 表示额外信息），以后想要更改接口时，可以直接将想传的信息传入 <code>info</code> 中</li>
<li>推荐在项目文件夹下创建 <code>src</code> 文件夹，<code>src</code> 表示源文件</li>
<li><strong>thrift</strong>只是将接口实现好（输出了函数名字），不实现具体的业务逻辑。先给函数添加 <code>return 返回值;</code> ，使代码能够编译成功。一个好习惯就是，写<strong>thrift</strong>时，先编译跑通，然后再逐步向文件添加模块</li>
<li><code>.o</code> 就是 <code>.cpp</code> 编译好后的文件，有多少个 <code>.cpp</code> 文件就能编译生成多少个 <code>.o</code> 文件</li>
<li>编译时需要用到<strong>thrift</strong>动态链接库，添加参数 <code>-lthrift</code> ，将所有<strong>thrift</strong>预编译好的动态链接文件直接链接进来</li>
<li><code>C++</code> 编译很慢，所以每次修改 <code>.cpp</code> 文件后，重新编译时只需编译修改过的 <code>.cpp</code> 文件，从而防止编译时间过长</li>
<li>写 <code>Python</code> 文件时一个好习惯就是在代码末尾加上以下语句</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<ol start="31">
<li>注意要先运行服务端的代码，再运行客户端，因为服务端若没运行，客户端就无法调用服务端的函数，就会报错</li>
<li>一个好习惯是多用 <code>git</code> 对代码文件进行持久化</li>
<li>编译 <code>C++</code> 时，如果用到了线程，则需要加上线程的动态链接库参数 <code>-pthread</code> ，将所有 <code>thread</code> 预编译好的动态链接文件直接链接进来</li>
<li>复制使用<strong>thrift</strong>教程中的代码时，一些细节需要注意更改，如其中带 <code>Calculator</code> 的字段</li>
<li>一个线程处理输入输出，如果以后要处理并发量，则需要开多个线程处理</li>
<li><code>C++</code> 标准程序库中的所有标识符都被定义于一个名为 <code>std</code> 的 <code>namespace</code> 中。如果在代码中加上 <code>using namespace std;</code> ，在使用 <code>C++</code> 标准程序库的任何标识符时就不用再加前缀。比如，<code>std::cout &lt;&lt; std::endl;</code> 加上 <code>using namespace std;</code> 后，就可以写成 <code>cout &lt;&lt; endl;</code> 。<code>std::ios::sync_with_stdio(false);</code> 加上 <code>using namespace std;</code> 后，就可以写成  <code>ios::sync_with_stdio(false);</code> </li>
<li>端口是一个16位的二进制数，其范围从0~65535。同一个端口只能由一个进程监听，当在一个端口号启动了一个服务，另一个进程将无法访问这个端口号。服务端的端口号和客户端的端口号要相同才能够连接</li>
<li>每执行一个程序就是开一个进程。每一个进程可以开很多线程。开多线程的开销是很小的，开多进程的开销是很大的</li>
<li><code>C++</code> 中有一个 <code>thread</code> 库，可以用来开线程。<strong>生产者-消费者模型</strong>中，生产者、消费者是两个线程。生产者和消费者之间需要一个媒介，这个媒介可以有很多种方法，比如<strong>消息队列</strong>。很多语言都有已实现的消息队列，也可以自己去实现消息队列。实现消息队列，需要用到一些锁（mutex）</li>
<li><code>Python</code> 从终端接收输入：<code>from sys import stdin</code></li>
<li>上传数据到服务器需要输入服务端的用户名和密码，密码可以采用<strong>md5加密</strong></li>
<li>一个程序是一个进程，一个进程中至少有一个线程。如果只有一个线程，则第二个任务必须等到第一个任务结束后才能进行，如果使用多线程则在主线程执行任务的同时可以执行其他任务，而不需要等待。创建线程代价较小，但能有效提升CPU利用率</li>
<li><code>C++</code> 中如果警告说不能用一个 <code>%s</code> 输出一个 <code>string</code> ，我们就可以在变量后加上 <code>.c_str()</code> 来取消警告</li>
<li><strong>http</strong>是80端口，<strong>https</strong>是443端口，<strong>ssh</strong>是22端口，<strong>thrift</strong>一般都是9090端口</li>
<li>一个 <code>C++</code> 项目只能有一个 <code>main</code> 函数</li>
<li>一般情况下只有在用<strong>thrift</strong>做微服务时才会需要手写多线程，大多情况下框架已经帮忙写好</li>
</ol>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">本次作业为复现课上最后一个版本的内容</span><br><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_6/，当前目录的文件结构如下：</span><br><span class="line">`-- thrift_lesson</span><br><span class="line">    |-- game</span><br><span class="line">    |   `-- src</span><br><span class="line">    |-- match_system</span><br><span class="line">    |   `-- src </span><br><span class="line">    |-- readme.md</span><br><span class="line">    `-- thrift</span><br><span class="line">        |-- match.thrift</span><br><span class="line">        `-- save.thrift</span><br><span class="line">(0) 进入thrift_lesson/match_system/src/目录，用cpp实现课上的match-server和save-client逻辑。</span><br><span class="line">接口文件在thrift_lesson/thrift/中。</span><br><span class="line">实现后启动server，监听端口9090。</span><br><span class="line">(1) 进入thrift_lesson/game/src/目录，用python3实现课上的match-client逻辑。</span><br><span class="line">文件名和输入格式与课上内容相同。</span><br></pre></td></tr></table></figure>

<p>(0) 进入thrift_lesson&#x2F;match_system&#x2F;src&#x2F;目录，用cpp实现课上的match-server和save-client逻辑。<br>接口文件在thrift_lesson&#x2F;thrift&#x2F;中。<br>实现后启动server，监听端口9090。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建match-server</span></span><br><span class="line">cd thrift_lesson/match_system/src</span><br><span class="line">thrift -r --gen cpp ../../thrift/match.thrift</span><br><span class="line">mv gen-cpp match_server</span><br><span class="line">rm match_server/Match_server.skeleton.cpp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建save-client</span></span><br><span class="line">cd thrift_lesson/match_system/src</span><br><span class="line">thrift -r --gen cpp ../../thrift/save.thrift</span><br><span class="line">mv gen-cpp save_client</span><br><span class="line">rm save_client/Save_server.skeleton.cpp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建main.cpp</span></span><br><span class="line">源代码在 https://git.acwing.com/yxc/thrift_lesson/-/blob/master/match_system/src/main.cpp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">g++ -c main.cpp match_server/*.cpp save_client/*.cpp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">链接</span></span><br><span class="line">g++ *.o -o main -lthrift -pthread</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<p>(1) 进入thrift_lesson&#x2F;game&#x2F;src&#x2F;目录，用python3实现课上的match-client逻辑。<br>文件名和输入格式与课上内容相同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建match-client</span></span><br><span class="line">cd thrift_lesson/game/src</span><br><span class="line">thrift -r --gen py ../../thrift/match.thrift</span><br><span class="line">mv gen-py match_client</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建client.py</span></span><br><span class="line">内容在 https://git.acwing.com/yxc/thrift_lesson/-/blob/master/game/src/client.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行client.py</span></span><br><span class="line">python3 client.py</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-tmux和vim</title>
    <url>/2022/11/16/Linux%E5%9F%BA%E7%A1%80-tmux%E5%92%8Cvim/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>tmux和vim</strong>的相关内容（AcWing-day14）</p>
<span id="more"></span>

<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>(1) 分屏。（很实用）</p>
<p>(2) 允许断开 Terminal 连接后，继续运行进程。（很实用）</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>一个 tmux 可以包含多个 session（会话），一个 session 可以包含多个 window（窗口），一个 window 可以包含多个 pane（小窗口）。pane 是 tmux 中的最小单位，一个 pane 会开启一个 shell 。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux:</span><br><span class="line">    session 0:</span><br><span class="line">       window 0:</span><br><span class="line">            pane 0</span><br><span class="line">            pane 1</span><br><span class="line">            pane 2</span><br><span class="line">            ...</span><br><span class="line">       window 1</span><br><span class="line">       window 2</span><br><span class="line">       ...</span><br><span class="line">    session 1</span><br><span class="line">    session 2</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</span><br><span class="line">(2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。</span><br><span class="line">(3) 按下Ctrl + a后手指松开，然后按&quot;（双引号）：将当前pane上下平分成两个pane。</span><br><span class="line">(4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</span><br><span class="line">(5) 鼠标点击可以选pane。</span><br><span class="line">(6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。</span><br><span class="line">(7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。</span><br><span class="line">(8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。</span><br><span class="line">(9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。</span><br><span class="line">(10) 按下ctrl + a后手指松开，然后按d：挂起当前session。</span><br><span class="line">(11) tmux a：打开之前挂起的session。</span><br><span class="line">(12) 按下ctrl + a后手指松开，然后按s：选择其它session。</span><br><span class="line">     方向键 —— 上：选择上一项 session/window/pane</span><br><span class="line">     方向键 —— 下：选择下一项 session/window/pane</span><br><span class="line">     方向键 —— 右：展开当前项 session/window</span><br><span class="line">     方向键 —— 左：闭合当前项 session/window</span><br><span class="line">(13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。</span><br><span class="line">(14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。</span><br><span class="line">(15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。</span><br><span class="line">(16) 鼠标滚轮：翻阅当前pane内的内容。</span><br><span class="line">(17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</span><br><span class="line">(18) tmux中复制/粘贴文本的通用方式（仅支持英文）：</span><br><span class="line">    (1) 按下Ctrl + a后松开手指，然后按[</span><br><span class="line">    (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</span><br><span class="line">    (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</span><br><span class="line">(19) tmux中复制/粘贴文本的另一种方式：</span><br><span class="line">    (1) 按住Shift键选中需要复制的文本</span><br><span class="line">    (2) Ctrl + Insert复制；Shift + Insert粘贴</span><br></pre></td></tr></table></figure>

<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p>(1) 命令行模式下的文本编辑器（支持中文）。</p>
<p>(2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</p>
<p>(3) 使用方式：<code>vim filename</code></p>
<p>​      如果已有该文件，则打开它。</p>
<p>​      如果没有该文件，则创建一个新文件，并命名为 filename 。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p><strong>(1) 一般命令模式</strong></p>
<p>默认模式。命令输入方式：类似于打游戏放技能，按不同字符来进行不同操作。可以复制、粘贴、删除文本等。</p>
<p><strong>(2) 编辑模式</strong></p>
<p>在一般命令模式里按下 <code>i</code> ，会进入编辑模式。</p>
<p>按下 <code>ESC</code> 会退出编辑模式，返回到一般命令模式。</p>
<p><strong>(3) 命令行模式</strong></p>
<p>在一般命令模式里按下 <code>:/?</code> 三个字母中的任意一个，会进入命令行模式。命令行在最下面。</p>
<p>可以查找、替换、保存、退出、配置编辑器等。</p>
<h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) i：进入编辑模式</span><br><span class="line">(2) ESC：进入一般命令模式</span><br><span class="line">(3) h 或 左箭头键：光标向左移动一个字符</span><br><span class="line">(4) j 或 向下箭头：光标向下移动一个字符</span><br><span class="line">(5) k 或 向上箭头：光标向上移动一个字符</span><br><span class="line">(6) l 或 向右箭头：光标向右移动一个字符</span><br><span class="line">(7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</span><br><span class="line">(8) 0 或 功能键[Home]：光标移动到本行开头</span><br><span class="line">(9) $ 或 功能键[End]：光标移动到本行末尾</span><br><span class="line">(10) G：光标移动到最后一行</span><br><span class="line">(11) :n 或 nG：n为数字，光标移动到第n行</span><br><span class="line">(12) gg：光标移动到第一行，相当于1G</span><br><span class="line">(13) n&lt;Enter&gt;：n为数字，光标向下移动n行</span><br><span class="line">(14) /word：向光标之下寻找第一个值为word的字符串。</span><br><span class="line">(15) ?word：向光标之上寻找第一个值为word的字符串。</span><br><span class="line">(16) n：重复前一个查找操作</span><br><span class="line">(17) N：反向重复前一个查找操作</span><br><span class="line">(18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</span><br><span class="line">(19) :1,$s/word1/word2/g：将全文的word1替换为word2</span><br><span class="line">(20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。</span><br><span class="line">(21) v：选中文本，按两次ESC退出（是通过命令跳转进行选中，不是通过鼠标）</span><br><span class="line">(22) d：删除选中的文本（实则是剪切，选中的文本会被自动复制到vim的剪贴板，不会复制行号）</span><br><span class="line">(23) dd: 删除当前行（实则是剪切，选中的文本会被自动复制到vim的剪贴板，不会复制行号）</span><br><span class="line">(24) y：复制选中的文本</span><br><span class="line">(25) yy: 复制当前行</span><br><span class="line">(26) p: 将复制的数据在光标的下一行/下一个位置粘贴</span><br><span class="line">(27) u：撤销</span><br><span class="line">(28) Ctrl + r：取消撤销</span><br><span class="line">(29) 大于号 &gt;：将选中的文本整体向右缩进一次</span><br><span class="line">(30) 小于号 &lt;：将选中的文本整体向左缩进一次</span><br><span class="line">(31) :w 保存</span><br><span class="line">(32) :w! 强制保存</span><br><span class="line">(33) :q 退出</span><br><span class="line">(34) :q! 强制退出</span><br><span class="line">(35) :wq 保存并退出</span><br><span class="line">(36) :wq! 强制保存并退出</span><br><span class="line">(37) :set paste 设置成粘贴模式，取消代码自动缩进</span><br><span class="line">(38) :set nopaste 取消粘贴模式，开启代码自动缩进</span><br><span class="line">(39) :set nu 显示行号</span><br><span class="line">(40) :set nonu 隐藏行号</span><br><span class="line">(41) :noh 关闭查找关键词高亮</span><br><span class="line">(42) ggdG：组合键，删除文件全部内容</span><br><span class="line">(43) gg=G：将全文代码格式化</span><br><span class="line">(44) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</span><br><span class="line">(45) delete：删除光标所在位置后面的字符</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>每次用 vim 编辑文件时，会自动创建一个 <code>.filename.swp</code> 的临时文件。</p>
<p>如果打开某个文件时，该文件的 swp 文件已存在，则会报错。此时解决办法有两种：</p>
<p>(1) 找到正在打开该文件的程序，并退出。</p>
<p>(2) 直接删掉该swp文件即可。</p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_2/，然后：</span><br><span class="line">(0) 进入homework_0文件夹，创建文件names.txt，并顺次将下列姓名写入该文件，每个名字占一行。</span><br><span class="line">    AcWing、yxc、Bob、张强、李明、Alice</span><br><span class="line">(1) 进入homework_1文件夹，打开problem.txt，并依次删除下列字符：</span><br><span class="line">    [1] 最后一行第101个字符</span><br><span class="line">    [2] 第3行第8个字符</span><br><span class="line">    [3] 第1行第30个字符</span><br><span class="line">    [4] 第16行第55个字符</span><br><span class="line">    [5] 第9行第80个字符</span><br><span class="line">    最后保存文件并退出。</span><br><span class="line">(2) 进入homework_2文件夹，打开problem.txt，并依次执行如下操作：</span><br><span class="line">    [1] 在第1个&quot;two&quot;的后面添加&quot;abc&quot;</span><br><span class="line">    [2] 在第2个&quot;two&quot;的前面添加&quot;def&quot;</span><br><span class="line">    [3] 将第3个&quot;two&quot;后面的连续12个字符删掉</span><br><span class="line">    [4] 将第4个&quot;two&quot;所在的行删掉</span><br><span class="line">    最后保存文件并退出。</span><br><span class="line">(3) 进入homework_3文件夹，打开problem.txt，并依次执行如下操作：</span><br><span class="line">    [1] 将第5行至第15行中所有of替换成OF。</span><br><span class="line">    [2] 将全文中所有的the替换成THE。</span><br><span class="line">    [3] 将第偶数个is替换成IS，第奇数个is不变。下标从1开始。</span><br><span class="line">(4) 进入homework_4文件夹，打开problem.txt，并依次执行如下操作：</span><br><span class="line">    [1] 删除第11行</span><br><span class="line">    [2] 将所删除的行粘贴到文件最后一行的下一行</span><br><span class="line">    [3] 复制第5行</span><br><span class="line">    [4] 将所复制的行粘贴到文件当前最后一行的下一行</span><br><span class="line">(5) 进入homework_5文件夹，打开problem.txt，并依次执行如下操作：</span><br><span class="line">    [1] 删除第11行第15个字符（包含该字符）至第13行第5个字符（包含该字符）</span><br><span class="line">    [2] 将所删除的内容粘贴到文件末尾（注意不要另起一行）</span><br><span class="line">    [3] 复制第5行第88个字符（包含该字符）至第7行第6个字符（包含该字符）</span><br><span class="line">    [4] 将所复制的内容粘贴到当前文件末尾（注意不要另起一行）</span><br><span class="line">(6) 进入homework_6文件夹，并依次执行如下操作：</span><br><span class="line">    [1] 清空source0.cpp</span><br><span class="line">    [2] 将source1.cpp中的第1-3行和第12-24行复制到source0.cpp中</span><br><span class="line">(7) 进入homework_7文件夹，格式化source.cpp</span><br><span class="line">(8) 进入homework_8文件夹，打开source.cpp，并依次执行如下操作：</span><br><span class="line">    [1] 将第15-21行向右缩进2次。</span><br><span class="line">    [2] 将第22-23行向左缩进1次。</span><br><span class="line">(9) 进入homework_9文件夹，打开链接：https://www.acwing.com/activity/content/code/content/1694465/</span><br><span class="line">    新建文件source.cpp，将链接中的代码抄进source.cpp文件中。</span><br></pre></td></tr></table></figure>

<p>(0) 进入homework_0文件夹，创建文件names.txt，并顺次将下列姓名写入该文件，每个名字占一行。<br>      AcWing、yxc、Bob、张强、李明、Alice</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_0</span><br><span class="line">vim names.txt</span><br><span class="line">输入 i 进入编辑模式</span><br><span class="line">依次输入各个单词</span><br><span class="line">按ESC返回一般命令模式</span><br><span class="line">按 :wq 保存并退出</span><br></pre></td></tr></table></figure>

<p>(1) 进入homework_1文件夹，打开problem.txt，并依次删除下列字符：<br>     [1] 最后一行第101个字符<br>     [2] 第3行第8个字符<br>     [3] 第1行第30个字符<br>     [4] 第16行第55个字符<br>     [5] 第9行第80个字符<br>     最后保存文件并退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_1</span><br><span class="line">vim problem.txt</span><br><span class="line">[1] 最后一行第101个字符：G101&lt;Space&gt;i&lt;Backspace&gt;ESC</span><br><span class="line">[2] 第3行第8个字符：3G8&lt;Space&gt;i&lt;Backspace&gt;ESC</span><br><span class="line">[3] 第1行第30个字符：gg30&lt;Space&gt;i&lt;Backspace&gt;ESC</span><br><span class="line">[4] 第16行第55个字符：:16&lt;Enter&gt;55&lt;Space&gt;i&lt;Backspace&gt;ESC</span><br><span class="line">[5] 第9行第80个字符：9G80&lt;Space&gt;i&lt;Backspace&gt;ESC</span><br><span class="line">保存：:wq&lt;Enter&gt;</span><br></pre></td></tr></table></figure>

<p>(2) 进入homework_2文件夹，打开problem.txt，并依次执行如下操作：<br>     [1] 在第1个”two”的后面添加”abc”<br>     [2] 在第2个”two”的前面添加”def”<br>     [3] 将第3个”two”后面的连续12个字符删掉<br>     [4] 将第4个”two”所在的行删掉<br>     最后保存文件并退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_2</span><br><span class="line">vim problem.txt</span><br><span class="line">输入/two依次查找每个two(按n)</span><br><span class="line">[1] 在第1个&quot;two&quot;的后面添加&quot;abc&quot;  按i进入编辑模式添加即可</span><br><span class="line">[2] 在第2个&quot;two&quot;的前面添加&quot;def&quot;  按i进入编辑模式添加即可</span><br><span class="line">[3] 将第3个&quot;two&quot;后面的连续12个字符删掉  按i进入编辑模式，然后按delete键直接删即可</span><br><span class="line">[4] 将第4个&quot;two&quot;所在的行删掉  输入dd即可</span><br><span class="line">:wq 保存并退出</span><br></pre></td></tr></table></figure>

<p>(3) 进入homework_3文件夹，打开problem.txt，并依次执行如下操作：<br>     [1] 将第5行至第15行中所有of替换成OF。<br>     [2] 将全文中所有的the替换成THE。<br>     [3] 将第偶数个is替换成IS，第奇数个is不变。下标从1开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_3</span><br><span class="line">vim problem.txt</span><br><span class="line">[1] 将第5行至第15行中所有of替换成OF。  :5,15s/of/OF/g</span><br><span class="line">[2] 将全文中所有的the替换成THE。  :1,$s/the/THE/g</span><br><span class="line">[3] 将第偶数个is替换成IS，第奇数个is不变。下标从1开始。  :1,$s/is/IS/gc  然后ny交替按即可</span><br><span class="line">:wq 保存并退出</span><br></pre></td></tr></table></figure>

<p>(4) 进入homework_4文件夹，打开problem.txt，并依次执行如下操作：<br>     [1] 删除第11行<br>     [2] 将所删除的行粘贴到文件最后一行的下一行<br>     [3] 复制第5行<br>     [4] 将所复制的行粘贴到文件当前最后一行的下一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_4</span><br><span class="line">vim problem.txt</span><br><span class="line">[1] 删除第11行  11Gdd</span><br><span class="line">[2] 将所删除的行粘贴到文件最后一行的下一行  Gp</span><br><span class="line">[3] 复制第5行  5Gyy</span><br><span class="line">[4] 将所复制的行粘贴到文件当前最后一行的下行  Gp</span><br><span class="line">:wq  保存并退出</span><br></pre></td></tr></table></figure>

<p>(5) 进入homework_5文件夹，打开problem.txt，并依次执行如下操作：<br>     [1] 删除第11行第15个字符（包含该字符）至第13行第5个字符（包含该字符）<br>     [2] 将所删除的内容粘贴到文件末尾（注意不要另起一行）<br>     [3] 复制第5行第88个字符（包含该字符）至第7行第6个字符（包含该字符）<br>     [4] 将所复制的内容粘贴到当前文件末尾（注意不要另起一行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_5</span><br><span class="line">vim problem.txt</span><br><span class="line">[1] 删除第11行第15个字符（包含该字符）至第13行第5个字符（包含该字符）  11G14&lt;Space&gt;v13G5&lt;Space&gt;d</span><br><span class="line">[2] 将所删除的内容粘贴到文件末尾（注意不要另起一行）  G$p</span><br><span class="line">[3] 复制第5行第88个个字符（包含该字符）至第7行第6个字符（包含该字符）  5G87&lt;Space&gt;v7G6&lt;Space&gt;y</span><br><span class="line">[4] 将所复制的内容粘贴到当前文件末尾（注意不要另起一行） G$p</span><br><span class="line">:wq  保存并退出</span><br></pre></td></tr></table></figure>

<p>(6) 进入homework_6文件夹，并依次执行如下操作：<br>     [1] 清空source0.cpp<br>     [2] 将source1.cpp中的第1-3行和第12-24行复制到source0.cpp中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_6</span><br><span class="line">vim source0.cpp</span><br><span class="line">ggdG  # 删掉全文</span><br><span class="line">Ctrl-a, &quot;   在tmux中打开一个新的pane</span><br><span class="line">vim source1.cpp</span><br><span class="line">:set nonu  删掉行号</span><br><span class="line">shift + 选中前3行</span><br><span class="line">Ctrl + insert 复制选中内容</span><br><span class="line">选择source0.cpp所在的pane</span><br><span class="line">:set paste 进入粘贴模式</span><br><span class="line">i进入编辑模式</span><br><span class="line">Shift + insert粘贴内容</span><br><span class="line"></span><br><span class="line">同理操作source1.cpp的第12-24行</span><br><span class="line">保存source0.cpp  :wq</span><br><span class="line">退出source1.cpp  :q (这一步很重要，不然会一直存在swp文件而导致test不成功)</span><br></pre></td></tr></table></figure>

<p>(7) 进入homework_7文件夹，格式化source.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_7</span><br><span class="line">vim source.cpp</span><br><span class="line">gg=G  全文格式化</span><br><span class="line">:wq  保存并退出</span><br></pre></td></tr></table></figure>

<p>(8) 进入homework_8文件夹，打开source.cpp，并依次执行如下操作：<br>     [1] 将第15-21行向右缩进2次。<br>     [2] 将第22-23行向左缩进1次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_8</span><br><span class="line">vim source.cpp</span><br><span class="line">选中15-21行   15Gv21G</span><br><span class="line">向右缩进一次   &gt;</span><br><span class="line">同理再缩进一次</span><br><span class="line"></span><br><span class="line">选中22-23行   22Gv23G</span><br><span class="line">向左缩进一次   &lt;</span><br><span class="line">:wq   保存并退出</span><br></pre></td></tr></table></figure>

<p>(9) 进入homework_9文件夹，打开链接：</p>
<p>​      <a href="https://www.acwing.com/activity/content/code/content/1694465/">https://www.acwing.com/activity/content/code/content/1694465/</a><br>​      新建文件source.cpp，将链接中的代码抄进source.cpp文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打就完事</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-常用文件管理命令</title>
    <url>/2022/11/15/Linux%E5%9F%BA%E7%A1%80-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>常用文件管理命令</strong>的相关内容（AcWing-day13）</p>
<span id="more"></span>

<h1 id="常用文件管理命令"><a href="#常用文件管理命令" class="headerlink" title="常用文件管理命令"></a>常用文件管理命令</h1><img src="/2022/11/15/Linux%E5%9F%BA%E7%A1%80-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/1.png" class="">

<p>后端服务器（server）多为 Linux 系统，熟练掌握 Linux 是工程开发（Web&#x2F;APP&#x2F;小程序&#x2F;桌面应用&#x2F;游戏）的基础</p>
<p>在 Linux 中，一个命令只用记住最常用的几个参数即可，其余均可通过 <code>-- help</code> 或者 <code>man</code> 来查找（边学边查才是最适合的学习方式），如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -- help</span><br><span class="line">man ls</span><br></pre></td></tr></table></figure>

<p>服务器均是通过终端操作，服务器一般都联网，想操作哪台服务器直接用终端去连就好（ssh），所以和本地的操作系统没有任何关系，只要有终端就行</p>
<h2 id="Linux文件结构"><a href="#Linux文件结构" class="headerlink" title="Linux文件结构"></a>Linux文件结构</h2><p><code>/</code> 根目录</p>
<p>在根目录下有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin 常见命令的可执行文件</span><br><span class="line">etc 配置文件（如代理服务器nginx）</span><br><span class="line">var 用最多是log（日志文件夹）</span><br><span class="line">lib 存放一些库文件（静态链接库）</span><br><span class="line">home 所有用户的家目录（一个Linux系统可能会有很多个用户）</span><br><span class="line">proc 存放一些进程相关的信息（如cpuinfo）</span><br><span class="line">root 根用户目录</span><br></pre></td></tr></table></figure>

<p>系统登录后起始位于用户目录（<code>~</code>），上一级是 home 目录，再上一级是根目录</p>
<h2 id="Linux路径描述"><a href="#Linux路径描述" class="headerlink" title="Linux路径描述"></a>Linux路径描述</h2><ol>
<li>绝对路径（从根目录开始描述），如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/acs/main.cpp</span><br></pre></td></tr></table></figure>

<p>第一个 <code>/</code> 表示根目录，<code>pwd</code> 命令是显示当前所在的绝对路径</p>
<ol start="2">
<li>相对路径（从当前目录开始描述）</li>
</ol>
<p>如何判别绝对路径和相对路径？绝对路径的开头一定是 <code>/</code> ，相对路径开头一定不是 <code>/</code> </p>
<ol start="3">
<li><p><code>.</code> （一个点表示当前目录）， <code>..</code> （两个点表示上一级目录）</p>
</li>
<li><p><code>~/</code> 表示当前用户目录</p>
</li>
</ol>
<h2 id="Linux文件管理常用命令"><a href="#Linux文件管理常用命令" class="headerlink" title="Linux文件管理常用命令"></a>Linux文件管理常用命令</h2><p>(1) ctrl c：终止命令，并且换行</p>
<p>(2) ctrl u：清空本行命令</p>
<p>(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项（very实用）</p>
<p>(4) ls：列出当前目录下的所有文件（不包括以 <code>.</code> 开头的隐藏文件），蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l   列出当前目录下所有文件的详细信息（长信息）</span><br><span class="line">ls -hl  将 -l 信息人性化输出</span><br><span class="line">ls -a   列出当前目录下的所有文件（包括以.开头的隐藏文件）</span><br><span class="line">ls -la  等价于ll</span><br></pre></td></tr></table></figure>

<p>(5) pwd：显示当前路径（绝对路径）</p>
<p>(6) cd XXX：进入XXX目录，<code>cd ..</code> 返回上级目录，<code>cd –</code> 返回上一次所在目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd后可以加任意路径，可以是相对路径，也可以是绝对路径</span><br><span class="line">cd后什么都不加就返回当前用户目录（~）</span><br></pre></td></tr></table></figure>

<p>(7) cp XXX YYY：将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如 <code>../dir_c/a.txt</code> ，表示上层目录下的dir_c文件夹下的文件a.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp还兼具文件重命名的功能，如：cp a/tmp.txt b/tmp2.txt</span><br><span class="line">如果是复制文件夹，只需在cp命令后加上-r参数即可：cp a b -r</span><br><span class="line">如果是复制文件夹到当前文件夹，只用cp a c -r即可</span><br><span class="line">cp = 复制+粘贴+重命名</span><br></pre></td></tr></table></figure>

<p>(8) mkdir XXX：创建一个名为XXX的目录（文件夹），XXX可以是相对路径，也可以是绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建多级目录：mkdir a/b/c -p</span><br></pre></td></tr></table></figure>

<p>(9) rm XXX：删除普通文件;  rm XXX -r：删除文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux中是没有回收站的，所以删除文件即直接删除，是没法找回的</span><br><span class="line">rm命令支持一次性删除多个文件：rm XXX YYY ZZZ</span><br><span class="line">rm -f XXX: 删除受保护的文件（此操作很危险，慎用！）</span><br><span class="line">rm /* -rf: 删库跑路（此操作异常危险，绝对慎用！）</span><br></pre></td></tr></table></figure>

<p>(10) mv XXX YYY：将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；mv还兼具文件重命名的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv = 剪切+粘贴+重命名</span><br></pre></td></tr></table></figure>

<p>(11) touch XXX：创建一个名为XXX的文件，注意与mkdir命令的区分</p>
<p>(12) cat XXX：展示文件XXX中的内容</p>
<p>(13) 复制文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows/Linux下：Ctrl + insert，Mac下：command + c （very实用）</span><br></pre></td></tr></table></figure>

<p>(14) 粘贴文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows/Linux下：Shift + insert，Mac下：command + v （very实用）</span><br></pre></td></tr></table></figure>

<p>(15) 方向键：上方向键最常用，可以往上查找历史命令</p>
<p>(16) history：显示当前为止所有的历史命令</p>
<p>(17) Linux文件管理命令支持正则表达式，用的最多的就是<code>*</code>，如：<code>rm *.txt</code></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：</span><br><span class="line">(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c</span><br><span class="line">(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak</span><br><span class="line">(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt</span><br><span class="line">(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下</span><br><span class="line">(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除</span><br><span class="line">(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除</span><br><span class="line">(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作</span><br><span class="line">(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，</span><br><span class="line">    将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt;</span><br><span class="line">    将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt;</span><br><span class="line">    将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;</span><br><span class="line">(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作</span><br><span class="line">(9) 进入homework_9文件夹，将其中所有txt类型的文件删除</span><br></pre></td></tr></table></figure>

<p>(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_0</span><br><span class="line">mkdir dir_a dir_b dir_c</span><br></pre></td></tr></table></figure>

<p>(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_1</span><br><span class="line">cp a.txt a.txt.bak</span><br><span class="line">cp b.txt b.txt.bak</span><br><span class="line">cp c.txt c.txt.bak</span><br></pre></td></tr></table></figure>

<p>(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_2</span><br><span class="line">mv a.txt a_new.txt</span><br><span class="line">mv b.txt b_new.txt</span><br><span class="line">mv c.txt c_new.txt</span><br></pre></td></tr></table></figure>

<p>(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_3</span><br><span class="line">mv dir_a/* dir_b/</span><br></pre></td></tr></table></figure>

<p>(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_4</span><br><span class="line">rm *</span><br></pre></td></tr></table></figure>

<p>(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_5</span><br><span class="line">rm * -r</span><br></pre></td></tr></table></figure>

<p>(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_6</span><br><span class="line">cat task.txt</span><br><span class="line">mkdir dir_a</span><br><span class="line">mv task.txt dir_a/done.txt</span><br></pre></td></tr></table></figure>

<p>(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt; 将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt; 将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_7</span><br><span class="line">mkdir dir_0 dir_1 dir_2</span><br><span class="line">cp a.txt dir_0/a0.txt</span><br><span class="line">cp a.txt dir_1/a1.txt</span><br><span class="line">cp a.txt dir_2/a2.txt</span><br><span class="line">cp b.txt dir_0/b0.txt</span><br><span class="line">cp b.txt dir_1/b1.txt</span><br><span class="line">cp b.txt dir_2/b2.txt</span><br><span class="line">cp c.txt dir_0/c0.txt</span><br><span class="line">cp c.txt dir_1/c1.txt</span><br><span class="line">cp c.txt dir_2/c2.txt</span><br></pre></td></tr></table></figure>

<p>(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_8</span><br><span class="line">cd dir_a</span><br><span class="line">cat task.txt</span><br><span class="line">rm a.txt</span><br><span class="line">cd ../dir_b/</span><br><span class="line">cat task.txt</span><br><span class="line">mv b.txt b_new.txt</span><br><span class="line">cd ../dir_c/</span><br><span class="line">cat task.txt</span><br><span class="line">cp c.txt c.txt.bak</span><br></pre></td></tr></table></figure>

<p>(9) 进入homework_9文件夹，将其中所有txt类型的文件删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd homework_9</span><br><span class="line">rm *.txt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-租云服务器及配置docker环境</title>
    <url>/2022/12/04/Linux%E5%9F%BA%E7%A1%80-%E7%A7%9F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E9%85%8D%E7%BD%AEdocker%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>租云服务器及配置docker环境</strong>的相关内容（AcWing-day20）</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="云平台的作用"><a href="#云平台的作用" class="headerlink" title="云平台的作用"></a>云平台的作用</h2><ol>
<li>存放我们的docker容器，让计算跑在云端</li>
<li>获得公网IP地址，让每个人都可以访问到我们的服务</li>
</ol>
<h2 id="云服务器推荐配置"><a href="#云服务器推荐配置" class="headerlink" title="云服务器推荐配置"></a>云服务器推荐配置</h2><p>任选一个云平台即可，学生机配置就已足够使用</p>
<ul>
<li><strong>1核 2GB</strong>（后期可以动态扩容，前期配置低一些没有关系）</li>
<li>网络带宽采用<strong>按量付费</strong>，最大带宽拉满即可（费用取决于用量，与最大带宽无关）</li>
<li>系统版本：<strong>ubuntu 20.04 LTS</strong></li>
</ul>
<h1 id="租云服务器及安装docker"><a href="#租云服务器及安装docker" class="headerlink" title="租云服务器及安装docker"></a>租云服务器及安装docker</h1><p>各大云平台的操作大同小异，此处以<strong>腾讯云</strong>为例，<strong>阿里云</strong>和<strong>华为云</strong>的具体操作见以下链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.acwing.com/blog/content/10867/  #阿里云</span><br><span class="line">https://www.acwing.com/blog/content/10869/  #华为云</span><br></pre></td></tr></table></figure>

<p>腾讯云官网：<a href="https://cloud.tencent.com/">https://cloud.tencent.com/</a></p>
<h2 id="创建工作用户acs并赋予sudo权限"><a href="#创建工作用户acs并赋予sudo权限" class="headerlink" title="创建工作用户acs并赋予sudo权限"></a>创建工作用户acs并赋予sudo权限</h2><p>打开 <code>Terminal</code> ，<code>ssh</code> 登录到新服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh ubuntu@xxx.xxx.xxx.xxx  # 注意腾讯云登录的用户不是root，而是ubuntu</span><br></pre></td></tr></table></figure>

<p>创建用户 <code>acs</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo adduser acs  # 创建用户acs</span><br><span class="line">sudo usermod -aG sudo acs  # 给用户acs分配sudo权限</span><br></pre></td></tr></table></figure>

<h2 id="配置免密登录方式"><a href="#配置免密登录方式" class="headerlink" title="配置免密登录方式"></a>配置免密登录方式</h2><p>退回 <code>Terminal</code> ，然后配置用户 <code>acs</code> 的别名和免密登录，具体可参考 <a href="https://xd-sy.github.io/2022/11/20/Linux%E5%9F%BA%E7%A1%80-ssh/">Linux 基础 - ssh</a> 中<strong>ssh登录</strong> 这一小节内容</p>
<h2 id="配置新服务器的工作环境"><a href="#配置新服务器的工作环境" class="headerlink" title="配置新服务器的工作环境"></a>配置新服务器的工作环境</h2><p>将 <code>Terminal</code> 的配置传到新服务器上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp .bashrc .vimrc .tmux.conf server_name:  # server_name需换成自己配置的别名</span><br></pre></td></tr></table></figure>

<h2 id="安装tmux和docker"><a href="#安装tmux和docker" class="headerlink" title="安装tmux和docker"></a>安装tmux和docker</h2><p>登录自己的服务器，然后安装 <code>tmux</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>

<p>打开 <code>tmux</code>（养成好习惯，所有开发工作都在 <code>tmux</code> 中进行，防止意外关闭终端后，工作进度丢失）</p>
<p>然后在 <code>tmux</code> 中根据以下步骤安装 <code>docker</code> 即可，具体也可参见<a href="https://docs.docker.com/engine/install/ubuntu/">docker安装教程</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line">echo \</span><br><span class="line">  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line"><span class="meta prompt_">  $</span><span class="language-bash">(lsb_release -cs) stable<span class="string">&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span></span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line">docker --version # 如果能正常显示docker版本，即可证明安装成功</span><br></pre></td></tr></table></figure>

<h1 id="docker教程"><a href="#docker教程" class="headerlink" title="docker教程"></a>docker教程</h1><h2 id="将当前用户添加到docker用户组"><a href="#将当前用户添加到docker用户组" class="headerlink" title="将当前用户添加到docker用户组"></a>将当前用户添加到docker用户组</h2><p>为了避免每次使用 <code>docker</code> 命令都需要加上 <code>sudo</code> 权限，可以将当前用户加入安装中自动创建的 <code>docker</code> 用户组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<p>执行完此操作后，需退出服务器，再重新登录回来，才可以省去 <code>sudo</code> 权限</p>
<h2 id="镜像（images）"><a href="#镜像（images）" class="headerlink" title="镜像（images）"></a>镜像（images）</h2><ol>
<li><code>docker pull ubuntu:20.04</code> ：拉取一个镜像</li>
<li><code>docker images</code> ：列出本地所有镜像</li>
<li><code>docker image rm ubuntu:20.04</code> 或 <code>docker rmi ubuntu:20.04</code> ：删除镜像 <code>ubuntu:20.04</code></li>
<li><code>docker commit CONTAINER IMAGE_NAME:TAG</code> ：创建某个 <code>container</code> 的镜像</li>
<li><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code> ：将镜像 <code>ubuntu:20.04</code> 导出到本地文件 <code>ubuntu_20_04.tar</code> 中</li>
<li><code>docker load -i ubuntu_20_04.tar</code> ：将镜像 <code>ubuntu:20.04</code> 从本地文件 <code>ubuntu_20_04.tar</code> 中加载出来</li>
</ol>
<h2 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h2><ol>
<li><p><code>docker create -it ubuntu:20.04</code> ：利用镜像 <code>ubuntu:20.04</code> 创建一个容器</p>
</li>
<li><p><code>docker ps -a</code> ：查看本地的所有容器</p>
</li>
<li><p><code>docker start CONTAINER</code> ：启动容器</p>
</li>
<li><p><code>docker stop CONTAINER</code> ：停止容器</p>
</li>
<li><p><code>docker restart CONTAINER</code> ：重启容器</p>
</li>
<li><p><code>docker run -itd ubuntu:20.04</code> ：创建并启动一个容器</p>
</li>
<li><p><code>docker attach CONTAINER</code> ：进入容器<br>先按 <code>Ctrl-P</code> ，再按 <code>Ctrl-Q</code> 可以挂起容器</p>
</li>
<li><p><code>docker exec CONTAINER COMMAND</code> ：在容器中执行命令</p>
</li>
<li><p><code>docker rm CONTAINER</code> ：删除容器</p>
</li>
<li><p><code>docker container prune</code> ：删除所有已停止的容器</p>
</li>
<li><p><code>docker export -o xxx.tar CONTAINER</code> ：将容器 <code>CONTAINER</code> 导出到本地文件 <code>xxx.tar</code> 中</p>
</li>
<li><p><code>docker import xxx.tar image_name:tag</code> ：将本地文件 <code>xxx.tar</code> 导入成镜像，并将镜像命名为 <code>image_name:tag</code></p>
</li>
<li><p><code>docker export/import</code> 与 <code>docker save/load</code> 的区别：<br><code>export/import</code> 会丢弃历史记录和元数据信息，仅保存容器当时的快照状态<br><code>save/load</code> 会保存完整记录，体积更大</p>
</li>
<li><p><code>docker top CONTAINER</code> ：查看某个容器内的所有进程</p>
</li>
<li><p><code>docker stats</code> ：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息</p>
</li>
<li><p><code>docker cp xxx CONTAINER:xxx</code> 或 <code>docker cp CONTAINER:xxx xxx</code> ：在本地和容器间复制文件</p>
</li>
<li><p><code>docker rename CONTAINER1 CONTAINER2</code> ：重命名容器</p>
</li>
<li><p><code>docker update [OPTIONS] CONTAINER</code> ：更新容器配置</p>
<p><code>docker update --cpu-shares 512 abebf7571666</code></p>
</li>
</ol>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>进入 <code>Terminal</code> ，然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器</span><br><span class="line">ssh server_name  # 登录自己的云端服务器</span><br><span class="line"></span><br><span class="line">docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地</span><br><span class="line">docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像</span><br><span class="line"></span><br><span class="line">docker attach my_docker_server  # 进入创建的docker容器</span><br><span class="line">passwd  # 设置root密码</span><br></pre></td></tr></table></figure>

<p>去云平台控制台中修改安全组配置，放行端口 <code>20000</code></p>
<p>返回 <code>Terminal</code> ，即可通过 <code>ssh</code> 登录自己的 <code>docker</code> 容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@xxx.xxx.xxx.xxx -p 20000  # 将xxx.xxx.xxx.xxx替换成自己服务器的IP地址</span><br></pre></td></tr></table></figure>


<p>然后，仿照第二小节内容，创建工作用户 <code>acs</code>，并配置 <code>docker</code> 容器的别名和免密登录</p>
<h1 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h1><p>如果 <code>apt-get</code> 下载软件速度较慢，可以参考<a href="https://www.acwing.com/activity/content/57/">清华大学开源软件镜像站</a>中的内容，修改软件源</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><code>docker ps</code> 查看当前正在运行的所有容器</li>
<li>如果要在容器中执行命令，容器必须属于运行状态</li>
<li>删除容器前需保证容器处于停止状态</li>
<li><code>docker cp</code> 命令还可以复制文件夹</li>
<li><code>docker pull</code> 命令是拉取 <code>docker</code> 官方镜像源</li>
<li>当镜像创建的容器未被全部销毁时，镜像是无法被删除的</li>
<li>租云服务器的一个核心目的就是通过云服务器创建 <code>docker</code> ，从而实现开发环境的可迁移（通过 <code>scp</code> 命令）</li>
<li>如果云服务器突然无法登录，很可能是账号欠费了</li>
<li>云服务器的流出速度是有很大限制的（具体根据订购时的配置而定），但流入速度基本没有限制</li>
<li>努力成为全栈</li>
</ol>
<h1 id="云服务器被盗记录"><a href="#云服务器被盗记录" class="headerlink" title="云服务器被盗记录"></a>云服务器被盗记录</h1><p>2022&#x2F;12&#x2F;19，在我购买云服务器的半个多月后，云服务器第一次遭受境外黑客（IP来源美国）的攻击，所幸黑客只是留了几个恶意文件，倒也没有造成什么损失</p>
<img src="/2022/12/04/Linux%E5%9F%BA%E7%A1%80-%E7%A7%9F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E9%85%8D%E7%BD%AEdocker%E7%8E%AF%E5%A2%83/1.png" class="">

<p>第一次遇到这种情况难免有些慌张，故此记录一番以备他日不时之需</p>
<img src="/2022/12/04/Linux%E5%9F%BA%E7%A1%80-%E7%A7%9F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E9%85%8D%E7%BD%AEdocker%E7%8E%AF%E5%A2%83/2.png" class="">

<p>通过腾讯云的“异常登录记录”可以知道，黑客并没有攻破云服务器的ubuntu账户，而是通过普通用户acs进行登录（都怪我之前太大意把acs账户的密码设为了最简单的“123456”），之后事情就好办了，先ssh登录到云服务器的ubuntu账户，在sudo权限下重新修改acs用户的密码即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh ubuntu@121.5.155.117</span><br><span class="line">sudo passwd acs</span><br></pre></td></tr></table></figure>

<p>倘若黑客攻破的是ubuntu账户，则需要在云平台上关闭服务器然后重置密码，之后再跟上述步骤即可</p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础-管道、环境变量与常用命令</title>
    <url>/2022/11/29/Linux%E5%9F%BA%E7%A1%80-%E7%AE%A1%E9%81%93%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本篇博客简单记录了Linux基础学习中的<strong>管道、环境变量与常用命令</strong>的相关内容（AcWing-day19）</p>
<span id="more"></span>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>管道类似于文件重定向，可以将前一个命令的 <code>stdout</code> 重定向到下一个命令的 <code>stdin</code> </p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol>
<li>管道命令仅处理 <code>stdout</code> ，会忽略 <code>stderr</code></li>
<li>管道右边的命令必须能接受 <code>stdin</code></li>
<li>多个管道命令可以串联</li>
</ol>
<h2 id="与文件重定向的区别"><a href="#与文件重定向的区别" class="headerlink" title="与文件重定向的区别"></a>与文件重定向的区别</h2><ul>
<li>文件重定向左边为命令，右边为文件</li>
<li>管道左右两边均为命令，左边有 <code>stdout</code> ，右边有 <code>stdin</code></li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>统计当前目录下所有 <code>python</code> 文件的总行数，其中 <code>find</code> 、 <code>xargs</code> 、 <code>wc</code> 等命令可以参考<strong>“常用命令”</strong>这一节内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; | xargs cat | wc -l</span><br></pre></td></tr></table></figure>

<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>Linux系统中会用很多环境变量来记录<strong>配置信息</strong><br>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>列出当前环境下的所有环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env  # 显示当前用户的变量</span><br><span class="line">set  # 显示当前shell的变量，包括当前用户的变量</span><br><span class="line">export  # 显示当前导出成用户变量的shell变量</span><br></pre></td></tr></table></figure>

<p>输出某个环境变量的值，以 <code>PATH</code> 为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>环境变量的定义、修改、删除操作可以参考<strong>“Linux基础-shell语法“</strong>这篇博客中的<strong>”变量“</strong>小节的内容</p>
<p>为了使对环境变量的修改能够应用到未来所有环境下，可以将修改命令放到 <code>~/.bashrc</code> 文件中<br>修改完 <code>~/.bashrc</code> 文件后，还需执行 <code>source ~/.bashrc</code> ，将此前的修改应用到当前的 <code>bash</code> 环境下</p>
<p>为何将修改命令放到 <code>~/.bashrc</code> ，就可以确保修改会影响未来所有的环境呢？</p>
<ul>
<li>每次启动 <code>bash</code> ，都会先执行 <code>~/.bashrc</code></li>
<li>每次 <code>ssh</code> 登陆远程服务器，都会启动一个 <code>bash</code> 命令行给我们</li>
<li>每次 <code>tmux</code> 新开一个 <code>pane</code> ，都会启动一个 <code>bash</code> 命令行给我们</li>
<li>所以未来所有新开的环境都会加载我们修改的内容</li>
</ul>
<h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><ol>
<li><code>HOME</code> ：用户的家目录</li>
<li><code>PATH</code> ：可执行文件（命令）的存储路径。路径与路径之间用 <code>:</code> 分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序</li>
<li><code>LD_LIBRARY_PATH</code> ：用于指定动态链接库（ <code>.so</code> 文件）的路径，其内容是以冒号分隔的路径列表</li>
<li><code>C_INCLUDE_PATH</code> ： <code>C</code> 语言的头文件路径，内容是以冒号分隔的路径列表</li>
<li><code>CPLUS_INCLUDE_PATH</code> ： <code>CPP</code> 的头文件路径，内容是以冒号分隔的路径列表</li>
<li><code>PYTHONPATH</code> ： <code>Python</code> 导入包的路径，内容是以冒号分隔的路径列表</li>
<li><code>JAVA_HOME</code> ： <code>jdk</code> 的安装目录</li>
<li><code>CLASSPATH</code> ：存放 <code>Java</code> 导入类的路径，内容是以冒号分隔的路径列表</li>
</ol>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>Linux命令非常多，本小节仅讲解几个常用命令。其他命令依赖于根据实际操作环境，边用边查</p>
<h2 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h2><ol>
<li><code>top</code> ：查看所有进程的信息（Linux的任务管理器）<br>   打开后，输入 <code>M</code> ：按使用内存排序<br>   打开后，输入 <code>P</code> ：按使用CPU排序<br>   打开后，输入 <code>q</code> ：退出</li>
<li><code>df -h</code> ：查看硬盘使用情况</li>
<li><code>free -h</code> ：查看内存使用情况</li>
<li><code>du -sh</code> ：查看当前目录占用的硬盘空间</li>
<li><code>ps aux</code> ：查看所有进程</li>
<li><code>kill -9 pid</code> ：杀死编号为 <code>pid</code> 的进程<br>   传递某个具体的信号： <code>kill -s SIGTERM pid</code></li>
<li><code>netstat -nt</code> ：查看所有网络连接</li>
<li><code>w</code> ：列出当前登陆的用户</li>
<li><code>ping</code> ：检查是否连网</li>
</ol>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><ol>
<li><code>chmod</code> ：修改文件权限</li>
<li><code>chmod +x xxx</code> ：给 <code>xxx</code> 添加可执行权限</li>
<li><code>chmod -x xxx</code> ：去掉 <code>xxx</code> 的可执行权限</li>
<li><code>chmod 777 xxx</code> ：将 <code>xxx</code> 的权限改成 <code>777</code></li>
<li><code>chmod 777 xxx -R</code> ：递归修改整个文件夹的权限</li>
</ol>
<h2 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h2><ol>
<li><code>find /path/to/directory/ -name &#39;*.py&#39;</code> ：搜索某个文件路径下的所有 <code>*.py</code> 文件</li>
<li><code>grep xxx</code> ：从 <code>stdin</code> 中读入若干行数据，如果某行中包含 <code>xxx</code> ，则输出该行；否则忽略该行</li>
<li><code>wc</code> ：统计行数、单词数、字节数<br>   既可以从 <code>stdin</code> 中直接读入内容；也可以在命令行参数中传入文件名列表<br><code>wc -l</code> ：统计行数<br><code>wc -w</code> ：统计单词数<br><code>wc -c</code> ：统计字节数</li>
<li><code>tree</code> ：展示当前目录的文件结构<br><code>tree /path/to/directory/</code> ：展示某个目录的文件结构<br><code>tree -a</code> ：展示隐藏文件</li>
<li><code>ag xxx</code> ：搜索当前目录下的所有文件，检索 <code>xxx</code> 字符串</li>
<li><code>cut</code> ：分割一行内容<br>   从 <code>stdin</code> 中读入多行数据<br><code>echo $PATH | cut -d &#39;:&#39; -f 3,5</code> ：输出 <code>PATH</code> 用 <code>:</code> 分割后第3、5列数据<br><code>echo $PATH | cut -d &#39;:&#39; -f 3-5</code> ：输出 <code>PATH</code> 用 <code>:</code> 分割后第3-5列数据<br><code>echo $PATH | cut -c 3,5</code> ：输出 <code>PATH</code> 的第3、5个字符<br><code>echo $PATH | cut -c 3-5</code> ：输出 <code>PATH</code> 的第3-5个字符</li>
<li><code>sort</code> ：将每行内容按字典序排序<br>   可以从 <code>stdin</code> 中读取多行数据<br>   可以从命令行参数中读取文件名列表</li>
<li><code>xargs</code> ：将 <code>stdin</code> 中的数据用空格或回车分割成命令行参数<br><code>find . -name &#39;*.py&#39; | xargs cat | wc -l</code> ：统计当前目录下所有 <code>python</code> 文件的总行数</li>
</ol>
<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><ol>
<li><code>more</code> ：浏览文件内容<br>   回车：下一行<br>   空格：下一页<br><code>b</code> ：上一页<br><code>q</code> ：退出</li>
<li><code>less</code> ：与 <code>more</code> 类似，功能更全<br>   回车：下一行<br><code>y</code> ：上一行<br><code>Page Down</code> ：下一页<br><code>Page Up</code> ：上一页<br><code>q</code> ：退出</li>
<li><code>head -3 xxx</code> ：展示 <code>xxx</code> 的前3行内容<br>   同时支持从 <code>stdin</code> 读入内容</li>
<li><code>tail -3 xxx</code> ：展示 <code>xxx</code> 末尾3行内容<br>   同时支持从 <code>stdin</code> 读入内容</li>
</ol>
<h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><ol>
<li><code>history</code> ：展示当前用户的历史操作。内容存放在 <code>~/.bash_history</code> 中</li>
</ol>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li><code>md5sum</code> ：计算 <code>md5</code> 哈希值<br>   可以从 <code>stdin</code> 读入内容<br>   也可以在命令行参数中传入文件名列表</li>
<li><code>time command</code> ：统计 <code>command</code> 命令的执行时间</li>
<li><code>ipython3</code> ：交互式 <code>python3</code> 环境。可以当做计算器，或者批量管理文件<br><code>! echo &quot;Hello World&quot;</code> ： <code>!</code> 表示执行 <code>shell</code> 脚本</li>
<li><code>watch -n 0.1 command</code> ：每0.1秒执行一次 <code>command</code> 命令</li>
<li><code>tar</code> ：压缩文件<br><code>tar -zcvf xxx.tar.gz /path/to/file/*</code> ：压缩<br><code>tar -zxvf xxx.tar.gz</code> ：解压缩</li>
<li><code>diff xxx yyy</code> ：查找文件 <code>xxx</code> 与 <code>yyy</code> 的不同点</li>
</ol>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ol>
<li><code>sudo command</code> ：以 <code>root</code> 身份执行 <code>command</code> 命令</li>
<li><code>apt-get install xxx</code> ：安装软件</li>
<li><code>pip install xxx --user --upgrade</code> ：安装 <code>python</code> 包</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><p>注意区分<strong>标准输入</strong>和<strong>命令参数</strong>是不一样的</p>
</li>
<li><p><code>find . -name &#39;*.py&#39; | xargs cat | wc -l</code> 和 <code>find . -name &#39;*.py&#39; | xargs wc -l</code> 都可以统计当前目录下所有 <code>python</code> 文件的总行数</p>
</li>
<li><p>没事不要轻易修改家目录下的 <code>.bashrc</code> 文件</p>
</li>
<li><p>动态链接库（之前已经预编译好，不编译进文件）、静态链接库（编译进文件）</p>
</li>
<li><p><code>ipython3</code> 是Linux中非常好用的命令，尤其当做计算器使用时</p>
</li>
<li><p>配环境的时候可能会要求改环境变量</p>
</li>
<li><p><code>python</code> 一般用 <code>python3</code></p>
</li>
<li><p><code>top</code> 类似于Windows中的任务管理器</p>
</li>
<li><p><code>du -ch</code> 是查看当前目录下每个文件所占用的硬盘空间</p>
</li>
<li><p><code>ps aux</code> 多搭配管道使用，如：<code>ps aux | grep xxx</code> ，80%情况下都是用来 <code>kill</code> 某个进程</p>
</li>
<li><p>对于有些进程用 <code>kill -9 pid</code>（立即杀死进程）会报错，得用 <code>kill -15 pid</code>（正常停止一个进程）</p>
</li>
<li><p><code>top</code> 相较 <code>ps aux</code> 会额外提供所有进程的统计信息，并且如果当前开启的进程数很多时，<code>top</code> 可以很方便地按使用内存或使用CPU进行排序，从上往下翻阅；而 <code>ps aux</code> 则只能从下往上翻阅，不太方便</p>
</li>
<li><p>如果某文件没有写权限，可以用 <code>vim</code> 打开后使用 <code>wq!</code> 强制保存（亲测有效）</p>
</li>
<li><p><code>grep xxx</code> 和 <code>wc</code> 都是使用 <code>Ctrl+D</code> 结束</p>
</li>
<li><p><code>less</code> 命令可以搭配 <code>NUM LOCK</code> 后的小键盘使用</p>
</li>
<li><p><code>history</code> 命令最多会显示最近的1000条历史命令，<code>.bash_history</code> 文件最多会保留最近的2000条历史命令</p>
</li>
<li><p>哈希函数和数字签名可以应用到今后的线上练习册中去，实现既可以让做练习的学生看不到明文答案，又可以验证做题人的身份，还可以完成作业评测</p>
</li>
<li><p><code>watch</code> 命令关闭是 <code>Ctrl+C</code></p>
</li>
<li><p>使用 <code>diff</code> 命令时，如果比较的两文件内容一致，则不会输出任何结果</p>
</li>
<li><p>Centos国内企业用的较多，Ubuntu外企用的较多</p>
</li>
<li><p><code>Django</code> 不推荐看书，看官方文档就行</p>
</li>
<li><p>开发效率越高维护效率就越高</p>
</li>
<li><p>Linux中 <code>ag</code> 命令需要额外安装，以Ubuntu为例：<code>sudo apt-get install silversearcher-ag</code></p>
</li>
<li><p>Centos的包管理软件是 <code>yum</code> ，所以安装软件的命令是 <code>yum -y install xxx</code></p>
</li>
<li><p><code>tar -zxvf xxx.tar.gz -C yyy</code> ：将 <code>xxx.tar.gz</code> 解压到指定目录 <code>yyy</code> 中</p>
</li>
<li><p><code>tar -zcvf xxx.tar.gz</code> 中的 <code>c</code> 是 <code>compress</code>（压缩），<code>tar -zxvf xxx.tar.gz</code> 中的 <code>x</code> 是 <code>extract</code>（提取）</p>
</li>
<li><p><code>ps -ef</code>  查看进程的父进程ID</p>
</li>
<li><p><code>ag</code> 和 <code>grep</code> 的区别是：<code>ag</code> 不区分大小写</p>
</li>
<li><p><code>shell</code> 脚本文件的后缀名不一定就是 <code>.sh</code> ，也可以不带后缀名</p>
</li>
<li><p>如果想在Linux中添加某个自定义命令，则需要修改 <code>~/.bashrc</code> 文件，将该命令所在的绝对路径加入 <code>PATH</code> 环境变量（在 <code>~/.bashrc</code> 文件的最后加上以下语句即可）</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=自定义命令所在的绝对路径:$PATH</span><br></pre></td></tr></table></figure>

<p>最后 <code>source ~/.bashrc</code> 对修改进行应用</p>
<ol start="31">
<li><p><code>ipython3</code> 也可直接执行 <code>shell</code> 指令，以 <code>!</code> 打头即可</p>
</li>
<li><p><code>ll</code> 命令可以查看当前目录下所有文件的权限信息（共10位）</p>
<p><code>d</code> 开头表示目录， <code>-</code> 开头表示文件， <code>l</code> 开头表示快捷方式</p>
</li>
</ol>
<img src="/2022/11/29/Linux%E5%9F%BA%E7%A1%80-%E7%AE%A1%E9%81%93%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1.png" class="">

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo使用指南</title>
    <url>/2022/10/08/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>本博客基于hexo+next+github搭建，本文将简单记录hexo使用中的常用指令，后续将继续更新补充……</p>
<span id="more"></span>

<p>搭建指南：<a href="https://zhuanlan.zhihu.com/p/547520780">https://zhuanlan.zhihu.com/p/547520780</a></p>
<p>配置指南：<a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a></p>
<p>使用指南：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p>next主题：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></p>
<h1 id="hexo常用指令"><a href="#hexo常用指令" class="headerlink" title="hexo常用指令"></a>hexo常用指令</h1><p>一、<code>$ hexo new [layout] &lt;title&gt;</code></p>
<p>新建一篇文章。layout为文章布局，有post（文章）、page（页面）和draft（草稿）三种，是可选项，默认为post。title为文章标题，是必选项，如果标题包含空格，需要使用引号括起来。示例：</p>
<p><code>$ hexo new &quot;post title with whitespace&quot;</code></p>
<p>二、<code>$ hexo clean</code></p>
<p>清除缓存文件和已生成的静态文件</p>
<p>三、<code>$ hexo server</code></p>
<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<p>通常采用调试模式：<code>$ hexo server --debug</code></p>
<p>四、<code>$ hexo generate</code></p>
<p>生成静态文件</p>
<p>五、<code>$ hexo deploy</code></p>
<p>部署网站</p>
<h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，举例来说：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="section">date: 2022/10/8 11:21:25</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>以下是一些常用的预定义参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>标题</td>
<td>文章的文件名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
</tbody></table>
<p><strong>分类和标签</strong></p>
<p>只有post（文章）支持分类和标签。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>。而标签没有顺序和层次。示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> Diary</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> PS3</span><br><span class="line"><span class="bullet">  -</span> Games</span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong></p>
<p>Hexo 不支持指定多个同级分类。下面的指定方法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> Diary</span><br><span class="line"><span class="bullet">  -</span> Life</span><br></pre></td></tr></table></figure>

<p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此需要了解较好的用法：</p>
<p><strong>并列分类</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [Linux]</span><br><span class="line"><span class="bullet">  -</span> [Tools]</span><br></pre></td></tr></table></figure>

<p><strong>并列+子分类</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [Linux, Hexo]</span><br><span class="line"><span class="bullet">  -</span> [Tools, PHP]</span><br></pre></td></tr></table></figure>

<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><p>还需要特别说明一下的是</p>
<p>一、在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。其中一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，可以将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p>
<p>二、主题的更新可以通过 <code>git pull</code> 来快速更新</p>
<p>三、博客集成的第三方服务有<strong>百度统计</strong>、<strong>Local Search</strong>、<strong>MathJax</strong>、<strong>畅言云评</strong>等</p>
<p>四、在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，在首页显示文章的摘录并显示 <strong>阅读全文</strong> 按钮</p>
<p>五、最后的最后，当前的博客还非常非常简陋，我会继续尽力完善之。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>博客中图片的插入方法</title>
    <url>/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本篇博客介绍hexo中图片的两种插入方法</p>
<span id="more"></span>

<h1 id="一、本地引用–相对路径"><a href="#一、本地引用–相对路径" class="headerlink" title="一、本地引用–相对路径"></a>一、本地引用–相对路径</h1><p>将图片资源放在与生成文章<code>post_name.md</code>的同名文件夹 <code>post_name</code>中，文章就可以使用如下指令相对引用图片资源了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>image.jpg</code>是图片文件名，<code>This is an image</code>是文章中显示的图片标题。</p>
<h1 id="二、CDN-引用"><a href="#二、CDN-引用" class="headerlink" title="二、CDN 引用"></a>二、CDN 引用</h1><p>除了在本地存储图片，还可以将图片上传到一些免费的 CDN 服务中。在图片 CDN 服务（比如SM.MS）上传图片后，会生成对应的 url 地址，将地址直接拿来引用即可。此时多采用组图形式，指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% gp [number]-[layout] %&#125;</span><br><span class="line">&#123;% endgp %&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>number</code>是可选参数，指组图中可添加的图片总数；<code>layout</code>也是可选参数，指布局的索引。具体布局索引如下图所示：</p>
<img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/1.png" class="">

<img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/2.png" class="">

<p>下面给出一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% grouppicture 3-3 %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% endgrouppicture %&#125;</span><br></pre></td></tr></table></figure>

<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div></div></div></div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% grouppicture 5-2 %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% asset_img next.svg %&#125;</span><br><span class="line">&#123;% endgrouppicture %&#125;</span><br></pre></td></tr></table></figure>

<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div><div class="group-picture-column" style="width: 50%;"><img src="/2022/10/09/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95/next.svg" class=""></div></div></div></div>







]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-位运算、离散化、区间合并</title>
    <url>/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>本篇博客简单记录了基础算法学习中的<strong>位运算、离散化、区间合并</strong>的相关内容（AcWing-day6）</p>
<span id="more"></span>

<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>此处只介绍两种最常见的操作</p>
<h2 id="求n的二进制表示中第k位是几"><a href="#求n的二进制表示中第k位是几" class="headerlink" title="求n的二进制表示中第k位是几"></a>求n的二进制表示中第k位是几</h2><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/1.png" class="">

<p>我们规定个位是第 0 位</p>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ol>
<li><p>先把第k位移到第0位（个位） <code>n &gt;&gt; k</code></p>
</li>
<li><p>再看第0位（个位）是几  <code>&amp; 1</code></p>
</li>
</ol>
<p>两步合并即为：<code>n &gt;&gt; k &amp; 1</code></p>
<h3 id="例题：求n的二进制表示"><a href="#例题：求n的二进制表示" class="headerlink" title="例题：求n的二进制表示"></a>例题：求n的二进制表示</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">3</span>; k &gt;= <span class="number">0</span>; k--) cout &lt;&lt; (n &gt;&gt; k &amp; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lowbit-操作"><a href="#lowbit-操作" class="headerlink" title="lowbit 操作"></a>lowbit 操作</h2><p>lowbit 操作是树状数组的一个基本操作</p>
<p>lowbit(x) 的作用是：返回 x 最右端的一位 1 到最右端的整个二进制序列</p>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/2.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lowbit(x) = x &amp; -x = x &amp; (～x+1)</span><br></pre></td></tr></table></figure>

<p>其中 ～x 是 x 取反的意思（反码），-x 为 x 的补码（补码 &#x3D; 反码 + 1）</p>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/3.png" class="">

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>lowbit 操作最简单的应用就是统计 x 中 1 的个数</p>
<p>思想就是每一次把 x 中最右端的 1 去掉（减掉），直到 x 等于 0 为止，统计去掉 1 的次数</p>
<h3 id="AcWing-801-二进制中1的个数"><a href="#AcWing-801-二进制中1的个数" class="headerlink" title="AcWing 801. 二进制中1的个数"></a>AcWing 801. 二进制中1的个数</h3><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/4.png" class="">

<p>使用 lowbit 操作即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) x -= <span class="built_in">lowbit</span>(x), res++;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原码、反码、补码的关系"><a href="#原码、反码、补码的关系" class="headerlink" title="原码、反码、补码的关系"></a>原码、反码、补码的关系</h3><p>计算机中的负数用补码表示（为什么？因为计算机中的减法其实是用加法实现的）</p>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/5.png" class="">

<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>此处特指整数的离散化，而且是保序的离散化</p>
<p>离散化的基本概念：把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小</p>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/6.png" class="">

<p>离散化中一般有两个问题</p>
<ol>
<li><p>原始数据中可能有重复元素，需要去重（使用库函数）</p>
</li>
<li><p>如何算出原始数据离散化后的值（利用二分算法映射为从1开始的自然数下标）</p>
</li>
</ol>
<h2 id="AcWing-802-区间和"><a href="#AcWing-802-区间和" class="headerlink" title="AcWing 802. 区间和"></a>AcWing 802. 区间和</h2><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/7.png" class="">

<p>题目所给的数据范围比较小的话（10^5以内）可以直接用前缀和做，数据范围比较大的话（如这题是10^9）则需要借助离散化</p>
<p>虽然题目的数据跨度是2*10^9，但实则用到的坐标最多只有3*10^5，这就是典型的离散化问题</p>
<h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>将题目所有用到的下标先排个序，然后映射为从 1 开始的自然数即可（由于要求前缀和，所以是从 1 开始映射，而不是从 0 开始。还有需要注意的是，这里的映射需要保证下标的相对大小不变）。所以如果要在 x 的位置上加 c ，只需把 x 映射为某一自然数，在该自然数位置上加 c 即可。求区间和时也是一样，先把 l 和 r 映射为某两个自然数，然后求这两个自然数之间所有数的和即可。全部映射完成后，题目所有用到的下标就都集中在 1 到 3*10^5 之间了，然后求前缀和即可</p>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/8.png" class="">

<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为add（加c）和query（询问）中所需的操作数均为两个，所以使用pair进行存储；并且规定后续使用PII来代替pair&lt;int, int&gt;这样的繁杂写法</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们需要将x\l\r离散化到新数组，最坏情况下，x\l\r离散化后的映射均不重复，此时新数组需要n+2m的空间，结合题目中n\m的具体范围，即为300000</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N]; <span class="comment">// a[N]存储离散化后的新数据，s[N]存储新数据的前缀和</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// alls存储待离散化的原始数据</span></span><br><span class="line">vector&lt;PII&gt; add, query; <span class="comment">// add和query数组中存储的数据均为pair类型，即一对操作数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// find函数用于对x离散化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实际采用二分算法达到离散化的目的</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid; <span class="comment">// 要找第一个大于等于x的位置</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 新数组下标为从1开始的自然数，这样容易处理前缀和的边界问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自写unique函数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span>(!i||a[i]!=a[i<span class="number">-1</span>]) a[j++]=a[i]; <span class="comment">// 把原a数组中所有不重复的数存到a[0]~a[j-1]的位置上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;); <span class="comment">// 把x和c两个参数作为一个整体加到add数组中</span></span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x); <span class="comment">// 把x加到待离散化的数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;); <span class="comment">// 把l和r两个参数作为一个整体加到query数组中</span></span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l); <span class="comment">// 把l加到待离散化的数组中</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r); <span class="comment">// 把r加到待离散化的数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 先排序</span></span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls), alls.<span class="built_in">end</span>()); <span class="comment">// 后去重</span></span><br><span class="line">    <span class="comment">// 也可以用C++自带的unique函数</span></span><br><span class="line">    <span class="comment">// alls.erase(unique(alls.begin(), alls.end()), alls.end());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); <span class="comment">// 取&#123;x,c&#125;中的x</span></span><br><span class="line">        a[x] += item.second; <span class="comment">// 取&#123;x,c&#125;中的c加到a[x]中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i]; <span class="comment">// 前缀和公式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second); <span class="comment">// 分别取&#123;l,r&#125;中的l和r</span></span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl; <span class="comment">// 输出区间和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>给定 n 个区间，将所有有交集的区间进行合并，最后返回合并后的区间个数</p>
<p>边界问题：如果两个区间只有端点相交，也认为可以合并</p>
<p>示例：</p>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/9.png" class="">

<h2 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h2><ol>
<li><p>按区间左端点排序（贪心）</p>
</li>
<li><p>区间合并的三种情形</p>
</li>
</ol>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/10.png" class="">

<h2 id="AcWing-803-区间合并"><a href="#AcWing-803-区间合并" class="headerlink" title="AcWing 803. 区间合并"></a>AcWing 803. 区间合并</h2><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/11.png" class="">

<h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><p>先维护一个区间，将它与有交集的区间进行合并，然后确定合并后的区间是否有新的交集区间，如果有就继续合并，如果没有就开始维护下一个区间</p>
<h3 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII; <span class="comment">// 左右端点</span></span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span> <span class="comment">// 区间合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>()); <span class="comment">// 要先排序，pair类型排序时默认优先比较first值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st=<span class="number">-2e9</span>, ed=<span class="number">-2e9</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg:segs) <span class="comment">// 再合并区间</span></span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;); <span class="comment">// 加一个判断条件，起始分段不能算进去</span></span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;); <span class="comment">// segs不为空</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-二分</title>
    <url>/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>本篇博客简单记录了基础算法学习中的<strong>整数二分</strong>和<strong>浮点数二分</strong>的相关内容（AcWing-day2）</p>
<span id="more"></span>

<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><h2 id="二分的本质"><a href="#二分的本质" class="headerlink" title="二分的本质"></a>二分的本质</h2><p>如果题目数据具有单调性，那么一定可以二分；但是，可以二分的题目，也可以不要求数据一定具有单调性。所以二分的本质并不是单调性，而是边界点的确定</p>
<h2 id="两种模板"><a href="#两种模板" class="headerlink" title="两种模板"></a>两种模板</h2><p>求边界点可以分为以下两种情况：</p>
<img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/1.png" class="">

<img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/2.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">// 其实此时l=r</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">// 其实此时l=r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故每次看更新区间，是l&#x3D;mid还是r&#x3D;mid，l&#x3D;mid情况下需要给mid补上+1，r&#x3D;mid情况下不需要补+1</p>
<h2 id="整数二分模板题（AcWing-789-数的范围）"><a href="#整数二分模板题（AcWing-789-数的范围）" class="headerlink" title="整数二分模板题（AcWing 789. 数的范围）"></a>整数二分模板题（AcWing 789. 数的范围）</h2><img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/3.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//求左边界</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid]&gt;=x) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(q[l]!=x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">//输出左边界，其实此时l=r</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//求右边界</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid]&lt;=x) l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl; <span class="comment">//输出右边界，其实此时l=r</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，二分模板一定是有解的，根据此解与题设的比较，可知题目最终是否有解</p>
<h2 id="奇怪的知识（关于C-）"><a href="#奇怪的知识（关于C-）" class="headerlink" title="奇怪的知识（关于C++）"></a>奇怪的知识（关于C++）</h2><p><code>cout &lt;&lt; &lt;&lt; endl;</code> 表示输出换行的意思</p>
<h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><p>浮点数二分没有边界问题，相比整数二分要简单很多</p>
<h2 id="浮点数二分模板题（AcWing-790-数的三次方根）"><a href="#浮点数二分模板题（AcWing-790-数的三次方根）" class="headerlink" title="浮点数二分模板题（AcWing 790. 数的三次方根）"></a>浮点数二分模板题（AcWing 790. 数的三次方根）</h2><img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/4.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l=<span class="number">-10000</span>,r=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid&gt;=x) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,l);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/5.png" class="">

<h2 id="AcWing-786-第k个数"><a href="#AcWing-786-第k个数" class="headerlink" title="AcWing 786. 第k个数"></a>AcWing 786. 第k个数</h2><img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/6.png" class="">

<h3 id="法一：快速排序算法"><a href="#法一：快速排序算法" class="headerlink" title="法一：快速排序算法"></a>法一：快速排序算法</h3><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x=q[(l+r)/<span class="number">2</span>],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,q[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,q[k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(nlogn)</p>
<h3 id="法二：快速选择算法"><a href="#法二：快速选择算法" class="headerlink" title="法二：快速选择算法"></a>法二：快速选择算法</h3><img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/7.png" class="">

<img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/8.png" class="">

<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>假设当前已完成快排的前两步基本步骤，设此时分界点的左侧有 SL 个数，分界点的右侧有 SR 个数。</p>
<ol>
<li>如果 k&lt;&#x3D;SL ，即说明第 k 个最小值在分界点的左侧，那么只要递归 Left 即可</li>
<li>如果 k&gt;SL ，即说明第 k 个最小值在分界点的右侧，那么只要递归 Right 即可，此时第 k 个最小值是分界点右侧的第 k-SL 个最小值</li>
</ol>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> q[l];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x=q[l],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++i]&lt;x);</span><br><span class="line">        <span class="keyword">while</span>(q[--j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sl=j-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=sl) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l,j,k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r,k-sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>,k) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)</p>
<h4 id="奇怪的知识（关于C-）-1"><a href="#奇怪的知识（关于C-）-1" class="headerlink" title="奇怪的知识（关于C++）"></a>奇怪的知识（关于C++）</h4><p>在 C++ 中，局部变量和全局变量是可以重名的，如果重名会优先使用局部变量</p>
<h2 id="AcWing-788-逆序对的数量"><a href="#AcWing-788-逆序对的数量" class="headerlink" title="AcWing 788. 逆序对的数量"></a>AcWing 788. 逆序对的数量</h2><img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/9.png" class="">

<h3 id="法一：外循环嵌套内循环"><a href="#法一：外循环嵌套内循环" class="headerlink" title="法一：外循环嵌套内循环"></a>法一：外循环嵌套内循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q[N],k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i]&gt;q[j]) k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间开销太大</p>
<h3 id="法二：基于归并排序"><a href="#法二：基于归并排序" class="headerlink" title="法二：基于归并排序"></a>法二：基于归并排序</h3><h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><img src="/2022/10/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/10.png" class="">

<p>逆序对分为三种类型：</p>
<ol>
<li>左半边内部的逆序对数量：merge_sort(L, mid)</li>
<li>右半边内部的逆序对数量：merge_sort(mid+1, R)</li>
<li>左右半边构成的逆序对数量：因为左右半边均有序，所以当 i 指针所指向的数大于 j 指针所指向的数时，左半边后续所有的数均大于此时 j 指针所指向的数，即构成逆序对。每一次逆序对数量为mid-i+1</li>
</ol>
<h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    LL res=<span class="built_in">merge_sort</span>(l,mid)+<span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并的过程</span></span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++]=q[j++];</span><br><span class="line">            res+=mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫尾</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//物归原主</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; q[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-前缀和与差分</title>
    <url>/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>本篇博客简单记录了基础算法学习中的<strong>前缀和与差分</strong>的相关内容（AcWing-day4）</p>
<span id="more"></span>

<h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><p>前缀和与差分是一对逆运算</p>
<h1 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h1><h2 id="一维前缀和定义"><a href="#一维前缀和定义" class="headerlink" title="一维前缀和定义"></a>一维前缀和定义</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/1.png" class="">

<p>注意原数组的下标从1开始</p>
<h2 id="一维前缀和计算"><a href="#一维前缀和计算" class="headerlink" title="一维前缀和计算"></a>一维前缀和计算</h2><p>令S[0]&#x3D;0</p>
<img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/2.png" class="">

<h2 id="一维前缀和作用"><a href="#一维前缀和作用" class="headerlink" title="一维前缀和作用"></a>一维前缀和作用</h2><p>能快速求出原数组中一段连续数的和（最大的作用，其实也是唯一的作用）</p>
<img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/3.png" class="">

<p>时间复杂度为O(1)</p>
<h2 id="一维前缀和模板题（AcWing-795-前缀和）"><a href="#一维前缀和模板题（AcWing-795-前缀和）" class="headerlink" title="一维前缀和模板题（AcWing 795. 前缀和）"></a>一维前缀和模板题（AcWing 795. 前缀和）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/4.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> a[N],s[N];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="number">-1</span>]+a[i]; <span class="comment">// 前缀和的初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]); <span class="comment">// 区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然代码很短，但思想很重要，前缀和是个很实用的工具，且很容易考</p>
<h2 id="奇怪的知识（关于C-）"><a href="#奇怪的知识（关于C-）" class="headerlink" title="奇怪的知识（关于C++）"></a>奇怪的知识（关于C++）</h2><p><code>ios::sync_with_stdio(false);</code></p>
<p>语义是要不要和标准读入同步，设置 false 的作用是提高 cin 的读取速度，副作用是不能再使用 scanf()，且优化之后还是没有 scanf() 快</p>
<p>如果数据输入的规模大于等于10^6，建议用 scanf()，否则建议用 cin</p>
<h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><h2 id="二维前缀和作用"><a href="#二维前缀和作用" class="headerlink" title="二维前缀和作用"></a>二维前缀和作用</h2><p>能快速求出某子矩阵中所有数的和</p>
<p>S[i][j] 为以 [i, j] 为右下角坐标的矩阵中的所有数的和</p>
<img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/5.png" class="">

<p>举例：</p>
<img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/6.png" class="">

<h2 id="二维前缀和计算"><a href="#二维前缀和计算" class="headerlink" title="二维前缀和计算"></a>二维前缀和计算</h2><p>S[i][j] 的递推公式</p>
<img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/7.png" class="">

<h2 id="二维前缀和模板题（AcWing-795-子矩阵的和）"><a href="#二维前缀和模板题（AcWing-795-子矩阵的和）" class="headerlink" title="二维前缀和模板题（AcWing 795. 子矩阵的和）"></a>二维前缀和模板题（AcWing 795. 子矩阵的和）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/8.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,q;</span><br><span class="line">    <span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j]; <span class="comment">// 求前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="number">-1</span>]-s[x1<span class="number">-1</span>][y2]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]); <span class="comment">// 求子矩阵的和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><h2 id="一维差分定义"><a href="#一维差分定义" class="headerlink" title="一维差分定义"></a>一维差分定义</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/9.png" class="">

<p>构造 b 数组，使得 a 数组是 b 数组的前缀和，此时 b 数组即为 a 数组的差分</p>
<h2 id="一维差分构造"><a href="#一维差分构造" class="headerlink" title="一维差分构造"></a>一维差分构造</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/10.png" class="">

<h2 id="一维差分作用"><a href="#一维差分作用" class="headerlink" title="一维差分作用"></a>一维差分作用</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/11.png" class="">

<p>由 b 数组可以以O(n)的时间得到 a 数组</p>
<p>想让 a 数组中某一区间内的所有数都 +C 的话，循环遍历 a 数组需要O(n)的时间复杂度，而其实我们只需在 b 数组中修改 b[i] 和 b[r+1] 两个数即可，时间复杂度可节省为O(1)</p>
<h2 id="一维差分模板题（AcWing-797-差分）"><a href="#一维差分模板题（AcWing-797-差分）" class="headerlink" title="一维差分模板题（AcWing 797. 差分）"></a>一维差分模板题（AcWing 797. 差分）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/12.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span> <span class="comment">// 一维差分的核心——insert()公式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><h2 id="二维差分作用"><a href="#二维差分作用" class="headerlink" title="二维差分作用"></a>二维差分作用</h2><p>便利子矩阵中所有数 +C 的时间复杂度</p>
<h2 id="二维差分构造"><a href="#二维差分构造" class="headerlink" title="二维差分构造"></a>二维差分构造</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/13.png" class="">

<h2 id="二维差分模板题（AcWing-798-差分矩阵）"><a href="#二维差分模板题（AcWing-798-差分矩阵）" class="headerlink" title="二维差分模板题（AcWing 798. 差分矩阵）"></a>二维差分模板题（AcWing 798. 差分矩阵）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/14.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                b[i][j]+=b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-双指针算法</title>
    <url>/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本篇博客简单记录了基础算法学习中的<strong>双指针算法</strong>的相关内容（AcWing-day5）</p>
<span id="more"></span>

<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>双指针算法很常见，在快速排序、归并排序中都有用到</p>
<p>双指针算法有两种常见情况：</p>
<ol>
<li><p>一共两个序列，一个指针指向其中一个序列，另一个指针指向另一个序列（少数情况）</p>
</li>
<li><p>只有一个序列，两个指针共同维护一段区间（多数情况）</p>
</li>
</ol>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的双指针算法的时间复杂度都是O(n)，双指针算法的目的就是将时间复杂度为O(n^2)的暴力解法依据某种性质（其实就是单调性）优化到O(n)。所以其实双指针算法的解题思路就是先考虑暴力解法，然后在这基础上尝试优化</p>
<h2 id="AcWing-799-最长连续不重复子序列"><a href="#AcWing-799-最长连续不重复子序列" class="headerlink" title="AcWing 799. 最长连续不重复子序列"></a>AcWing 799. 最长连续不重复子序列</h2><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/1.png" class="">

<h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>i 指针循环遍历整个序列，每一次遍历 i 指针都要确定 j 指针的位置（ j 指针在其能在的最左位置，使得 [j,i] 区间内的所有数均不重复）。如果 i 指针++后，[j,i] 区间内出现重复数，则 j 指针也++，然后继续 check[j,i] 区间，不断更新 j 指针的位置，直到 [j,i] 区间内不再有重复数为止。最后更新最长连续不重复子序列的长度为 i-j+1（如果此时 i-j+1 大于之前保存的最长连续不重复子序列的长度的话）</p>
<p>可以用下面这个例子模拟一下</p>
<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2.png" class="">

<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,res=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[i]]&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">max</span>(res, i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实此题还有需要完善的地方，因为此题中数的范围还不够大，如果数的范围很大就需要依靠“哈希表”来做了（后面数据结构中会讲到）</p>
<h2 id="AcWing-800-数组元素的目标和"><a href="#AcWing-800-数组元素的目标和" class="headerlink" title="AcWing 800. 数组元素的目标和"></a>AcWing 800. 数组元素的目标和</h2><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/3.png" class="">

<h3 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h3><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/4.png" class="">

<img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/5.png" class="">

<h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><p>来自 y 总，推荐使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,x;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=m<span class="number">-1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[i]+b[j]&gt;x) j--;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+b[j]==x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><p>我写的，不怎么推荐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=m<span class="number">-1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+b[j]&lt;x) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]+b[j]&lt;x) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i]+b[j]==x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-2816-判断子序列"><a href="#AcWing-2816-判断子序列" class="headerlink" title="AcWing 2816. 判断子序列"></a>AcWing 2816. 判断子序列</h2><img src="/2022/11/03/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/6.png" class="">

<p>这题在笔试面试中考察的次数非常多，做起来难度倒是一般</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n<span class="number">-1</span>&amp;&amp;j&lt;=m<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==n) <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-排序</title>
    <url>/2022/10/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本篇博客简单记录了基础算法学习中的<strong>快速排序</strong>和<strong>归并排序</strong>的相关内容（AcWing-day1）</p>
<span id="more"></span>

<h1 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h1><p>因为是关于AcWing算法基础课的第一篇博客，所以简单介绍一下今后对于该课程的学习方法</p>
<p><strong>课上：</strong>理解算法的主要思想</p>
<p><strong>课后：</strong> 1. 背过代码模板，能默写、调试通过即可  2. 利用习题对模板的掌握程度进行检验  3. 对习题代码进行删除重写，重复3-5次即可取得很好的记忆效果</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序主要基于分治的思想</p>
<p>Plus：面试官很喜欢在面试的时候让手写一个快排</p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>确定分界点 x ：常用的有左边界q[l]，中间值q[(l+r)&#x2F;2]，右边界q[r]。也可以取随机</li>
<li>调整区间：把整个区间一分为二，保证分界点左边所有的数都小于等于 x ，右边所有的数都大于等于 x</li>
<li>递归处理分界点左右两边</li>
</ol>
<h2 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h2><p>思想上简单，但需要一些额外的空间</p>
<img src="/2022/10/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/1.png" class="">

<h2 id="优美的做法"><a href="#优美的做法" class="headerlink" title="优美的做法"></a>优美的做法</h2><p>不需要开辟额外的空间</p>
<p>分别在区间的左右端点设置两个指针 i 和 j ，i 指针先向右移动，如果 i 指针指向的值小于 x ，则 i 指针继续右移，直到移动到 i 指针指向的值大于等于 x 时停止；此时开始向左移动 j 指针，如果 j 指针指向的值大于 x ，则 j 指针继续左移，直到移动到 j 指针指向的值小于等于 x 时停止。然后交换 i 指针和 j 指针所指向的两个数，之后 i 指针和 j 指针按照上述步骤继续移动，直至 i 指针和 j 指针发生相遇时停止。此时区间内的所有数已被成功划分成两块，分界点左侧的数全都小于等于它，分界点右侧的数全都大于等于它，然后再依次递归分界点左右两侧即可</p>
<img src="/2022/10/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/2.png" class="">

<h2 id="快速排序模板题（AcWing-785-快速排序）"><a href="#快速排序模板题（AcWing-785-快速排序）" class="headerlink" title="快速排序模板题（AcWing 785. 快速排序）"></a>快速排序模板题（AcWing 785. 快速排序）</h2><img src="/2022/10/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/3.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x=q[(l+r)/<span class="number">2</span>],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>; <span class="comment">//快速排序这道题的数据已加强，分界点取左端点或右端点时会超时，需改成取中点或随机值</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快排是不稳定的</p>
<p>平均时间复杂度为O(nlogn)</p>
<h2 id="奇怪的知识（关于C-）"><a href="#奇怪的知识（关于C-）" class="headerlink" title="奇怪的知识（关于C++）"></a>奇怪的知识（关于C++）</h2><p>#include &lt;iostream&gt; 的意思是引入 iostream 库，即输入输出流库</p>
<p>iostream 库的基础是两种命名为 istream 和 ostream 的类型，分别表示输入流和输出流</p>
<p>#include &lt;iostream&gt; 是标准的C++头文件，任何符合标准的C++开发环境都有这个头文件。在旧的标准C++中，使用 #include &lt;iostream.h&gt;，但在新标准中，用 #include &lt;iostream&gt;</p>
<p>iostream 标准库定义了4个IO对象。处理输入时使用命名为 cin (读作see-in) 的 istream 类型对象。这个对象也称为标准输入。处理输出时使用命名为 cout (读作see-out)的 ostream 类型对象，这个对象也称为标准输出</p>
<p>标准库还定义了另外两个 ostream 对象，分别命名为 cerr 和 clog (分别读作“see-err”和“see-log”）</p>
<p>cerr 对象又叫作标准错误，通常用来输出警告和错误信息给程序的使用者。而 clog 对象用于产生程序执行的一般信息</p>
<p>在C++中建议用 scanf() 进行读入；在 JAVA 中一定不要用Scanner，而要用BufferReader，能提升程序约20倍的读取效率</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序也主要基于分治的思想</p>
<h2 id="基本步骤-1"><a href="#基本步骤-1" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>确定分界点：mid&#x3D;(l+r)&#x2F;2</li>
<li>递归排序 left 和 right</li>
<li>归并，合 left 和 right 为一</li>
</ol>
<img src="/2022/10/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/4.png" class="">

<p>主要的难点在于第3步归并</p>
<h2 id="优美的做法（采用双指针算法）"><a href="#优美的做法（采用双指针算法）" class="headerlink" title="优美的做法（采用双指针算法）"></a>优美的做法（采用双指针算法）</h2><p>假设在第2步排序后，已得到两个有序的序列（默认从小到大排列）。分别设置指针 i 和 j 指向两个序列的开头（i&#x3D;l, j&#x3D;mid+1），此时指针 i 指向第一个序列中的最小值，指针 j 指向第二个序列中的最小值，再引入一个临时数组 tmp 来记录最终合并后的有序序列，设置指针 k 指向临时数组的开头。比较指针 i 和指针 j 所指向的两个数的大小，将较小的数存入临时数组，相应指针向后移动（ i 和 j 中指向较小数的那个，以及临时数组的指针 k）。不断重复上述比较和写入操作，直至一个有序序列已经遍历完成（指针 i 到达 mid 处，或指针 j 到达 r 处）时停止。如果另一有序序列仍存在未写入临时数组的数据，则再将这些数据依次写入临时数组的尾部。最终得到的临时数组，即为两个有序序列归并得到的最终有序序列。</p>
<img src="/2022/10/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/5.png" class="">

<h2 id="归并排序模板题（AcWing-787-归并排序）"><a href="#归并排序模板题（AcWing-787-归并排序）" class="headerlink" title="归并排序模板题（AcWing 787. 归并排序）"></a>归并排序模板题（AcWing 787. 归并排序）</h2><img src="/2022/10/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/6.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>,tmp[N];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序是稳定的</p>
<p>时间复杂度为O(nlogn)</p>
<h2 id="奇怪的知识（关于C-）-1"><a href="#奇怪的知识（关于C-）-1" class="headerlink" title="奇怪的知识（关于C++）"></a>奇怪的知识（关于C++）</h2><p>C++其实自带排序函数——sort()</p>
<p>用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(q,q+n);</span><br></pre></td></tr></table></figure>

<p>经测试验证，上述的快速排序和归并排序算法与sort()函数的时间开销几乎一致</p>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-高精度</title>
    <url>/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<p>本篇博客简单记录了基础算法学习中的<strong>高精度加法、减法、乘法、除法</strong>的相关内容（AcWing-day3）</p>
<span id="more"></span>

<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><p>只有C++需要掌握高精度，Java和Python不需要掌握，因为它们自带了函数</p>
<p>高精度在面试中基本不考，在笔试中偶尔出现</p>
<p>以下介绍四种常见的高精度情况（模板中默认A、B均为正数）：</p>
<img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/1.png" class="">

<p>A+B（两个大整数相加，A和B的位数大约为10^6）</p>
<p>A-B（两个大整数相减，A和B的位数大约为10^6）</p>
<p>A*a（一个大整数与一个小整数相乘，A的位数小于等于10^6，a的数值小于10^9）</p>
<p>A÷b（一个大整数与一个小整数相除，A的位数小于等于10^6，a的数值小于10^9）</p>
<h1 id="奇怪的知识（关于C-）"><a href="#奇怪的知识（关于C-）" class="headerlink" title="奇怪的知识（关于C++）"></a>奇怪的知识（关于C++）</h1><h2 id="大整数如何存储"><a href="#大整数如何存储" class="headerlink" title="大整数如何存储"></a>大整数如何存储</h2><p>把每一位存到数组里，从大整数的低位开始存储，即数组的 0 下标位存储大整数的个位，数组的 1 下标位存储大整数的十位，以此类推……</p>
<h2 id="如何表示大整数"><a href="#如何表示大整数" class="headerlink" title="如何表示大整数"></a>如何表示大整数</h2><p>在C++中，一般比较喜欢用 vector 来表示大整数，因为 vector 自带 size() 函数，可以表示数组的长度</p>
<p><code>\#include &lt;vector&gt;</code></p>
<h2 id="算法和工程的区别"><a href="#算法和工程的区别" class="headerlink" title="算法和工程的区别"></a>算法和工程的区别</h2><p>算法和工程是不一样的。写算法时的目标是能在短时间内降低错误率，提高自己通关的效率；写工程则是能省则省（空间、时间）</p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>在C++11标准的语法中，auto被定义为编译器自动推断变量的类型。auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型</p>
<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><h2 id="大整数如何相加"><a href="#大整数如何相加" class="headerlink" title="大整数如何相加"></a>大整数如何相加</h2><p>从低位开始逐位相加，除两个大整数的对应位相加外，还需要加上对应的进位，第一位相加时可以认为进位为0。每一位的进位由前一位的加和模10得到</p>
<h2 id="高精度加法模板题（AcWing-791-高精度加法）"><a href="#高精度加法模板题（AcWing-791-高精度加法）" class="headerlink" title="高精度加法模板题（AcWing 791. 高精度加法）"></a>高精度加法模板题（AcWing 791. 高精度加法）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/2.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C=A+B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||i&lt;B.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t+=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a=&#x27;123456&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>); <span class="comment">// A=[6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><h2 id="大整数如何相减"><a href="#大整数如何相减" class="headerlink" title="大整数如何相减"></a>大整数如何相减</h2><p>高精度减法的模板需要保证A&gt;&#x3D;B，所以，如果A&gt;&#x3D;B就直接减，如果A&lt;B，则需要转换成-(B-A)。从低位开始逐位相减，除两个大整数的对应位相减外，还需减去对应的借位。如果以上结果大于等于0，那么此结果即为该位的最终结果；如果以上结果小于0，那么此结果+10才为最终结果。</p>
<h2 id="高精度减法模板题（AcWing-792-高精度减法）"><a href="#高精度减法模板题（AcWing-792-高精度减法）" class="headerlink" title="高精度减法模板题（AcWing 792. 高精度减法）"></a>高精度减法模板题（AcWing 792. 高精度减法）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/3.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C=A-B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 借位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=A[i]-t;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t-=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t=<span class="number">1</span>; <span class="comment">// 需要借位</span></span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>; <span class="comment">// 不需要借位</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a=&#x27;123456&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>); <span class="comment">// A=[6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C=<span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C=<span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h1><h2 id="大整数和小整数如何相乘"><a href="#大整数和小整数如何相乘" class="headerlink" title="大整数和小整数如何相乘"></a>大整数和小整数如何相乘</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/4.png" class="">

<h2 id="高精度乘法模板题（AcWing-793-高精度乘法）"><a href="#高精度乘法模板题（AcWing-793-高精度乘法）" class="headerlink" title="高精度乘法模板题（AcWing 793. 高精度乘法）"></a>高精度乘法模板题（AcWing 793. 高精度乘法）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/5.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C=A×B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i]*b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 去掉前导0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a=&#x27;123456&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>); <span class="comment">// A=[6,5,4,3,2,1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">mul</span>(A,b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h1><h2 id="大整数和小整数如何相除"><a href="#大整数和小整数如何相除" class="headerlink" title="大整数和小整数如何相除"></a>大整数和小整数如何相除</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/6.png" class="">

<h2 id="高精度除法模板题（AcWing-794-高精度除法）"><a href="#高精度除法模板题（AcWing-794-高精度除法）" class="headerlink" title="高精度除法模板题（AcWing 794. 高精度除法）"></a>高精度除法模板题（AcWing 794. 高精度除法）</h2><img src="/2022/10/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/7.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 使用reverse()需引入</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C=A÷B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> &amp;b,<span class="type">int</span> &amp;r)</span> <span class="comment">//A,b,r都是引用传回去</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">// 商</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r=r*<span class="number">10</span>+A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>()); <span class="comment">// 这里reverse和第36行输出时的写法有关</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 去掉前导0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a=&#x27;123456&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>); <span class="comment">// A=[6,5,4,3,2,1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>; <span class="comment">// 初始余数为0</span></span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">div</span>(A,b,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    cout &lt;&lt; endl&lt;&lt; r &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-KMP</title>
    <url>/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP/</url>
    <content><![CDATA[<p>本篇博客简单记录了数据结构学习中的<strong>KMP</strong>的相关内容（AcWing-day9）</p>
<span id="more"></span>

<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1000010</span>, N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s[M]是匹配串（长串），p[N]是模式串（短串）</span></span><br><span class="line"><span class="type">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="comment">// KMP中一般习惯下标从1开始</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i + j - <span class="number">1</span>] != p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用-next-数组"><a href="#利用-next-数组" class="headerlink" title="利用 next 数组"></a>利用 next 数组</h2><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP/1.png" class="">

<p>next[i] &#x3D; j 的含义是模式串 p 的 [1, i] 段子串的最大前缀和后缀相等长度为 j，此外易知 next[1] &#x3D; 0</p>
<img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP/2.png" class="">

<h2 id="AcWing-831-KMP字符串"><a href="#AcWing-831-KMP字符串" class="headerlink" title="AcWing 831. KMP字符串"></a>AcWing 831. KMP字符串</h2><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP/3.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 不用next而用ne是因为next数组在C++的某个头文件中用过，如果用next就可能会在某些时候引发报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>; <span class="comment">// 因为我们让p数组和s数组的下标均从1开始，所以此处为p+1和s+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求模式串的next数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) <span class="comment">// 因为易知next[1]为0，所以求next数组从i=2开始即可，注意此处j从0开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j]; <span class="comment">// 根据ne[j]的值对j进行前移，避免从头开始比较</span></span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// KMP匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) <span class="comment">// 注意此处j从0开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j]; <span class="comment">// 根据ne[j]的值对j进行前移，避免从头开始比较</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n); <span class="comment">// 因为题目的输出要求下标从0开始，所以此处是i-n而不是i-n+1</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
    <content><![CDATA[<p>本篇博客简单记录了数据结构学习中的<strong>堆</strong>的相关内容（AcWing-day12）</p>
<span id="more"></span>

<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>此处所讲的堆不是 STL 中的堆（就是优先队列），而是我们自己如何去手写一个堆</p>
<p>堆是维护一个数据集合，堆最常见的三个操作（也是 STL 中堆可以支持的三个操作）：</p>
<ol>
<li><p>向堆中插入一个数</p>
</li>
<li><p>求堆中的最小值</p>
</li>
<li><p>删除堆中的最小值</p>
</li>
</ol>
<p>其实还有两个操作也是我们可以支持的（这两个操作在 STL 的堆中是无法直接实现的，当然间接还是可以实现的）</p>
<ol start="4">
<li><p>删除堆中的任意一个元素</p>
</li>
<li><p>修改堆中的任意一个元素</p>
</li>
</ol>
<h2 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h2><p>堆是一棵完全二叉树（除最后一层结点外，其余所有结点都是非空的，并且最后一层结点是从左至右依次排布）</p>
<p>堆满足一个基本性质，以小根堆为例：堆中的每一个结点均小于等于它的左右儿子结点，根结点就是整个堆中的最小值</p>
<h2 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h2><p>用一个一维数组来存（凡是堆状的数据结构都是这么存的）</p>
<img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/1.png" class="">

<p>下标 1 存根结点（下标从 1 开始比较方便），x 结点的左儿子结点是 2x ，x 结点的右儿子结点是 2x+1 （所以下标 2 存根结点的左儿子，下标 3 存根结点的右儿子）</p>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>堆有两个基本操作（上面提到的五个操作完全可以由以下两个基本操作组合实现）</p>
<ol>
<li><p>down(x) 如果 x 结点的值变大了，就需要 down 操作来把 x 结点往下移</p>
</li>
<li><p>up(x) 如果 x 结点的值变小了，就需要 up 操作来把 x 结点往上移</p>
</li>
</ol>
<p>时间复杂度都是 O(log n)</p>
<p>下面看如何利用 down 和 up 这两基本操作来实现上面提到的五个操作</p>
<p>用 heap 表示堆，用 size 表示当前堆的大小</p>
<h3 id="向堆中插入一个数"><a href="#向堆中插入一个数" class="headerlink" title="向堆中插入一个数"></a>向堆中插入一个数</h3><p>把数插到堆的最后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">heap[++ size] = x;</span><br><span class="line">up[size];</span><br></pre></td></tr></table></figure>

<h3 id="求堆中的最小值"><a href="#求堆中的最小值" class="headerlink" title="求堆中的最小值"></a>求堆中的最小值</h3><p>堆（小根堆）中的最小值就是堆顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">heap[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="删除堆中的最小值"><a href="#删除堆中的最小值" class="headerlink" title="删除堆中的最小值"></a>删除堆中的最小值</h3><p>用堆中的最后一个元素覆盖堆顶元素，然后去掉最后一个元素（ size – ），最后再把堆顶元素 down 一遍即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">heap[<span class="number">1</span>] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="删除堆中的任意一个元素"><a href="#删除堆中的任意一个元素" class="headerlink" title="删除堆中的任意一个元素"></a>删除堆中的任意一个元素</h3><p>和删除堆中的最小值操作类似，不过需要注意的是，当用堆中的最后一个元素覆盖当前需要删除的元素后，需要判断是执行 down 操作还是 up 操作，不过总归两个操作只能执行其中一个，所以不妨在代码里都写上（为了简化代码就不判断了，这其实也是一种很实用的技巧）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">heap[k] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure>

<h3 id="修改堆中的任意一个元素"><a href="#修改堆中的任意一个元素" class="headerlink" title="修改堆中的任意一个元素"></a>修改堆中的任意一个元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">heap[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-838-堆排序"><a href="#AcWing-838-堆排序" class="headerlink" title="AcWing 838. 堆排序"></a>AcWing 838. 堆排序</h2><img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/2.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], Size; <span class="comment">// h[]就是heap[]，Size就是当前heap中的元素个数，注意这里也不能用size会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// down操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u; <span class="comment">// 用t来表示u结点和它的两个子结点中的最小值</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= Size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>; <span class="comment">// 如果u结点有左儿子且左儿子的值小于t结点，那么就让t等于u结点的左儿子</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= Size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 如果u结点有右儿子且右儿子的值小于t结点，那么就让t等于u结点的右儿子</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t); <span class="comment">// 交换位置后可能会出现新的不平衡，所以还需要继续down</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// up操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &lt; h[u]) <span class="comment">// 如果u结点有父亲结点且父亲结点的值小于u结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    Size = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆排序（建堆），一开始是树，排序后才成堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i --) <span class="built_in">down</span>(i); <span class="comment">// 从树的倒数第2层开始down，可以证明时间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出并删除堆中的最小值，然后重新形成有序堆</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[Size];</span><br><span class="line">        Size -- ;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-839-模拟堆"><a href="#AcWing-839-模拟堆" class="headerlink" title="AcWing 839. 模拟堆"></a>AcWing 839. 模拟堆</h2><img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/3.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], Size; <span class="comment">// h[]就是heap[]，Size就是当前heap中的元素个数，注意这里也不能用size会报错</span></span><br><span class="line"><span class="type">int</span> ph[N], hp[N]; <span class="comment">// ph[k]存的是第k个插入的数在堆中的下标，hp[k]存的是堆中的第k个结点是第几个插入的数，相当于是ph[k]反过来存，对这两个映射关系进行维护是一个难点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 此时交换堆中的两个结点就不仅仅是交换两个值了，所以需要定义一个全新的交换操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); <span class="comment">// ph指向的交换</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]); <span class="comment">// ph交换后，hp的指向也要相应交换</span></span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]); <span class="comment">// 最后是结点的交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// down操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u; <span class="comment">// 用t来表示u结点和它的两个子结点中的最小值</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= Size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>; <span class="comment">// 如果u结点有左儿子且左儿子的值小于t结点，那么就让t等于u结点的左儿子</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= Size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 如果u结点有右儿子且右儿子的值小于t结点，那么就让t等于u结点的右儿子</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t); <span class="comment">// 交换位置后可能会出现新的不平衡，所以还需要继续down</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// up操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u]) <span class="comment">// 如果u结点有父亲结点且父亲结点的值大于u结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            Size ++ ;</span><br><span class="line">            m ++ ;</span><br><span class="line">            ph[m] = Size, hp[Size] = m;</span><br><span class="line">            h[Size] = x;</span><br><span class="line">            <span class="built_in">up</span>(Size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, Size);</span><br><span class="line">            Size -- ;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, Size);</span><br><span class="line">            Size -- ;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-Trie</title>
    <url>/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie/</url>
    <content><![CDATA[<p>本篇博客简单记录了数据结构学习中的<strong>Trie树</strong>的相关内容（AcWing-day10）</p>
<span id="more"></span>

<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>Trie树是用来高效地存储和查找字符串集合的数据结构</p>
<p>凡是用到Trie树的题目，字符串一般来说要么都是小写字母，要么都是大写字母，要么都是数字，要么都是0和1，总之符号的类型和个数不会很多（字符串是中文基本不大可能，要做也能做，就是换成二进制来存）</p>
<h2 id="Trie树的存储"><a href="#Trie树的存储" class="headerlink" title="Trie树的存储"></a>Trie树的存储</h2><img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie/1.png" class="">

<p>首先Trie树有一个根结点（root），然后依次根据每个字符串中的字符次序创建相应结点（如果已经有对应结点就不再重复创建），最后在每个字符串的结尾字符结点处做上标记，表示存在一个字符串以该字符结点结尾</p>
<h2 id="Trie树的查找"><a href="#Trie树的查找" class="headerlink" title="Trie树的查找"></a>Trie树的查找</h2><p>以上图为例，查找“aced”、“abcf”、“abcd”</p>
<ol>
<li>查找“aced”</li>
</ol>
<p>从根结点出发，找到根结点下的“a”结点，再找到“a”结点下的“c”结点，再找到“c”结点下的“e”结点，最后找到“e”结点下的“d”结点，此时需要查找的字符串已经遍历完，然后可以发现“d”结点处有标记，说明存在一个字符串以“d”结点结尾，所以可以认为在原字符串集合中存在此时所查找的“aced”字符串</p>
<ol start="2">
<li>查找“abcf”</li>
</ol>
<p>同理，在顺利到达“c”结点后，我们发现“c”结点下不存在“f”结点，所以可以认为在原字符串集合中不存在此时所查找的“abcf”字符串</p>
<ol start="3">
<li>查找“abcd”</li>
</ol>
<p>同理，在顺利到达“d”结点后，我们发现需要查找的字符串已经遍历完，但“d”结点处没有标记，所以可以认为在原字符串集合中不存在此时所查找“abcd”字符串</p>
<h2 id="AcWing-835-Trie字符串统计"><a href="#AcWing-835-Trie字符串统计" class="headerlink" title="AcWing 835. Trie字符串统计"></a>AcWing 835. Trie字符串统计</h2><img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie/2.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// son数组就是Trie树，其中每个结点最多可能有26个子结点（题目说字符串仅包含小写英文字母）</span></span><br><span class="line"><span class="comment">// cnt数组统计各结点处以该结点为结尾的字符串个数</span></span><br><span class="line"><span class="comment">// idx 指向下一个待用的结点下标（和单链表中的idx是一个东西），下标是0的点既是根结点也是空结点</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span> <span class="comment">// 插入操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">// 从Trie树的根结点开始查找字符串中各字符应该插入的位置，p为当前结点（初始为根结点）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) <span class="comment">// 依次遍历字符串中的每个字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 将每个字符（小写字母a到z）映射为0-25的数组下标</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++ idx; <span class="comment">// 如果当前结点不存在上述字符所对应的子结点，就在Trie树中插入（创建）此结点（新的结点）</span></span><br><span class="line">        p = son[p][u]; <span class="comment">// 将当前结点位置移到相应子结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt[p] ++ ; <span class="comment">// 最终，p来到了字符串中最后一个字符所在的结点，更新统计</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span> <span class="comment">// 查询操作和插入操作其实非常类似</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">// 还是从根结点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果当前结点不存在上述字符所对应的子结点，即说明Trie树（字符串集合）中不存在该字符串，返回0</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt[p]; <span class="comment">// 如果能在Trie树（字符串集合）中找到此处查询的字符串，那么就返回其当前为止出现的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>]; <span class="comment">// op[0]是I或Q，op[1]是空格</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op ,str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-143-最大异或对"><a href="#AcWing-143-最大异或对" class="headerlink" title="AcWing 143. 最大异或对"></a>AcWing 143. 最大异或对</h2><img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie/3.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">31</span> * N; <span class="comment">// Trie树一共存N个数，每个数最多需要31个结点，所以Trie树最多需要31*N个结点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])</span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res * <span class="number">2</span> + !u; <span class="comment">// *2相当于左移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * <span class="number">2</span> + u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(a[i]); <span class="comment">// 先插入</span></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">query</span>(a[i]); <span class="comment">// 再查询</span></span><br><span class="line">        <span class="comment">// 先插入再查询主要是为了处理边界问题（当Trie树为空时）</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, a[i] ^ t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-并查集</title>
    <url>/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>本篇博客简单记录了数据结构学习中的<strong>并查集</strong>的相关内容（AcWing-day11）</p>
<span id="more"></span>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是面试、笔试和比赛中都非常容易考察的一个数据结构，因为它的代码很短，但是思路都非常精巧</p>
<p>并查集的作用是来快速地支持以下两个操作（在近乎 O(1) 的时间内）：</p>
<ol>
<li><p>将两个集合合并</p>
</li>
<li><p>查询两个元素是否在一个集合当中</p>
</li>
</ol>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>每个集合用一棵树来表示，树根结点的编号就是整个集合的编号。每个结点存储它的父结点，p[x]表示 x 的父结点，根结点的父结点是本身（即 p[x] &#x3D; x ）</p>
<p><strong>问题1：如何判断一个结点是否为树的根结点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[x] == x)</span><br></pre></td></tr></table></figure>

<p><strong>问题2：如何求x结点所在集合的编号</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p[x] != x) x = p[x];</span><br></pre></td></tr></table></figure>

<p><strong>问题3：如何合并两个集合</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">假设其中一个集合的根结点是x，另一个集合的根结点是y，就让p[x] = y，即让y成为x的父结点</span><br></pre></td></tr></table></figure>

<p>如果仅仅只是以上这样，时间复杂度还是挺高的，因为“求x结点所在集合的编号”这一步所耗费的时间会很多。所以我们还需要引入一个很关键的优化，叫“路径压缩”。路径压缩是指，当我们完成一遍查找集合编号的操作时，就把查找路径上所有经过的结点（除根结点）的父结点指向根结点。经过以上优化，并查集的两个操作的时间复杂度就可以近乎 O(1) 了</p>
<h2 id="AcWing-836-合并集合"><a href="#AcWing-836-合并集合" class="headerlink" title="AcWing 836. 合并集合"></a>AcWing 836. 合并集合</h2><img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// p[]存储每个结点的父结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回x结点的祖宗结点（内含路径压缩优化）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find函数是并查集中最核心的操作，此类题目只用背过find函数即可</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">// 如果x结点不是根结点，那么就让x结点的父结点等于它的祖宗结点</span></span><br><span class="line">    <span class="keyword">return</span> p[x]; <span class="comment">// 最后返回x结点的父结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i; <span class="comment">// 初始化各根结点（因为题目说最开始每个数各自在一个集合中）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>]; <span class="comment">// 因为下面的scanf中是用字符串来读，所以此处不能是char op，而必须是char op[2]才行</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="comment">// scanf读字符串时(%s)会自动忽略字符串末尾的空格和回车，因此哪怕只用scanf读一个字符，也建议读成字符串的形式，这是C++的一个小技巧</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); <span class="comment">// 使b结点的祖宗结点成为a结点的祖宗结点的父结点，从而实现两个集合合并的目的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-837-连通块中点的数量"><a href="#AcWing-837-连通块中点的数量" class="headerlink" title="AcWing 837. 连通块中点的数量"></a>AcWing 837. 连通块中点的数量</h2><img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// p[]存储每个结点的父结点</span></span><br><span class="line"><span class="type">int</span> Size[N]; <span class="comment">// Size[]存储每个连通块（集合）中结点的数量，只需保证根结点的Size有意义即可</span></span><br><span class="line"><span class="comment">// 一个奇怪的点，此处如果用size会报一堆奇奇怪怪的错，怀疑是引入的头文件中有size这个数组，改成Size就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回x结点的祖宗结点（内含路径压缩优化）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果x结点（当前结点）不是根结点，那么就返回x结点父结点的祖宗结点，相当于往上走了一层</span></span><br><span class="line">    <span class="comment">// 每次只要x结点（当前结点）不是根结点，就往上走一层，直到走到根结点为止</span></span><br><span class="line">    <span class="comment">// 在递归回溯的时候，就会让路径上的所有结点的父结点指向根结点</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i; <span class="comment">// 初始化各根结点</span></span><br><span class="line">        Size[i] = <span class="number">1</span>; <span class="comment">// 初始时各连通块中只有1个点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>]; <span class="comment">// 因为下面的scanf中是用字符串来读，所以此处不能是char op，而必须是char op[5]才行</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="comment">// scanf读字符串时(%s)会自动忽略字符串末尾的空格和回车，因此哪怕只用scanf读一个字符，也建议读成字符串的形式，这是C++的一个小技巧</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>; <span class="comment">// 如果a和b本身就在一个集合中，就不需要进行下面的操作了</span></span><br><span class="line">            Size[<span class="built_in">find</span>(b)] += Size[<span class="built_in">find</span>(a)]; <span class="comment">// 在新的根结点上加上需要合并的结点的个数</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); <span class="comment">// 使b结点的祖宗结点成为a结点的祖宗结点的父结点，从而实现两个集合合并的目的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Size[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-240-食物链"><a href="#AcWing-240-食物链" class="headerlink" title="AcWing 240. 食物链"></a>AcWing 240. 食物链</h2><p>维护的是每一个结点到根结点的距离，个人感觉还是挺难的</p>
<img src="/2022/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/3.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) res ++ ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) res ++ ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈和队列</title>
    <url>/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本篇博客简单记录了数据结构学习中的<strong>栈和队列</strong>的相关内容（AcWing-day8）</p>
<span id="more"></span>

<p>这里主要介绍用数组模拟栈和队列。用数组模拟栈和队列，相比 STL 来说，有个致命的好处，就是速度快。一般开了 O2 或 O3 优化后，两者速度才会相差无几</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈——先进后出</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tt表示栈顶，初始时栈为空，tt为0</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line"><span class="comment">// 栈中第一个元素存于stk[0]还是stk[1]全凭个人喜好</span></span><br><span class="line">stk[ ++ tt] = x; <span class="comment">// 此时栈中第一个元素存于stk[1]，栈中第二个元素存于stk[2]，以此类推……stk[0]为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询栈顶元素</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-828-模拟栈"><a href="#AcWing-828-模拟栈" class="headerlink" title="AcWing 828. 模拟栈"></a>AcWing 828. 模拟栈</h2><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/1.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tt表示栈顶，初始时栈为空，tt为0</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            stk[ ++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) tt -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tt &gt; <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; stk[tt] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-3302-表达式求值"><a href="#AcWing-3302-表达式求值" class="headerlink" title="AcWing 3302. 表达式求值"></a>AcWing 3302. 表达式求值</h2><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.png" class="">

<p>这题还是挺难的，值得反复做</p>
<p>将表达式转换成表达式树，表达式树中所有的内部结点都是运算符，所有的叶子结点都是数。题目所给表达式为中缀表达式，是整棵树的中序遍历</p>
<p>如何判断某棵子树被遍历完？当前运算符的优先级小于等于上一个运算符的优先级，可以说明该运算符所在子树已被遍历完，就可以计算该子树的值了。括号单独考虑，遇到右括号时从右往左把括号内的所有运算符操作一遍即可</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">// 这题需要用到栈</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span> <span class="comment">// 这题还需要用到哈希表</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num; <span class="comment">// 存数字</span></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op; <span class="comment">// 存运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作最后一个运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先取b再取a，因为b是倒数第一个数，a是倒数第二个数，顺序不能变</span></span><br><span class="line">    <span class="keyword">auto</span> b = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> a = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>(); <span class="comment">// 再取运算符</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>) x = a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) x = a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) x = a * b;</span><br><span class="line">    <span class="keyword">else</span> x = a / b;</span><br><span class="line">    <span class="comment">// else if (c == &#x27;^&#x27;) x = a ^ b;</span></span><br><span class="line">    num.<span class="built_in">push</span>(x); <span class="comment">// 结果入栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;; <span class="comment">// 定义一个哈希表，规定每个运算符的优先级，数字越大优先级越大</span></span><br><span class="line">    <span class="comment">// 如果表达式中还涉及乘方运算</span></span><br><span class="line">    <span class="comment">// unordered_map&lt;char, int&gt; pr&#123;&#123;&#x27;+&#x27;, 1&#125;, &#123;&#x27;-&#x27;, 1&#125;, &#123;&#x27;*&#x27;, 2&#125;, &#123;&#x27;/&#x27;, 2&#125;, &#123;&#x27;^&#x27;, 3&#125;&#125;;</span></span><br><span class="line">    string str; <span class="comment">// 定义表达式</span></span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="comment">// 如果当前字符是数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">                x = x * <span class="number">10</span> + str[j ++ ] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i = j - <span class="number">1</span>; <span class="comment">// 不要忘了更新i</span></span><br><span class="line">            num.<span class="built_in">push</span>(x); <span class="comment">// x入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c); <span class="comment">// 如果当前字符是左括号，则直接入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="comment">// 如果当前字符是右括号，则需要把栈中所有的运算符从右往左操作一遍，直至遇到左括号为止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>(); <span class="comment">// eval就是用末尾的运算符去操作末尾的两个数</span></span><br><span class="line">            op.<span class="built_in">pop</span>(); <span class="comment">// 将左括号弹出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果当前字符是一般运算符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c]) <span class="built_in">eval</span>(); <span class="comment">// 如果栈非空且栈顶元素的优先级大于等于当前元素的优先级，那么就操作一下栈顶元素</span></span><br><span class="line">            op.<span class="built_in">push</span>(c); <span class="comment">// 否则将当前元素入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (op.<span class="built_in">size</span>()) <span class="built_in">eval</span>(); <span class="comment">// 最后把所有没操作完的运算符从右往左操作一遍</span></span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 最后栈顶元素就是我们要求的答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h1><p>队列——先进先出</p>
<h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hh 表示队头，tt 表示队尾，初始时队列为空，hh为0，tt为-1</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line"><span class="comment">// 队列中第一个元素存于q[0]还是q[1]全凭个人喜好</span></span><br><span class="line">q[ ++ tt] = x; <span class="comment">// 此时队列中第一个元素存于q[0]，队列中第二个元素存于q[1]，以此类推……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实用数组模拟队列时，还能取队尾的值</span></span><br><span class="line"><span class="comment">// q[tt];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-829-模拟队列"><a href="#AcWing-829-模拟队列" class="headerlink" title="AcWing 829. 模拟队列"></a>AcWing 829. 模拟队列</h2><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/3.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hh 表示队头，tt 表示队尾，初始时队列为空，hh为0，tt为-1</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[ ++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) hh ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hh &lt;= tt) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h1><p>单调栈和单调队列虽然很抽象，但能考察的题型非常少</p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈最主要的一个应用就是：给定一个序列，求出序列中每一个数的左边第一个比它小的数（基础模型，可以有很多变体）</p>
<p>示例：</p>
<img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/4.png" class="">

<h2 id="AcWing-830-单调栈"><a href="#AcWing-830-单调栈" class="headerlink" title="AcWing 830. 单调栈"></a>AcWing 830. 单调栈</h2><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/5.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x) tt --; <span class="comment">// 如果此时栈不为空，且栈顶元素大于等于x，则弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 如果此时栈不为空，即说明找到了x左边第一个比它小的数，进行输出</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        stk[++ tt] = x; <span class="comment">// 最后需要把x插到栈顶</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为每个元素最多只会进栈一次和出栈一次，所以整个算法的时间复杂度是O(n)</p>
<p>输入输出还是建议使用 scanf 和 printf ，要比 cin 和 cout 快10倍左右。需要注意，使用 scanf 和 printf 要引入头文件 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/6.png" class="">

<p>除非加上 cin.tie(0) 和 ios::sync_with_stdio(false) ，可以做到和 scanf 和 printf 相近的时耗</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/7.png" class="">

<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列最经典的一个应用就是：求滑动窗口中的最大值或最小值</p>
<h2 id="AcWing-154-滑动窗口"><a href="#AcWing-154-滑动窗口" class="headerlink" title="AcWing 154. 滑动窗口"></a>AcWing 154. 滑动窗口</h2><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/8.png" class="">

<p>个人感觉还挺难的</p>
<p>我们以求最小值为例，从左到右扫描整个序列，用一个队列来维护最近 k 个元素</p>
<p>如果用暴力解法，就是每次都遍历一遍队列中的所有元素，找出其中的最小值即可，但这样的时间复杂度很高，为O(nk)</p>
<p>我们可以尝试利用这样一个性质：如果队列中存在两个元素，满足 a[i] &gt;&#x3D; a[j] 且 i &lt; j，那么无论什么时候我们都不会再取 a[i] 作为最小值，所以就可以直接将 a[i] 删除；此时队列中剩余的元素严格单调递增，所以队头就是整个队列中的最小值，我们用 O(1) 的时间就能找到。为了维护队列的这个性质，我们在往队尾插入元素之前，需要先将队尾大于等于当前数的元素全部弹出；这样所有数均只进队一次，出队一次，所以算法整体的时间复杂度是O(n)</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N], q[N]; <span class="comment">// q[N]是实际窗口向右滑动时维护的一个单调队列，存的是a[N]中的下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找滑动窗口中的最小值</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; <span class="comment">// 初始化，hh表示队头，tt表示队尾。hh和a数组下标的起始点需保持一致</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="comment">// i表示滑动窗口的右端点下标，可以推出此时左端点下标应为i-k+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// q[hh]存的是窗口中数值最小的元素的下标</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++; <span class="comment">// 若q[hh]（队头元素的下标）已从滑动窗口左端点移出，则需要h++指向新的队头</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; <span class="comment">// 若队尾元素的值a[q[tt]]&gt;=滑动窗口右端点的值a[i]，那么为了维护队列的单调，此时需要删除队尾</span></span><br><span class="line">        q[ ++ tt] = i; <span class="comment">// 直到队尾元素比窗口右端点的值小，即a[q[tt]]&lt;a[i]，再将窗口右端点的下标i入队</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]); <span class="comment">// 窗口是从数组a中的第一个元素a[0]开始吞入，故要等到窗口中的元素满了才可输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找滑动窗口中的最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 以下同理</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; <span class="comment">// 只需将这里改为&lt;=即可</span></span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>本篇博客简单记录了数据结构学习中的<strong>链表</strong>的相关内容（AcWing-day7）</p>
<span id="more"></span>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>这里暂不介绍“结构体 + 指针”实现链表的方式（这种方式在面试题中较为常见，但在笔试题中用的很多，因为new Node()操作在实际使用中非常慢，很容易超时）</p>
<img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/1.png" class="">

<p>这里我们主要介绍用数组模拟链表（也称为静态链表，适用于算法题，最大的好处就是快；写工程多用动态链表，删除结点时一般会把相应的空间也释放掉）</p>
<h2 id="数组模拟单链表"><a href="#数组模拟单链表" class="headerlink" title="数组模拟单链表"></a>数组模拟单链表</h2><p>单链表中用的最多的是邻接表，邻接表最主要的应用是存储图和树</p>
<img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/2.png" class="">

<h3 id="如何用数组模拟单链表"><a href="#如何用数组模拟单链表" class="headerlink" title="如何用数组模拟单链表"></a>如何用数组模拟单链表</h3><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/3.png" class="">

<p>head 表示头结点的下标，e[N] 是 value 数组，ne[N] 是 next 数组，空结点的下标用 -1 表示</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示结点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示结点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 指向下一个待用的结点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将值为x的新结点插到链表头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x; <span class="comment">// 为新结点赋值</span></span><br><span class="line">    ne[idx] = head; <span class="comment">// 原来的头结点成为新结点的next结点</span></span><br><span class="line">    head = idx; <span class="comment">// 新结点成为头结点</span></span><br><span class="line">    idx ++ ; <span class="comment">// 新结点头插操作已完成，idx移到下一个待用的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将值为x的新结点插到下标为k的结点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x; <span class="comment">// 为新结点赋值</span></span><br><span class="line">    ne[idx] = ne[k]; <span class="comment">// k结点的next结点成为新结点的next结点</span></span><br><span class="line">    ne[k] = idx; <span class="comment">// 新结点成为k结点的next结点</span></span><br><span class="line">    idx ++ ; <span class="comment">// 新结点插入操作已完成，idx移到下一个待用的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标为k的结点的next结点删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-826-单链表"><a href="#AcWing-826-单链表" class="headerlink" title="AcWing 826. 单链表"></a>AcWing 826. 单链表</h3><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/4.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示结点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示结点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 指向下一个待用的结点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将值为x的新结点插到链表头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x; <span class="comment">// 为新结点赋值</span></span><br><span class="line">    ne[idx] = head; <span class="comment">// 原来的头结点成为新结点的next结点</span></span><br><span class="line">    head = idx; <span class="comment">// 新结点成为头结点</span></span><br><span class="line">    idx ++ ; <span class="comment">// 新结点头插操作已完成，idx移到下一个待用的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将值为x的新结点插到下标为k的结点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x; <span class="comment">// 为新结点赋值</span></span><br><span class="line">    ne[idx] = ne[k]; <span class="comment">// k结点的next结点成为新结点的next结点</span></span><br><span class="line">    ne[k] = idx; <span class="comment">// 新结点成为k结点的next结点</span></span><br><span class="line">    idx ++ ; <span class="comment">// 新结点插入操作已完成，idx移到下一个待用的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标为k的结点的next结点删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组模拟双链表"><a href="#数组模拟双链表" class="headerlink" title="数组模拟双链表"></a>数组模拟双链表</h2><p>双链表一般用来优化某些问题</p>
<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e[i]表示结点i的值</span></span><br><span class="line"><span class="comment">// l[i]表示结点i的前驱结点(左结点)的下标</span></span><br><span class="line"><span class="comment">// r[i]表示结点i的后继结点(右结点)的下标</span></span><br><span class="line"><span class="comment">// idx 指向下一个待用的结点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里偷个懒，用0表示左边界结点(head)，用1表示右边界结点(tail)</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化时，0结点的右结点为1结点</span></span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 初始化时，1结点的左结点为0结点</span></span><br><span class="line">    idx = <span class="number">2</span>; <span class="comment">// 下标为0和1的结点均已使用，所以idx从2开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新结点插到下标为k的结点的右边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x; <span class="comment">// 为新结点赋值</span></span><br><span class="line">    r[idx] = r[k]; <span class="comment">// 原k结点的右结点成为新结点的右结点</span></span><br><span class="line">    l[idx] = k; <span class="comment">// k结点成为新结点的左结点</span></span><br><span class="line">    </span><br><span class="line">    l[r[k]] = idx; <span class="comment">// 新结点成为原k结点的右结点的左结点</span></span><br><span class="line">    r[k] = idx ++ ; <span class="comment">// 新结点成为k结点的右结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新结点插到下标为k的结点的左边，相当于将新结点插到k结点的左结点的右边</span></span><br><span class="line"><span class="comment">// 即 add(l[k], x);</span></span><br><span class="line"><span class="comment">// 因此双链表的插入操作只需实现一个即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除下标为k的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k]; <span class="comment">// k结点的右结点成为k结点左结点的右结点</span></span><br><span class="line">    l[r[k]] = l[k]; <span class="comment">// k结点的左结点成为k结点右结点的左结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-827-双链表"><a href="#AcWing-827-双链表" class="headerlink" title="AcWing 827. 双链表"></a>AcWing 827. 双链表</h3><img src="/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/5.png" class="">

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e[i]表示结点i的值</span></span><br><span class="line"><span class="comment">// l[i]表示结点i的前驱结点(左结点)的下标</span></span><br><span class="line"><span class="comment">// r[i]表示结点i的后继结点(右结点)的下标</span></span><br><span class="line"><span class="comment">// idx 指向下一个待用的结点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里偷个懒，用0表示左边界结点(head)，用1表示右边界结点(tail)</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化时，0结点的右结点为1结点</span></span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 初始化时，1结点的左结点为0结点</span></span><br><span class="line">    idx = <span class="number">2</span>; <span class="comment">// 下标为0和1的结点均已使用，所以idx从2开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新结点插到下标为k的结点的右边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x; <span class="comment">// 为新结点赋值</span></span><br><span class="line">    r[idx] = r[k]; <span class="comment">// 原k结点的右结点成为新结点的右结点</span></span><br><span class="line">    l[idx] = k; <span class="comment">// k结点成为新结点的左结点</span></span><br><span class="line">    </span><br><span class="line">    l[r[k]] = idx; <span class="comment">// 新结点成为原k结点的右结点的左结点</span></span><br><span class="line">    r[k] = idx ++ ; <span class="comment">// 新结点成为k结点的右结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新结点插到下标为k的结点的左边，相当于将新结点插到k结点的左结点的右边</span></span><br><span class="line"><span class="comment">// 即 add(l[k], x);</span></span><br><span class="line"><span class="comment">// 因此双链表的插入操作只需实现一个即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除下标为k的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k]; <span class="comment">// k结点的右结点成为k结点左结点的右结点</span></span><br><span class="line">    l[r[k]] = l[k]; <span class="comment">// k结点的左结点成为k结点右结点的左结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        string op; <span class="comment">// 注意，此处op不能是char类型</span></span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;IL&quot;</span>) <span class="comment">// 注意，C++中双引号中间的数据视作字符串，单引号中间的数据视作字符，所以这里一定要用双引号</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表其实就是 n 个单链表</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>电子数据取证常见问题总结</title>
    <url>/2022/10/30/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇博客简单记录了我在备战2022长安杯电子数据取证比赛时的学习总结，今后也将继续学习继续更新……</p>
<span id="more"></span>

<h1 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h1><ol>
<li><p>需重点关注的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc	配置文件目录</span><br><span class="line">/home	用户文件夹</span><br><span class="line">/root	root用户文件夹</span><br><span class="line">/opt	额外安装的应用程序目录</span><br><span class="line">/var	日志文件目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>netstat -atnlp  &#x2F;&#x2F; 直接使用ip地址列出所有处于监听状态的TCP端口，且加上程序名</p>
</li>
<li><p>linux 终端查看文件用 more \ less \ vi \ cat</p>
</li>
<li><p>linux 镜像仿真后的起始路径都是用户目录（~），cd ..后可以返回系统根目录，然后再进行ls等一系列操作</p>
</li>
</ol>
<h1 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h1><ol>
<li>Windows 镜像仿真后可以关注一下快速访问、回收站等地方</li>
</ol>
<h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h1><ol>
<li>尝试理解看着像中文拼音缩写的字母，很多时候有助于解题，如 dl 就是代理的意思</li>
<li>有时如火眼证据分析软件会识别不到检材中的分区（即无法对该分区进行分析），此时需要手动选中该分区，右键-&gt;添加为新检材。国内取证软件的兼容性有时还是不太行，使用 FTK Imager 可以很好地避免此类问题</li>
</ol>
<h1 id="真题训练"><a href="#真题训练" class="headerlink" title="真题训练"></a>真题训练</h1><p>长安杯历年真题 → 美亚杯历年真题 → 创享杯历年真题</p>
<h1 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VeraCrypt</span><br><span class="line">FTK Imager</span><br><span class="line">雷电APP智能分析</span><br><span class="line">火眼仿真取证软件</span><br><span class="line">火眼证据分析软件</span><br><span class="line">取证大师</span><br><span class="line">网探勘验</span><br><span class="line">物联网取证分析</span><br><span class="line">雷电模拟器</span><br><span class="line">雷电手机快取</span><br><span class="line">VMware</span><br><span class="line">Navicat</span><br><span class="line">DB Browser SQLite</span><br><span class="line">IDA pro</span><br><span class="line">R-Studio</span><br><span class="line">dnSpy</span><br><span class="line">Fliddler</span><br><span class="line">Wireshark</span><br><span class="line">VScode</span><br><span class="line">X-Ways Forensics</span><br><span class="line">取证录像</span><br></pre></td></tr></table></figure>

<p><strong>注：相关软件需要联系客服获取授权</strong></p>
<h1 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h1><p><a href="https://forensics.xidian.edu.cn/wiki/">https://forensics.xidian.edu.cn/wiki/</a></p>
]]></content>
      <categories>
        <category>电子数据取证</category>
      </categories>
      <tags>
        <tag>电子数据取证</tag>
      </tags>
  </entry>
</search>
